{"id": "2601.02898", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2601.02898", "abs": "https://arxiv.org/abs/2601.02898", "authors": ["Wim Vanderbauwhede", "Lauritz Thamsen", "José Cano"], "title": "Proceedings of the 1st International Workshop on Low Carbon Computing (LOCO 2024)", "comment": "arXiv overlay proceedings for LOCO 2024. Living index of papers submitted individually", "summary": "This is the proceedings of the 1st International Workshop on Low Carbon Computing (LOCO 2024)."}
{"id": "2601.03197", "categories": ["cs.DC", "cs.MA"], "pdf": "https://arxiv.org/pdf/2601.03197", "abs": "https://arxiv.org/abs/2601.03197", "authors": ["Saurabh Agarwal", "Marco Laju", "Jayanth Srinivasa", "Myungjin Lee", "Aditya Akella"], "title": "Software-Defined Agentic Serving", "comment": null, "summary": "As multi-agent LLM pipelines grow in complexity, existing serving paradigms fail to adapt to the dynamic serving conditions. We argue that agentic serving systems should be programmable and system-aware, unlike existing serving which statically encode the parameters. In this work, we propose a new SDN-inspired agentic serving framework that helps control the key attributes of communication based on runtime state. This architecture enables serving-efficient, responsive agent systems and paves the way for high-level intent-driven agentic serving."}
{"id": "2601.02653", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.02653", "abs": "https://arxiv.org/abs/2601.02653", "authors": ["Ajay Brahmakshatriya", "Saman Amarasinghe", "Martin Rinard"], "title": "Backwards Data-Flow Analysis using Prophecy Variable in the BuildIt System", "comment": null, "summary": "Many program transformations and optimizations require information about the future behavior of the program. A standard way to obtain this information is to build an intermediate program representation, then use a backwards program analysis to propagate relevant information against the flow of control back to the transformation/optimization site. We instead propose to use prophecy variables, which predict information about the future execution of the program, to enable such transformations and optimizations. We implement prophecy variables in BuildIt, a lightweight domain specific language implementation system. BuildIt uses staged compilation to implement high performance domain specific languages embedded within a standard general purpose programming language (C++). The BuildIt first phase uses standard C++ program execution to generate optimized C, C++, and CUDA second phase code. This approach enables BuildIt to eliminate programming language implementation components such as parsers and intermediate representations, delivering a dramatic decrease in the engineering effort required to implement domain specific languages. The combination of prophecy variables and repeated forward program execution enables BuildIt to extend this approach to include transformations and optimizations that require information about the future execution of the program without backwards analyses and without the engineering overhead associated with implementing these analyses. We formalize the use of prophecy variables for this purpose, discuss the implementation of prophecy variables and repeated execution in BuildIt, and present experimental results for BuildIt computations that benefit from optimizations enabled by the information that prophecy variables provide."}
{"id": "2601.02613", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.02613", "abs": "https://arxiv.org/abs/2601.02613", "authors": ["Kuilian Yang", "Li Zhang", "Ahmed M. Eltawil", "Khaled Nabil Salama"], "title": "Sparsity-Aware Streaming SNN Accelerator with Output-Channel Dataflow for Automatic Modulation Classification", "comment": null, "summary": "The rapid advancement of wireless communication technologies, including 5G, emerging 6G networks, and the large-scale deployment of the Internet of Things (IoT), has intensified the need for efficient spectrum utilization. Automatic modulation classification (AMC) plays a vital role in cognitive radio systems by enabling real-time identification of modulation schemes for dynamic spectrum access and interference mitigation. While deep neural networks (DNNs) offer high classification accuracy, their computational and energy demands pose challenges for real-time edge deployment. Spiking neural networks (SNNs), with their event-driven nature, offer inherent energy efficiency, but achieving both high throughput and low power under constrained hardware resources remains challenging. This work proposes a sparsity-aware SNN streaming accelerator optimized for AMC tasks. Unlike traditional systolic arrays that exploit sparsity but suffer from low throughput, or streaming architectures that achieve high throughput but cannot fully utilize input and weight sparsity, our design integrates both advantages. By leveraging the fixed nature of kernels during inference, we apply the gated one-to-all product (GOAP) algorithm to compute only on non-zero input-weight intersections. Extra or empty iterations are precomputed and embedded into the inference dataflow, eliminating dynamic data fetches and enabling fully pipelined, control-free inter-layer execution. Implemented on an FPGA, our sparsity-aware output-channel dataflow streaming (SAOCDS) accelerator achieves 23.5 MS/s (approximately double the baseline throughput) on the RadioML 2016 dataset, while reducing dynamic power and maintaining comparable classification accuracy. These results demonstrate strong potential for real-time, low-power deployment in edge cognitive radio systems."}
{"id": "2601.02532", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2601.02532", "abs": "https://arxiv.org/abs/2601.02532", "authors": ["Manuel Lafond", "Francis Sarrazin"], "title": "A $O^*((2 + ε)^k)$ Time Algorithm for Cograph Deletion Using Unavoidable Subgraphs in Large Prime Graphs", "comment": null, "summary": "We study the parameterized complexity of the Cograph Deletion problem, which asks whether one can delete at most $k$ edges from a graph to make it $P_4$-free. This is a well-known graph modification problem with applications in computation biology and social network analysis.\n  All current parameterized algorithms use a similar strategy, which is to find a $P_4$ and explore the local structure around it to perform an efficient recursive branching.\n  The best known algorithm achieves running time $O^*(2.303^k)$ and requires an automated search of the branching cases due to their complexity.\n  Since it appears difficult to further improve the current strategy, we devise a new approach using modular decompositions. We solve each module and the quotient graph independently, with the latter being the core problem. This reduces the problem to solving on a prime graph, in which all modules are trivial. We then use a characterization of Chudnovsky et al. stating that any large enough prime graph has one of seven structures as an induced subgraph. These all have many $P_4$s, with the quantity growing linearly with the graph size, and we show that these allow a recursive branch tree algorithm to achieve running time $O^*((2 + ε)^k)$ for any $ε> 0$.\n  This appears to be the first algorithmic application of the prime graph characterization and it could be applicable to other modification problems. Towards this goal, we provide the exact set of graph classes $\\H$ for which the $\\H$-free editing problem can make use of our reduction to a prime graph, opening the door to improvements for other modification problems."}
{"id": "2601.02836", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2601.02836", "abs": "https://arxiv.org/abs/2601.02836", "authors": ["Klaus Jansen", "Felix Ohnesorge"], "title": "A Practical 73/50 Approximation for Contiguous Monotone Moldable Job Scheduling", "comment": "to appear in STACS 2026", "summary": "In moldable job scheduling, we are provided $m$ identical machines and $n$ jobs that can be executed on a variable number of machines. The execution time of each job depends on the number of machines assigned to execute that job. For the specific problem of monotone moldable job scheduling, jobs are assumed to have a processing time that is non-increasing in the number of machines.\n  The previous best-known algorithms are: (1) a polynomial-time approximation scheme with time complexity $Ω(n^{g(1/\\varepsilon)})$, where $g(\\cdot)$ is a super-exponential function [Jansen and Thöle '08; Jansen and Land '18], (2) a fully polynomial approximation scheme for the case of $m \\geq 8\\frac{n}{\\varepsilon}$ [Jansen and Land '18], and (3) a $\\frac{3}{2}$ approximation with time complexity $O(nm\\log(mn))$ [Wu, Zhang, and Chen '23].\n  We present a new practically efficient algorithm with an approximation ratio of $\\approx (1.4593 + \\varepsilon)$ and a time complexity of $O(nm \\log \\frac{1}{\\varepsilon})$. Our result also applies to the contiguous variant of the problem. In addition to our theoretical results, we implement the presented algorithm and show that the practical performance is significantly better than the theoretical worst-case approximation ratio."}
{"id": "2601.03020", "categories": ["cs.DS", "cs.CC", "cs.FL"], "pdf": "https://arxiv.org/pdf/2601.03020", "abs": "https://arxiv.org/abs/2601.03020", "authors": ["Taisei Nogami", "Tachio Terauchi"], "title": "Hardness of Regular Expression Matching with Extensions", "comment": null, "summary": "The regular expression matching problem asks whether a given regular expression of length $m$ matches a given string of length $n$. As is well known, the problem can be solved in $O(nm)$ time using Thompson's algorithm. Moreover, recent studies have shown that the matching problem for regular expressions extended with a practical extension called lookaround can be solved in the same time complexity. In this work, we consider three well-known extensions to regular expressions called backreference, intersection and complement, and we show that, unlike in the case of lookaround, the matching problem for regular expressions extended with any of the three (for backreference, even when restricted to one capturing group) cannot be solved in $O(n^{2-\\varepsilon} \\mathrm{poly}(m))$ time for any constant $\\varepsilon > 0$ under the Orthogonal Vectors Conjecture. Moreover, we study the matching problem for regular expressions extended with complement in more detail, which is also known as extended regular expression (ERE) matching. We show that there is no ERE matching algorithm that runs in $O(n^{ω-\\varepsilon} \\mathrm{poly}(m))$ time ($2 \\le ω< 2.3716$ is the exponent of square matrix multiplication) for any constant $\\varepsilon > 0$ under the $k$-Clique Hypothesis, and there is no combinatorial ERE matching algorithm that runs in $O(n^{3-\\varepsilon} \\mathrm{poly}(m))$ time for any constant $\\varepsilon > 0$ under the Combinatorial $k$-Clique Hypothesis. This shows that the $O(n^3 m)$-time algorithm introduced by Hopcroft and Ullman in 1979 and recently improved by Bille et al. to run in $O(n^ωm)$ time using fast matrix multiplication was already optimal in a sense, and sheds light on why the theoretical computer science community has struggled to improve the time complexity of ERE matching with respect to $n$ and $m$ for more than 45 years."}
{"id": "2601.03129", "categories": ["cs.DS", "cs.DM"], "pdf": "https://arxiv.org/pdf/2601.03129", "abs": "https://arxiv.org/abs/2601.03129", "authors": ["Matthias Bentert", "Tom-Lukas Breitkopf", "Vincent Froese", "Anton Herrmann", "André Nichterlein"], "title": "Density Matters: A Complexity Dichotomy of Deleting Edges to Bound Subgraph Density", "comment": "to appear at STACS 2026", "summary": "We study $τ$-Bounded-Density Edge Deletion ($τ$-BDED), where given an undirected graph $G$, the task is to remove as few edges as possible to obtain a graph $G'$ where no subgraph of $G'$ has density more than $τ$. The density of a (sub)graph is the number of edges divided by the number of vertices. This problem was recently introduced and shown to be NP-hard for $τ\\in \\{2/3, 3/4, 1 + 1/25\\}$, but polynomial-time solvable for $τ\\in \\{0,1/2,1\\}$ [Bazgan et al., JCSS 2025]. We provide a complete dichotomy with respect to the target density $τ$:\n  1. If $2τ\\in \\mathbb{N}$ (half-integral target density) or $τ< 2/3$, then $τ$-BDED is polynomial-time solvable.\n  2. Otherwise, $τ$-BDED is NP-hard.\n  We complement the NP-hardness with fixed-parameter tractability with respect to the treewidth of $G$. Moreover, for integral target density $τ\\in \\mathbb{N}$, we show $τ$-BDED to be solvable in randomized $O(m^{1 + o(1)})$ time. Our algorithmic results are based on a reduction to a new general flow problem on restricted networks that, depending on $τ$, can be solved via Maximum s-t-Flow or General Factors. We believe this connection between these variants of flow and matching to be of independent interest."}
