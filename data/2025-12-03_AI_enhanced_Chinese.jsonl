{"id": "2512.02083", "categories": ["cs.DS", "cs.CC"], "pdf": "https://arxiv.org/pdf/2512.02083", "abs": "https://arxiv.org/abs/2512.02083", "authors": ["Sangam Balchandar Reddy"], "title": "On the Complexity of Signed Roman Domination", "comment": "38 pages, 7 figures, Submitted to Elsevier", "summary": "Given a graph $G = (V, E)$, a signed Roman dominating function is a function $f: V \\rightarrow \\{-1, 1, 2\\}$ such that for every vertex $u \\in V$: $\\sum_{v \\in N[u]} f(v) \\geq 1$ and for every vertex $u \\in V$ with $f(u) = -1$, there exists a vertex $v \\in N(u)$ with $f(v) = 2$. The weight of a signed Roman dominating function $f$ is $\\sum_{u \\in V} f(u)$. The objective of \\srd{} (SRD) problem is to compute a signed Roman dominating function with minimum weight. The problem is known to be NP-complete even when restricted to bipartite graphs and planar graphs. In this paper, we advance the complexity study by showing that the problem remains NP-complete on split graphs. In the realm of parameterized complexity, we prove that the problem is W[2]-hard parameterized by weight, even on bipartite graphs. We further show that the problem is W[1]-hard parameterized by feedback vertex set number (and hence also when parameterized by treewidth or clique-width). On the positive side, we present an FPT algorithm parameterized by neighbourhood diversity (and by vertex cover number). Finally, we complement this result by proving that the problem does not admit a polynomial kernel parameterized by vertex cover number unless coNP $\\subseteq$ NP/poly.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e\u56fe\u5904\u7406\u76f8\u5173\u3002\n\u592a\u957f\u4e0d\u770b\u7248\uff1a\u5e26\u7b26\u53f7\u7f57\u9a6c\u652f\u914d\uff08SRD\uff09\u95ee\u9898\u662f\u4e00\u4e2a\u56fe\u8bba\u4f18\u5316\u95ee\u9898\uff0c\u65e8\u5728\u627e\u5230\u6700\u5c0f\u6743\u91cd\u7684\u5e26\u7b26\u53f7\u7f57\u9a6c\u652f\u914d\u51fd\u6570\u3002\u672c\u6587\u8bc1\u660e\u4e86 SRD \u95ee\u9898\u5728\u5206\u88c2\u56fe\u4e0a\u4ecd\u662f NP-\u5b8c\u5168\u7684\uff0c\u5e76\u5728\u53c2\u6570\u5316\u590d\u6742\u6027\u65b9\u9762\u53d6\u5f97\u4e86\u7cfb\u5217\u7ed3\u679c\uff1a\u4ee5\u6743\u91cd\u4e3a\u53c2\u6570\u662f W[2]-hard\uff08\u5728\u4e8c\u5206\u56fe\u4e0a\uff09\uff0c\u4ee5\u53cd\u9988\u70b9\u96c6\u6570\u4e3a\u53c2\u6570\u662f W[1]-hard\u3002\u540c\u65f6\uff0c\u63d0\u51fa\u4e00\u4e2a\u4ee5\u90bb\u57df\u591a\u6837\u6027\uff08\u548c\u70b9\u8986\u76d6\u6570\uff09\u4e3a\u53c2\u6570\u7684 FPT \u7b97\u6cd5\uff0c\u5e76\u8bc1\u660e\u4e86\u4ee5\u70b9\u8986\u76d6\u6570\u4e3a\u53c2\u6570\u4e0d\u5b58\u5728\u591a\u9879\u5f0f\u6838\uff08\u9664\u975e coNP $\\subseteq$ NP/poly\uff09\u3002", "motivation": "\u5e26\u7b26\u53f7\u7f57\u9a6c\u652f\u914d\uff08SRD\uff09\u95ee\u9898\u662f\u4e00\u4e2a\u5df2\u77e5\u7684 NP-\u5b8c\u5168\u95ee\u9898\uff0c\u5373\u4f7f\u5728\u4e8c\u5206\u56fe\u548c\u5e73\u9762\u56fe\u4e0a\u4e5f\u662f\u5982\u6b64\u3002\u672c\u6587\u7684\u52a8\u673a\u662f\u6df1\u5165\u63a2\u7a76\u8fd9\u4e2a\u95ee\u9898\u7684\u8ba1\u7b97\u590d\u6742\u6027\uff0c\u7279\u522b\u662f\u5728\u66f4\u5177\u9650\u5236\u6027\u7684\u56fe\u7c7b\u4e0a\uff08\u5982\u5206\u88c2\u56fe\uff09\u7684\u7ecf\u5178\u590d\u6742\u6027\uff0c\u5e76\u4ece\u53c2\u6570\u5316\u590d\u6742\u6027\u7684\u89d2\u5ea6\uff0c\u7406\u89e3\u4e0d\u540c\u56fe\u7ed3\u6784\u53c2\u6570\u5bf9\u95ee\u9898\u53ef\u89e3\u6027\u7684\u5f71\u54cd\uff0c\u4ee5\u671f\u627e\u5230\u5728\u67d0\u4e9b\u53c2\u6570\u4e0b\u53ef\u9ad8\u6548\u6c42\u89e3\u7684\u65b9\u6cd5\uff08FPT\uff09\u6216\u8bc1\u660e\u5176\u5185\u5728\u7684\u56f0\u96be\u6027\uff08W-hard\uff09\u3002", "method": "\u672c\u6587\u4e3b\u8981\u91c7\u7528\u590d\u6742\u6027\u7406\u8bba\u548c\u56fe\u7b97\u6cd5\u8bbe\u8ba1\u7684\u65b9\u6cd5\u3002\u9996\u5148\uff0c\u901a\u8fc7\u5f52\u7ea6\u8bc1\u660e\u4e86\u5e26\u7b26\u53f7\u7f57\u9a6c\u652f\u914d\u51fd\u6570\u95ee\u9898\u5728\u5206\u88c2\u56fe\u4e0a\u7684 NP-\u5b8c\u5168\u6027\u3002\u63a5\u7740\uff0c\u5e94\u7528\u53c2\u6570\u5316\u590d\u6742\u6027\u7406\u8bba\uff0c\u901a\u8fc7\u8bbe\u8ba1\u89c4\u7ea6\u6216\u5c55\u793a\u786c\u5ea6\u8bc1\u660e\uff0c\u6765\u7814\u7a76\u95ee\u9898\u5728\u4e0d\u540c\u7ed3\u6784\u53c2\u6570\u4e0b\u7684\u590d\u6742\u6027\uff0c\u4f8b\u5982\u6743\u91cd\u3001\u53cd\u9988\u70b9\u96c6\u6570\u3001\u6811\u5bbd\u3001\u90bb\u57df\u591a\u6837\u6027\u3001\u70b9\u8986\u76d6\u6570\u7b49\u3002\u5177\u4f53\u5305\u62ec\u8bc1\u660e W[2]-hard \u548c W[1]-hard\uff0c\u4ee5\u53ca\u8bbe\u8ba1 FPT \u7b97\u6cd5\u3002\u6700\u540e\uff0c\u5229\u7528\u6838\u5316\u7406\u8bba\u8bc1\u660e\u4e86\u4e0d\u5b58\u5728\u591a\u9879\u5f0f\u6838\u7684\u7ed3\u679c\u3002", "result": "\u672c\u6587\u5728\u7406\u8bba\u590d\u6742\u6027\u65b9\u9762\u53d6\u5f97\u4e86\u591a\u9879\u91cd\u8981\u7ed3\u679c\uff1a1. \u8bc1\u660e\u4e86 SRD \u95ee\u9898\u5728\u5206\u88c2\u56fe\u4e0a\u4ecd\u7136\u662f NP-\u5b8c\u5168\u7684\u30022. \u5728\u53c2\u6570\u5316\u590d\u6742\u6027\u65b9\u9762\uff0c\u8bc1\u660e\u4e86\u5728\u4e8c\u5206\u56fe\u4e0a\u4ee5\u76ee\u6807\u6743\u91cd\u4e3a\u53c2\u6570\uff0c\u95ee\u9898\u662f W[2]-hard \u7684\u30023. \u8bc1\u660e\u4e86\u4ee5\u53cd\u9988\u70b9\u96c6\u6570\uff08\u56e0\u6b64\u4e5f\u5305\u62ec\u6811\u5bbd\u548c\u56e2\u5bbd\uff09\u4e3a\u53c2\u6570\uff0c\u95ee\u9898\u662f W[1]-hard \u7684\u30024. \u5728\u79ef\u6781\u65b9\u9762\uff0c\u63d0\u51fa\u4e86\u4e00\u4e2a\u4ee5\u90bb\u57df\u591a\u6837\u6027\uff08\u4ee5\u53ca\u70b9\u8986\u76d6\u6570\uff09\u4e3a\u53c2\u6570\u7684 FPT \u7b97\u6cd5\u30025. \u8bc1\u660e\u4e86\u8be5\u95ee\u9898\u4e0d\u5b58\u5728\u4ee5\u70b9\u8986\u76d6\u6570\u4e3a\u53c2\u6570\u7684\u591a\u9879\u5f0f\u6838\uff0c\u9664\u975e coNP $\\subseteq$ NP/poly\u3002", "conclusion": "\u672c\u6587\u7814\u7a76\u4e86\u5e26\u7b26\u53f7\u7f57\u9a6c\u652f\u914d\u51fd\u6570\uff08Signed Roman Dominating Function, SRDF\uff09\u95ee\u9898\uff0c\u786e\u5b9a\u4e86\u8be5\u95ee\u9898\u5728\u5206\u88c2\u56fe\u4e0a\u4ecd\u7136\u662f NP-\u5b8c\u5168\u7684\u3002\u5728\u53c2\u6570\u5316\u590d\u6742\u6027\u65b9\u9762\uff0c\u8bc1\u660e\u4e86\u8be5\u95ee\u9898\u5728\u4e8c\u5206\u56fe\u4e0a\u4ee5\u76ee\u6807\u6743\u91cd\u4e3a\u53c2\u6570\u662f W[2]-hard \u7684\uff0c\u4ee5\u53cd\u9988\u70b9\u96c6\u3001\u6811\u5bbd\u6216\u56e2\u5bbd\u4e3a\u53c2\u6570\u662f W[1]-hard \u7684\u3002\u540c\u65f6\uff0c\u5728\u6b63\u9762\u4e0a\uff0c\u63d0\u51fa\u4e86\u4e00\u4e2a\u4ee5\u90bb\u57df\u591a\u6837\u6027\uff08\u4ee5\u53ca\u70b9\u8986\u76d6\u6570\uff09\u4e3a\u53c2\u6570\u7684 FPT \u7b97\u6cd5\u3002\u6700\u540e\uff0c\u901a\u8fc7\u8bc1\u660e\u8be5\u95ee\u9898\u4e0d\u5b58\u5728\u4ee5\u70b9\u8986\u76d6\u6570\u4e3a\u53c2\u6570\u7684\u591a\u9879\u5f0f\u6838\uff08\u9664\u975e coNP $\\subseteq$ NP/poly\uff09\uff0c\u5b8c\u5584\u4e86\u7ed3\u679c\u3002\u8fd9\u4e9b\u7ed3\u679c\u5168\u9762\u5730\u63a2\u8ba8\u4e86 SRD \u95ee\u9898\u7684\u8ba1\u7b97\u590d\u6742\u6027\uff0c\u65e0\u8bba\u662f\u5728\u7ecf\u5178\u590d\u6742\u6027\u8fd8\u662f\u53c2\u6570\u5316\u590d\u6742\u6027\u65b9\u9762\u3002"}}
{"id": "2512.02384", "categories": ["cs.DS", "math.PR"], "pdf": "https://arxiv.org/pdf/2512.02384", "abs": "https://arxiv.org/abs/2512.02384", "authors": ["Amit Rajaraman", "David X. Wu"], "title": "Markov Chains Approximate Message Passing", "comment": "41 pages, 2 figures", "summary": "Markov chain Monte Carlo algorithms have long been observed to obtain near-optimal performance in various Bayesian inference settings. However, developing a supporting theory that make these studies rigorous has proved challenging.\n  In this paper, we study the classical spiked Wigner inference problem, where one aims to recover a planted Boolean spike from a noisy matrix measurement. We relate the recovery performance of Glauber dynamics on the annealed posterior to the performance of Approximate Message Passing (AMP), which is known to achieve Bayes-optimal performance. Our main results rely on the analysis of an auxiliary Markov chain called restricted Gaussian dynamics (RGD). Concretely, we establish the following results:\n  1. RGD can be reduced to an effective one-dimensional recursion which mirrors the evolution of the AMP iterates.\n  2. From a warm start, RGD rapidly converges to a fixed point in correlation space, which recovers Bayes-optimal performance when run on the posterior.\n  3. Conditioned on widely believed mixing results for the SK model, we recover the phase transition for non-trivial inference.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e DSL\u3001\u56fe\u5904\u7406\u3001MLIR\u3001\u7f16\u8bd1\u5668\u6216 HLS \u65e0\u5173\u3002\n\n\u5c3d\u7ba1\u9a6c\u5c14\u53ef\u592b\u94fe\u8499\u7279\u5361\u6d1b\uff08MCMC\uff09\u7b97\u6cd5\u5728\u8d1d\u53f6\u65af\u63a8\u65ad\u4e2d\u8868\u73b0\u51fa\u8fd1\u4e4e\u6700\u4f18\u7684\u6027\u80fd\uff0c\u4f46\u5176\u7406\u8bba\u652f\u6301\u4ecd\u5177\u6311\u6218\u3002\u672c\u6587\u7814\u7a76\u4e86\u68d8\u6ce2\u7ef4\u683c\u7eb3\u63a8\u65ad\u95ee\u9898\uff0c\u5c06\u9000\u706b\u540e\u9a8c\u4e0a\u7684 Glauber \u52a8\u529b\u5b66\u6062\u590d\u6027\u80fd\u4e0e\u8d1d\u53f6\u65af\u6700\u4f18\u7684\u8fd1\u4f3c\u6d88\u606f\u4f20\u9012\uff08AMP\uff09\u7b97\u6cd5\u8054\u7cfb\u8d77\u6765\u3002\u901a\u8fc7\u5206\u6790\u8f85\u52a9\u7684\u53d7\u9650\u9ad8\u65af\u52a8\u529b\u5b66\uff08RGD\uff09\uff0c\u7814\u7a76\u8bc1\u660e RGD \u53ef\u7b80\u5316\u4e3a\u53cd\u6620 AMP \u6f14\u5316\u7684\u4e00\u7ef4\u9012\u5f52\uff0c\u5e76\u80fd\u4ece\u6696\u542f\u52a8\u5feb\u901f\u6536\u655b\u5230\u4e0d\u52a8\u70b9\u4ee5\u6062\u590d\u8d1d\u53f6\u65af\u6700\u4f18\u6027\u80fd\u3002\u6b64\u5916\uff0c\u5728 SK \u6a21\u578b\u6df7\u5408\u7ed3\u679c\u7684\u6761\u4ef6\u4e0b\uff0c\u672c\u6587\u6062\u590d\u4e86\u975e\u5e73\u51e1\u63a8\u65ad\u7684\u76f8\u53d8\u3002", "motivation": "\u9a6c\u5c14\u53ef\u592b\u94fe\u8499\u7279\u5361\u6d1b\uff08MCMC\uff09\u7b97\u6cd5\u5728\u5404\u79cd\u8d1d\u53f6\u65af\u63a8\u65ad\u8bbe\u7f6e\u4e2d\u88ab\u89c2\u5bdf\u5230\u63a5\u8fd1\u6700\u4f18\u6027\u80fd\uff0c\u4f46\u7f3a\u4e4f\u4e25\u8c28\u7684\u7406\u8bba\u652f\u6301\u6765\u8bc1\u5b9e\u8fd9\u4e9b\u89c2\u5bdf\u7ed3\u679c\uff0c\u8fd9\u6fc0\u53d1\u4e86\u672c\u6587\u7684\u7814\u7a76\u3002\u672c\u6587\u65e8\u5728\u901a\u8fc7\u7406\u8bba\u5206\u6790\u68d8\u6ce2\u7ef4\u683c\u7eb3\u63a8\u65ad\u95ee\u9898\u4e2d Glauber \u52a8\u529b\u5b66\u7684\u6062\u590d\u6027\u80fd\uff0c\u5e76\u5c06\u5176\u4e0e\u5df2\u77e5\u7684\u8d1d\u53f6\u65af\u6700\u4f18\u7b97\u6cd5\uff08AMP\uff09\u8054\u7cfb\u8d77\u6765\uff0c\u4ee5\u63d0\u4f9b MCMC \u6027\u80fd\u7684\u7406\u8bba\u4f9d\u636e\u3002", "method": "\u672c\u6587\u901a\u8fc7\u7814\u7a76\u7ecf\u5178\u68d8\u6ce2\u7ef4\u683c\u7eb3\u63a8\u65ad\u95ee\u9898\uff0c\u5c06 Glauber \u52a8\u529b\u5b66\u5728\u9000\u706b\u540e\u9a8c\u4e0a\u7684\u6062\u590d\u6027\u80fd\u4e0e\u8fd1\u4f3c\u6d88\u606f\u4f20\u9012\uff08AMP\uff09\u7b97\u6cd5\u7684\u6027\u80fd\u8054\u7cfb\u8d77\u6765\u3002\u6838\u5fc3\u65b9\u6cd5\u662f\u5206\u6790\u4e00\u4e2a\u79f0\u4e3a\u53d7\u9650\u9ad8\u65af\u52a8\u529b\u5b66\uff08RGD\uff09\u7684\u8f85\u52a9\u9a6c\u5c14\u53ef\u592b\u94fe\u3002\u5177\u4f53\u5305\u62ec\uff1a1. \u8bc1\u660e RGD \u53ef\u7b80\u5316\u4e3a\u53cd\u6620 AMP \u8fed\u4ee3\u6f14\u5316\u7684\u4e00\u7ef4\u9012\u5f52\u30022. \u8bc1\u660e RGD \u4ece\u6696\u542f\u52a8\u5f00\u59cb\u80fd\u5feb\u901f\u6536\u655b\u5230\u76f8\u5173\u6027\u7a7a\u95f4\u4e2d\u7684\u4e0d\u52a8\u70b9\u30023. \u5728 SK \u6a21\u578b\u6df7\u5408\u7ed3\u679c\u7684\u5047\u8bbe\u4e0b\uff0c\u5206\u6790\u4e86\u975e\u5e73\u51e1\u63a8\u65ad\u7684\u76f8\u53d8\u3002", "result": "\u672c\u6587\u53d6\u5f97\u4e86\u4ee5\u4e0b\u7ed3\u679c\uff1a1. \u53d7\u9650\u9ad8\u65af\u52a8\u529b\u5b66\uff08RGD\uff09\u53ef\u4ee5\u7b80\u5316\u4e3a\u4e00\u4e2a\u6709\u6548\u7684\u4e00\u7ef4\u9012\u5f52\uff0c\u8be5\u9012\u5f52\u53cd\u6620\u4e86\u8fd1\u4f3c\u6d88\u606f\u4f20\u9012\uff08AMP\uff09\u8fed\u4ee3\u7684\u6f14\u5316\u30022. \u4ece\u201c\u6696\u542f\u52a8\u201d\u5f00\u59cb\uff0cRGD \u80fd\u5728\u76f8\u5173\u6027\u7a7a\u95f4\u4e2d\u8fc5\u901f\u6536\u655b\u5230\u4e00\u4e2a\u4e0d\u52a8\u70b9\uff0c\u8fd9\u5728\u5e94\u7528\u4e8e\u540e\u9a8c\u65f6\u6062\u590d\u4e86\u8d1d\u53f6\u65af\u6700\u4f18\u6027\u80fd\u30023. \u5047\u8bbe SK \u6a21\u578b\u5e7f\u6cdb\u63a5\u53d7\u7684\u6df7\u5408\u7ed3\u679c\u6210\u7acb\uff0c\u672c\u6587\u6062\u590d\u4e86\u975e\u5e73\u51e1\u63a8\u65ad\u7684\u76f8\u53d8\u3002", "conclusion": "\u672c\u6587\u7814\u7a76\u4e86 Glauber \u52a8\u529b\u5b66\u5728\u9000\u706b\u540e\u9a8c\u4e0a\u7684\u6062\u590d\u6027\u80fd\uff0c\u5e76\u5c06\u5176\u4e0e\u5df2\u77e5\u80fd\u8fbe\u5230\u8d1d\u53f6\u65af\u6700\u4f18\u6027\u80fd\u7684\u8fd1\u4f3c\u6d88\u606f\u4f20\u9012\uff08AMP\uff09\u7b97\u6cd5\u7684\u6027\u80fd\u8054\u7cfb\u8d77\u6765\u3002\u7814\u7a76\u8868\u660e\uff0c\u8f85\u52a9\u7684\u53d7\u9650\u9ad8\u65af\u52a8\u529b\u5b66\uff08RGD\uff09\u53ef\u4ee5\u7b80\u5316\u4e3a\u53cd\u6620 AMP \u8fed\u4ee3\u6f14\u5316\u7684\u4e00\u7ef4\u9012\u5f52\uff0c\u5e76\u4e14 RGD \u4ece\u201c\u6696\u542f\u52a8\u201d\u5f00\u59cb\u80fd\u5feb\u901f\u6536\u655b\u5230\u76f8\u5173\u6027\u7a7a\u95f4\u4e2d\u7684\u4e0d\u52a8\u70b9\uff0c\u4ece\u800c\u6062\u590d\u8d1d\u53f6\u65af\u6700\u4f18\u6027\u80fd\u3002\u5728\u5047\u8bbe SK \u6a21\u578b\u6df7\u5408\u7ed3\u679c\u6210\u7acb\u7684\u6761\u4ef6\u4e0b\uff0c\u8fd8\u80fd\u6062\u590d\u51fa\u975e\u5e73\u51e1\u63a8\u65ad\u7684\u76f8\u53d8\u3002\u8fd9\u4e9b\u7ed3\u679c\u4e3a\u7406\u89e3 MCMC \u7b97\u6cd5\u5728\u8d1d\u53f6\u65af\u63a8\u65ad\u4e2d\u7684\u8fd1\u4e4e\u6700\u4f18\u6027\u80fd\u63d0\u4f9b\u4e86\u7406\u8bba\u652f\u6301\u3002"}}
{"id": "2512.02412", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.02412", "abs": "https://arxiv.org/abs/2512.02412", "authors": ["Arnav Burudgunte", "Paul Valiant", "Hongao Wang"], "title": "New Bounds for Circular Trace Reconstruction", "comment": null, "summary": "The ''trace reconstruction'' problem asks, given an unknown binary string $x$ and a channel that repeatedly returns ''traces'' of $x$ with each bit randomly deleted with some probability $p$, how many traces are needed to recover $x$? There is an exponential gap between the best known upper and lower bounds for this problem. Many variants of the model have been introduced in hopes of motivating or revealing new approaches to narrow this gap. We study the variant of circular trace reconstruction introduced by Narayanan and Ren (ITCS 2021), in which traces undergo a random cyclic shift in addition to random deletions.\n  We show an improved lower bound of $\\tilde\u03a9(n^5)$ for circular trace reconstruction. This contrasts with the (previously) best known lower bounds of $\\tilde\u03a9(n^3)$ in the circular case and $\\tilde\u03a9(n^{3/2})$ in the linear case. Our bound shows the indistinguishability of traces from two sparse strings $x,y$ that each have a constant number of nonzeros. Can this technique be extended significantly? How hard is it to reconstruct a sparse string $x$ under a cyclic deletion channel? We resolve these questions by showing, using Fourier techniques, that $\\tilde{O}(n^6)$ traces suffice for reconstructing any constant-sparse string in a circular deletion channel, in contrast to the upper bound of $\\exp(\\tilde{O}(n^{1/3}))$ for general strings in the circular deletion channel. This shows that new algorithms or new lower bounds must focus on non-constant-sparse strings.", "AI": {"tldr": "\u5173\u8054\u9886\u57df\uff1a\u65e0\u3002\n\u592a\u957f\u4e0d\u8bfb\uff1a\u8f68\u8ff9\u91cd\u6784\u662f\u7ed9\u5b9a\u4e00\u4e2a\u672a\u77e5\u4e8c\u8fdb\u5236\u5b57\u7b26\u4e32 $x$\uff0c\u901a\u8fc7\u4e00\u4e2a\u901a\u9053\u91cd\u590d\u8fd4\u56de $x$ \u7684\u201c\u8f68\u8ff9\u201d\u6765\u6062\u590d $x$\uff0c\u5176\u4e2d $x$ \u7684\u6bcf\u4e2a\u4f4d\u90fd\u4ee5\u4e00\u5b9a\u6982\u7387\u88ab\u968f\u673a\u5220\u9664\uff0c\u95ee\u9700\u8981\u591a\u5c11\u6761\u8f68\u8ff9\uff1f\u6700\u4f73\u5df2\u77e5\u4e0a\u754c\u548c\u4e0b\u754c\u4e4b\u95f4\u5b58\u5728\u5de8\u5927\u7684\u6307\u6570\u7ea7\u5dee\u8ddd\u3002\u672c\u6587\u7814\u7a76\u4e86\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u53d8\u4f53\uff0c\u5176\u4e2d\u8f68\u8ff9\u9664\u4e86\u968f\u673a\u5220\u9664\u5916\uff0c\u8fd8\u4f1a\u7ecf\u5386\u4e00\u4e2a\u968f\u673a\u5faa\u73af\u79fb\u4f4d\u3002\u6211\u4eec\u8bc1\u660e\u4e86\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u7684\u6539\u8fdb\u4e0b\u754c\u4e3a $\\tilde{\\Omega}(n^5)$\uff0c\u8d85\u8fc7\u4e86\u6b64\u524d\u6700\u4f73\u7684\u7ebf\u6027\u60c5\u51b5\u4e0b\u7684 $\\tilde{\\Omega}(n^{3/2})$ \u548c\u5706\u5468\u60c5\u51b5\u4e0b\u7684 $\\tilde{\\Omega}(n^3)$\u3002\u8be5\u4e0b\u754c\u662f\u901a\u8fc7\u6784\u5efa\u4e24\u5bf9\u5e38\u91cf\u6570\u91cf\u975e\u96f6\u5143\u7d20\u7684\u7a00\u758f\u5b57\u7b26\u4e32 $x, y$ \u7684\u8f68\u8ff9\u65e0\u6cd5\u533a\u5206\u6765\u8bc1\u660e\u7684\u3002\u6211\u4eec\u8fd8\u89e3\u51b3\u4e86\u7a00\u758f\u5b57\u7b26\u4e32\u5728\u5faa\u73af\u5220\u9664\u901a\u9053\u4e0b\u7684\u91cd\u6784\u96be\u5ea6\uff0c\u5229\u7528\u5085\u91cc\u53f6\u6280\u672f\u8bc1\u660e\u4e86\u91cd\u6784\u4efb\u610f\u5e38\u6570\u7a00\u758f\u5b57\u7b26\u4e32\u4ec5\u9700 $\\tilde{O}(n^6)$ \u6761\u8f68\u8ff9\uff0c\u8fdc\u4f4e\u4e8e\u4e00\u822c\u5b57\u7b26\u4e32\u5728\u5706\u5468\u5220\u9664\u901a\u9053\u4e2d\u7684\u6307\u6570\u7ea7\u4e0a\u754c $\\exp(\\tilde{O}(n^{1/3}))$\u3002\u8fd9\u8868\u660e\u65b0\u7684\u7b97\u6cd5\u6216\u65b0\u7684\u4e0b\u754c\u5fc5\u987b\u5173\u6ce8\u975e\u7a00\u758f\u7684\u5b57\u7b26\u4e32\u3002", "motivation": "\u201c\u8f68\u8ff9\u91cd\u6784\u201d\u95ee\u9898\u4e2d\uff0c\u5df2\u77e5\u6700\u4f73\u4e0a\u754c\u548c\u4e0b\u754c\u4e4b\u95f4\u5b58\u5728\u6307\u6570\u7ea7\u7684\u5dee\u8ddd\u3002\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u662f\u8be5\u95ee\u9898\u7684\u4e00\u4e2a\u53d8\u4f53\uff0c\u901a\u8fc7\u5f15\u5165\u968f\u673a\u5faa\u73af\u79fb\u4f4d\u548c\u968f\u673a\u5220\u9664\uff0c\u5e0c\u671b\u80fd\u6fc0\u53d1\u6216\u63ed\u793a\u7f29\u5c0f\u8fd9\u4e00\u5dee\u8ddd\u7684\u65b0\u65b9\u6cd5\u3002\u672c\u6587\u65e8\u5728\u6539\u8fdb\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u95ee\u9898\u7684\u5df2\u77e5\u4e0b\u754c\uff0c\u5e76\u63a2\u8ba8\u7a00\u758f\u5b57\u7b26\u4e32\u5728\u5faa\u73af\u5220\u9664\u901a\u9053\u4e0b\u7684\u91cd\u6784\u96be\u5ea6\u3002", "method": "\u672c\u6587\u91c7\u7528\u6784\u5efa\u4e0d\u6613\u533a\u5206\u7684\u7a00\u758f\u5b57\u7b26\u4e32\u5bf9\u7684\u65b9\u6cd5\u6765\u8bc1\u660e\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u7684\u6539\u8fdb\u4e0b\u754c $\\tilde{\\Omega}(n^5)$\u3002\u5bf9\u4e8e\u7a00\u758f\u5b57\u7b26\u4e32\u7684\u91cd\u6784\u4e0a\u754c $\\tilde{O}(n^6)$\uff0c\u672c\u6587\u4f7f\u7528\u4e86\u5085\u91cc\u53f6\u6280\u672f\u8fdb\u884c\u8bc1\u660e\u3002", "result": "\u672c\u6587\u5c06\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u7684\u4e0b\u754c\u6539\u8fdb\u81f3 $\\tilde{\\Omega}(n^5)$\uff0c\u800c\u6b64\u524d\u5df2\u77e5\u7684\u6700\u4f73\u4e0b\u754c\u5728\u7ebf\u6027\u60c5\u51b5\u4e0b\u4e3a $\\tilde{\\Omega}(n^{3/2})$\uff0c\u5728\u5706\u5468\u60c5\u51b5\u4e0b\u4e3a $\\tilde{\\Omega}(n^3)$\u3002\u6b64\u5916\uff0c\u672c\u6587\u8bc1\u660e\u4e86\u5728\u5faa\u73af\u5220\u9664\u901a\u9053\u4e2d\uff0c\u91cd\u6784\u4efb\u610f\u5e38\u6570\u7a00\u758f\u5b57\u7b26\u4e32\u4ec5\u9700 $\\tilde{O}(n^6)$ \u6761\u8f68\u8ff9\uff0c\u800c\u5728\u5706\u5468\u5220\u9664\u901a\u9053\u4e2d\uff0c\u91cd\u6784\u4e00\u822c\u5b57\u7b26\u4e32\u7684\u4e0a\u754c\u4e3a $\\exp(\\tilde{O}(n^{1/3}))$\u3002", "conclusion": "\u672c\u6587\u7814\u7a76\u4e86\u5706\u5468\u8f68\u8ff9\u91cd\u6784\u53d8\u4f53\u95ee\u9898\uff0c\u5e76\u8bc1\u660e\u4e86\u91cd\u6784\u7a00\u758f\u5ea6\u4e3a\u5e38\u6570\u7684\u5b57\u7b26\u4e32\u6240\u9700\u7684\u8f68\u8ff9\u6570\u91cf\u4e0a\u754c\u4e3a $\\tilde{O}(n^6)$ \u6b21\uff0c\u4e0b\u754c\u4e3a $\\tilde{\\Omega}(n^5)$ \u6b21\uff0c\u8fd9\u4e0e\u4e00\u822c\u5b57\u7b26\u4e32\u5728\u5706\u5468\u5220\u9664\u901a\u9053\u4e2d\u7684\u6307\u6570\u7ea7\u4e0a\u754c\u5f62\u6210\u4e86\u9c9c\u660e\u5bf9\u6bd4\uff0c\u8868\u660e\u4e86\u672a\u6765\u7b97\u6cd5\u6216\u4e0b\u754c\u7684\u7814\u7a76\u5e94\u7740\u91cd\u4e8e\u975e\u7a00\u758f\u7684\u5b57\u7b26\u4e32\u3002"}}
{"id": "2512.02189", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.02189", "abs": "https://arxiv.org/abs/2512.02189", "authors": ["Aaron Jarmusch", "Sunita Chandrasekaran"], "title": "Microbenchmarking NVIDIA's Blackwell Architecture: An in-depth Architectural Analysis", "comment": null, "summary": "As GPU architectures rapidly evolve to meet the overcoming demands of exascale computing and machine learning, the performance implications of architectural innovations remain poorly understood across diverse workloads. NVIDIA's Blackwell (B200) generation introduce significant architectural advances including the 5th generation tensor cores, tensor memory (TMEM), decompression engine (DE), and dual chips; however systematic methodologies for quantifying these improvements lag behind hardware development cycles. We contribute an open-source microbenchmark suite that offers practical insights into optimizing workloads to fully utilize the rich feature sets of the modern GPU architecture. This work aims to enable application developers make informed architectural decisions and guide future GPU design directions.\n  Our work studies Blackwell GPUs, compares them to H200 generation with regards to the memory subsystem, tensor core pipeline and floating-point precisions (FP32, FP16, FP8, FP6, FP4). Our systematic evaluation of dense/sparse GEMM, transformer inference, and training workloads demonstrate that B200's tensor core enhancements achieves 1.56x higher mixed-precision throughput and 42% better energy efficiency than H200. Our memory analysis reveals 58% reduction in memory access latency in cache-misses, fundamentally changing optimal algorithm design strategies.", "AI": {"tldr": "\u5173\u8054\u5206\u6790\uff1a\u8be5\u8bba\u6587\u4e0eDSL\u3001\u56fe\u5f62\u5904\u7406\u3001MLIR\u3001\u7f16\u8bd1\u5668\u6216HLS\u5747\u4e0d\u76f4\u63a5\u76f8\u5173\uff0c\u5b83\u4e13\u6ce8\u4e8eGPU\u67b6\u6784\u6027\u80fd\u8bc4\u4f30\u548c\u5e95\u5c42\u4f18\u5316\u3002\n\u592a\u957f\u4e0d\u770b(TLDR)\uff1aNVIDIA Blackwell (B200) GPU\u5728\u67b6\u6784\u4e0a\u8fdb\u884c\u4e86\u91cd\u5927\u5347\u7ea7\uff0c\u5305\u62ec\u7b2c\u4e94\u4ee3Tensor Core\u548cTensor Memory\u7b49\u3002\u672c\u6587\u8d21\u732e\u4e86\u4e00\u4e2a\u5f00\u6e90\u5fae\u57fa\u51c6\u6d4b\u8bd5\u5957\u4ef6\uff0c\u5bf9B200\u4e0eH200\u8fdb\u884c\u7cfb\u7edf\u6027\u8bc4\u4f30\uff0c\u7ed3\u679c\u663e\u793aB200\u5728\u6df7\u5408\u7cbe\u5ea6\u541e\u5410\u91cf\u4e0a\u63d0\u9ad8\u4e861.56\u500d\uff0c\u80fd\u6548\u63d0\u9ad8\u4e8642%\uff0c\u4e14\u5185\u5b58\u8bbf\u95ee\u5ef6\u8fdf\u51cf\u5c11\u4e8658%\uff0c\u8fd9\u4e3a\u4f18\u5316\u7b97\u6cd5\u548c\u6307\u5bfc\u672a\u6765GPU\u8bbe\u8ba1\u63d0\u4f9b\u4e86\u5173\u952e\u6d1e\u5bdf\u3002", "motivation": "\u968f\u7740GPU\u67b6\u6784\u7684\u5feb\u901f\u53d1\u5c55\u4ee5\u6ee1\u8db3\u767e\u4ebf\u4ebf\u6b21\u7ea7\u8ba1\u7b97\u548c\u673a\u5668\u5b66\u4e60\u7684\u9700\u6c42\uff0c\u67b6\u6784\u521b\u65b0\u5bf9\u4e0d\u540c\u5de5\u4f5c\u8d1f\u8f7d\u7684\u6027\u80fd\u5f71\u54cd\u5c1a\u672a\u88ab\u5145\u5206\u7406\u89e3\u3002\u7279\u522b\u662fNVIDIA Blackwell (B200) \u5f15\u5165\u4e86\u663e\u8457\u7684\u65b0\u7279\u6027\uff0c\u4f46\u7f3a\u4e4f\u7cfb\u7edf\u6027\u7684\u65b9\u6cd5\u6765\u91cf\u5316\u8fd9\u4e9b\u6539\u8fdb\uff0c\u4ece\u800c\u963b\u788d\u4e86\u5e94\u7528\u5f00\u53d1\u8005\u505a\u51fa\u660e\u667a\u7684\u67b6\u6784\u51b3\u7b56\u548c\u65b0\u7684GPU\u8bbe\u8ba1\u65b9\u5411\u3002\u4f5c\u8005\u65e8\u5728\u901a\u8fc7\u63d0\u4f9b\u4e00\u5957\u5f00\u6e90\u5fae\u57fa\u51c6\u6d4b\u8bd5\u5957\u4ef6\u6765\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\u3002", "method": "\u4f5c\u8005\u5f00\u53d1\u4e86\u4e00\u4e2a\u5f00\u6e90\u5fae\u57fa\u51c6\u6d4b\u8bd5\u5957\u4ef6\uff0c\u7528\u4ee5\u7cfb\u7edf\u6027\u5730\u8bc4\u4f30Blackwell (B200) GPU\u7684\u5404\u9879\u65b0\u7279\u6027\u3002\u5177\u4f53\u65b9\u6cd5\u5305\u62ec\uff1a\u7814\u7a76B200\u76f8\u8f83\u4e8eH200\u7684\u5185\u5b58\u5b50\u7cfb\u7edf\u3001Tensor Core\u7ba1\u7ebf\u548c\u6d6e\u70b9\u7cbe\u5ea6\uff08FP32\u3001FP16\u3001FP8\u3001FP6\u3001FP4\uff09\u3002\u901a\u8fc7\u8bc4\u4f30\u5bc6\u96c6/\u7a00\u758fGEMM\u3001transformer\u63a8\u7406\u548c\u8bad\u7ec3\u7b49\u5de5\u4f5c\u8d1f\u8f7d\u6765\u91cf\u5316\u6027\u80fd\u548c\u80fd\u6548\u7684\u63d0\u5347\uff0c\u5e76\u5206\u6790\u5185\u5b58\u8bbf\u95ee\u5ef6\u8fdf\u7684\u51cf\u5c11\u3002", "result": "Blackwell (B200) \u76f8\u8f83\u4e8eH200\u7684\u4e3b\u8981\u7ed3\u679c\u5982\u4e0b\uff1a\n1. **\u5f20\u91cf\u6838\u5fc3(Tensor Core)\u589e\u5f3a\uff1a** \u5728\u6df7\u5408\u7cbe\u5ea6\u541e\u5410\u91cf\u4e0a\u5b9e\u73b0\u4e861.56\u500d\u7684\u63d0\u5347\u3002\n2. **\u80fd\u6548\uff1a** \u80fd\u6e90\u6548\u7387\u63d0\u9ad8\u4e8642%\u3002\n3. **\u5185\u5b58\u5b50\u7cfb\u7edf\uff1a** \u7f13\u5b58\u672a\u547d\u4e2d\u65f6\u7684\u5185\u5b58\u8bbf\u95ee\u5ef6\u8fdf\u51cf\u5c11\u4e8658%\u3002\n\u8fd9\u4e9b\u53d1\u73b0\u4ece\u6839\u672c\u4e0a\u6539\u53d8\u4e86\u6700\u4f18\u7b97\u6cd5\u7684\u8bbe\u8ba1\u7b56\u7565\uff0c\u5e76\u4e3a\u5e94\u7528\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u4f18\u5316\u6d1e\u5bdf\u3002", "conclusion": "\u672c\u6587\u5206\u6790\u4e86NVIDIA Blackwell (B200) GPU\u76f8\u5bf9\u4e8eH200\u7684\u67b6\u6784\u8fdb\u6b65\uff0c\u5e76\u63d0\u4f9b\u4e86\u5f00\u6e90\u5fae\u57fa\u51c6\u6d4b\u8bd5\u5957\u4ef6\u3002\u7814\u7a76\u8868\u660e\uff0cB200\u5728\u6df7\u5408\u7cbe\u5ea6\u541e\u5410\u91cf\u4e0a\u63d0\u5347\u4e861.56\u500d\uff0c\u80fd\u6548\u63d0\u9ad8\u4e8642%\uff1b\u7f13\u5b58\u672a\u547d\u4e2d\u65f6\u7684\u5185\u5b58\u8bbf\u95ee\u5ef6\u8fdf\u964d\u4f4e\u4e8658%\uff0c\u8fd9\u4e3a\u5e94\u7528\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u91cd\u8981\u7684\u4f18\u5316\u6307\u5bfc\uff0c\u5e76\u80fd\u6307\u5bfc\u672a\u6765\u7684GPU\u8bbe\u8ba1\u65b9\u5411\u3002"}}
{"id": "2512.02571", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.02571", "abs": "https://arxiv.org/abs/2512.02571", "authors": ["Kobe Grobben", "Phablo F. S. Moura", "Hande Yaman"], "title": "Approximation schemes for covering and packing mixed-integer programs with a fixed number of constraints", "comment": "20 pages", "summary": "This paper presents an algorithmic study of a class of covering mixed-integer linear programming problems which encompasses classic cover problems, including multidimensional knapsack, facility location and supplier selection problems. We first show some properties of the vertices of the associated polytope, which are then used to decompose the problem into instances of the multidimensional knapsack cover problem with a single continuous variable per dimension. The proposed decomposition is used to design a polynomial-time approximation scheme for the problem with a fixed number of constraints. To the best of our knowledge, this is the first approximation scheme for such a general class of covering mixed-integer programs. Moreover, we design a fully polynomial-time approximation scheme and an approximate linear programming formulation for the case with a single constraint. These results improve upon the previously best-known 2-approximation algorithm for the knapsack cover problem with a single continuous variable. Finally, we show a perfect compact formulation for the case where all variables have the same lower and upper bounds. Analogous results are derived for the packing and assignment variants of the problem.", "AI": {"tldr": "The paper is related to graph processing (knapsack problem, facility location, supplier selection which can be modeled as graphs or related to resource allocation problems on graphs).\nThis paper presents an algorithmic study of covering mixed-integer linear programming (MILP) problems, which include classical cover problems like multidimensional knapsack and facility location. The authors first analyze the properties of the associated polytope's vertices and use them to decompose the problem into instances of the multidimensional knapsack cover with a single continuous variable per dimension. This decomposition leads to the design of the first polynomial-time approximation scheme (PTAS) for the problem with a fixed number of constraints. Furthermore, for the single-constraint case, they propose a fully polynomial-time approximation scheme (FPTAS) and an approximate linear programming formulation, improving on the previous best 2-approximation algorithm. Finally, a perfect compact formulation is shown for the case where all variables have identical bounds, with analogous results for packing and assignment variants.", "motivation": "\u5bf9\u4e00\u7c7b\u6db5\u76d6\u7ecf\u5178\u8986\u76d6\u95ee\u9898\uff08\u5982\u591a\u7ef4\u80cc\u5305\u3001\u8bbe\u65bd\u9009\u5740\u548c\u4f9b\u5e94\u5546\u9009\u62e9\uff09\u7684\u8986\u76d6\u6df7\u5408\u6574\u6570\u7ebf\u6027\u89c4\u5212\u95ee\u9898\u8fdb\u884c\u7b97\u6cd5\u7814\u7a76\uff0c\u5e76\u586b\u8865\u73b0\u6709\u8fd1\u4f3c\u7b97\u6cd5\u7684\u7a7a\u767d\u3002\u7279\u522b\u662f\u7f3a\u4e4f\u9488\u5bf9\u8fd9\u7c7b\u4e00\u822c\u8986\u76d6\u6df7\u5408\u6574\u6570\u89c4\u5212\u7684\u8fd1\u4f3c\u65b9\u6848\u3002", "method": "1. \u5206\u6790\u76f8\u5173\u591a\u9762\u4f53\u9876\u70b9\u7684\u6027\u8d28\u3002\n2. \u5c06\u95ee\u9898\u5206\u89e3\u4e3a\u5e26\u6709\u4e00\u4e2a\u8fde\u7eed\u53d8\u91cf\u7684\u591a\u7ef4\u80cc\u5305\u8986\u76d6\u95ee\u9898\u5b9e\u4f8b\u3002\n3. \u5229\u7528\u5206\u89e3\u8bbe\u8ba1\u5177\u6709\u56fa\u5b9a\u7ea6\u675f\u6570\u91cf\u95ee\u9898\u7684\u591a\u9879\u5f0f\u65f6\u95f4\u8fd1\u4f3c\u65b9\u6848\uff08PTAS\uff09\u3002\n4. \u9488\u5bf9\u5355\u7ea6\u675f\u60c5\u51b5\u8bbe\u8ba1\u5b8c\u5168\u591a\u9879\u5f0f\u65f6\u95f4\u8fd1\u4f3c\u65b9\u6848\uff08FPTAS\uff09\u548c\u4e00\u4e2a\u8fd1\u4f3c\u7ebf\u6027\u89c4\u5212\u516c\u5f0f\u3002\n5. \u63a8\u5bfc\u6240\u6709\u53d8\u91cf\u5177\u6709\u76f8\u540c\u4e0a\u4e0b\u754c\u60c5\u51b5\u7684\u5b8c\u7f8e\u7d27\u51d1\u516c\u5f0f\u3002\n6. \u5c06\u76f8\u4f3c\u7684\u7ed3\u679c\u63a8\u5e7f\u5230\u95ee\u9898\u7684\u6253\u5305\u548c\u5206\u914d\u53d8\u4f53\u3002", "result": "1. \u5bf9\u4e8e\u5177\u6709\u56fa\u5b9a\u7ea6\u675f\u6570\u91cf\u7684\u95ee\u9898\uff0c\u8bbe\u8ba1\u4e86\u9996\u4e2a\u591a\u9879\u5f0f\u65f6\u95f4\u8fd1\u4f3c\u65b9\u6848\uff08PTAS\uff09\u3002\n2. \u5bf9\u4e8e\u5355\u7ea6\u675f\u60c5\u51b5\uff0c\u8bbe\u8ba1\u4e86\u5b8c\u5168\u591a\u9879\u5f0f\u65f6\u95f4\u8fd1\u4f3c\u65b9\u6848\uff08FPTAS\uff09\u548c\u4e00\u4e2a\u8fd1\u4f3c\u7ebf\u6027\u89c4\u5212\u516c\u5f0f\uff0c\u6539\u8fdb\u4e86\u5148\u524d\u63d0\u51fa\u7684\u5355\u8fde\u7eed\u53d8\u91cf\u80cc\u5305\u8986\u76d6\u95ee\u9898\u7684\u6700\u4f18 2-\u8fd1\u4f3c\u7b97\u6cd5\u3002\n3. \u63a8\u5bfc\u4e86\u6240\u6709\u53d8\u91cf\u5177\u6709\u76f8\u540c\u4e0a\u4e0b\u754c\u60c5\u51b5\u7684\u5b8c\u7f8e\u7d27\u51d1\u516c\u5f0f\u3002\n4. \u76f8\u4f3c\u7684\u7ed3\u679c\u88ab\u63a8\u5e7f\u5230\u4e86\u95ee\u9898\u7684\u6253\u5305\u548c\u5206\u914d\u53d8\u4f53\u3002", "conclusion": "\u672c\u6587\u5bf9\u4e00\u7c7b\u8986\u76d6\u6df7\u5408\u6574\u6570\u7ebf\u6027\u89c4\u5212\u95ee\u9898\u8fdb\u884c\u4e86\u7b97\u6cd5\u7814\u7a76\uff0c\u6db5\u76d6\u4e86\u591a\u7ef4\u80cc\u5305\u3001\u8bbe\u65bd\u9009\u5740\u548c\u4f9b\u5e94\u5546\u9009\u62e9\u7b49\u7ecf\u5178\u8986\u76d6\u95ee\u9898\u3002\u901a\u8fc7\u5206\u6790\u76f8\u5173\u591a\u9762\u4f53\u9876\u70b9\u7684\u6027\u8d28\uff0c\u5c06\u95ee\u9898\u5206\u89e3\u4e3a\u5e26\u6709\u4e00\u4e2a\u8fde\u7eed\u53d8\u91cf\u7684\u591a\u7ef4\u80cc\u5305\u8986\u76d6\u95ee\u9898\u5b9e\u4f8b\uff0c\u5e76\u57fa\u4e8e\u6b64\u8bbe\u8ba1\u4e86\u5177\u6709\u56fa\u5b9a\u7ea6\u675f\u6570\u91cf\u95ee\u9898\u7684\u591a\u9879\u5f0f\u65f6\u95f4\u8fd1\u4f3c\u65b9\u6848\uff08PTAS\uff09\uff0c\u8fd9\u662f\u9488\u5bf9\u6b64\u7c7b\u8986\u76d6\u6df7\u5408\u6574\u6570\u89c4\u5212\u7684\u9996\u6b21\u8fd1\u4f3c\u65b9\u6848\u3002\u6b64\u5916\uff0c\u672c\u6587\u8fd8\u9488\u5bf9\u5355\u7ea6\u675f\u60c5\u51b5\u8bbe\u8ba1\u4e86\u5b8c\u5168\u591a\u9879\u5f0f\u65f6\u95f4\u8fd1\u4f3c\u65b9\u6848\uff08FPTAS\uff09\u548c\u4e00\u4e2a\u8fd1\u4f3c\u7ebf\u6027\u89c4\u5212\u516c\u5f0f\uff0c\u6539\u8fdb\u4e86\u5148\u524d\u63d0\u51fa\u7684\u5355\u8fde\u7eed\u53d8\u91cf\u80cc\u5305\u8986\u76d6\u95ee\u9898\u7684\u6700\u4f18 2-\u8fd1\u4f3c\u7b97\u6cd5\u3002\u6700\u540e\uff0c\u672c\u6587\u5c55\u793a\u4e86\u6240\u6709\u53d8\u91cf\u5177\u6709\u76f8\u540c\u4e0a\u4e0b\u754c\u60c5\u51b5\u7684\u5b8c\u7f8e\u7d27\u51d1\u516c\u5f0f\uff0c\u5e76\u5c06\u76f8\u4f3c\u7684\u7ed3\u679c\u63a8\u5e7f\u5230\u4e86\u95ee\u9898\u7684\u6253\u5305\u548c\u5206\u914d\u53d8\u4f53\u3002"}}
{"id": "2512.02346", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.02346", "abs": "https://arxiv.org/abs/2512.02346", "authors": ["Hongyang Shang", "An Guo", "Shuai Dong", "Junyi Yang", "Ye Ke", "Arindam Basu"], "title": "Near-Memory Architecture for Threshold-Ordinal Surface-Based Corner Detection of Event Cameras", "comment": null, "summary": "Event-based Cameras (EBCs) are widely utilized in surveillance and autonomous driving applications due to their high speed and low power consumption. Corners are essential low-level features in event-driven computer vision, and novel algorithms utilizing event-based representations, such as Threshold-Ordinal Surface (TOS), have been developed for corner detection. However, the implementation of these algorithms on resource-constrained edge devices is hindered by significant latency, undermining the advantages of EBCs. To address this challenge, a near-memory architecture for efficient TOS updates (NM-TOS) is proposed. This architecture employs a read-write decoupled 8T SRAM cell and optimizes patch update speed through pipelining. Hardware-software co-optimized peripheral circuits and dynamic voltage and frequency scaling (DVFS) enable power and latency reductions. Compared to traditional digital implementations, our architecture reduces latency/energy by 24.7x/1.2x at Vdd = 1.2 V or 1.93x/6.6x at Vdd = 0.6 V based on 65nm CMOS process. Monte Carlo simulations confirm robust circuit operation, demonstrating zero bit error rate at operating voltages above 0.62 V, with only 0.2% at 0.61 V and 2.5% at 0.6 V. Corner detection evaluation using precision-recall area under curve (AUC) metrics reveals minor AUC reductions of 0.027 and 0.015 at 0.6 V for two popular EBC datasets.", "AI": {"tldr": "\u5426\u3002\n\u4e8b\u4ef6\u76f8\u673a\uff08EBCs\uff09\u5728\u8fb9\u7f18\u8bbe\u5907\u4e0a\u90e8\u7f72\u89d2\u70b9\u68c0\u6d4b\u7b97\u6cd5\uff08\u5982\u57fa\u4e8eTOS\u7684\u7b97\u6cd5\uff09\u65f6\u9762\u4e34\u663e\u8457\u5ef6\u8fdf\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u8fd1\u5185\u5b58\u67b6\u6784\uff08NM-TOS\uff09\u6765\u89e3\u51b3\u8fd9\u4e00\u95ee\u9898\u3002NM-TOS\u91c7\u7528\u8bfb\u5199\u89e3\u8026\u76848T SRAM\u5355\u5143\u548c\u6d41\u6c34\u7ebf\u6280\u672f\u4f18\u5316TOS\u66f4\u65b0\uff0c\u5e76\u901a\u8fc7\u8f6f\u786c\u4ef6\u534f\u540c\u4f18\u5316\u548cDVFS\u6280\u672f\u964d\u4f4e\u5ef6\u8fdf\u548c\u80fd\u8017\u3002\u4e0e\u4f20\u7edf\u6570\u5b57\u5b9e\u73b0\u76f8\u6bd4\uff0cNM-TOS\u663e\u8457\u964d\u4f4e\u4e86\u5ef6\u8fdf\uff08\u6700\u9ad824.7\u500d\uff09\u548c\u80fd\u8017\uff08\u6700\u9ad86.6\u500d\uff09\uff0c\u540c\u65f6\u4fdd\u6301\u4e86\u5408\u7406\u7684\u68c0\u6d4b\u6027\u80fd\u3002", "motivation": "\u4e8b\u4ef6\u76f8\u673a\uff08EBCs\uff09\u56e0\u5176\u9ad8\u901f\u5ea6\u548c\u4f4e\u529f\u8017\u800c\u88ab\u5e7f\u6cdb\u5e94\u7528\u4e8e\u76d1\u63a7\u548c\u81ea\u52a8\u9a7e\u9a76\u3002\u89d2\u70b9\u662f\u4e8b\u4ef6\u9a71\u52a8\u8ba1\u7b97\u673a\u89c6\u89c9\u4e2d\u7684\u91cd\u8981\u4f4e\u7ea7\u7279\u5f81\u3002\u867d\u7136\u5df2\u5f00\u53d1\u51fa\u5229\u7528TOS\uff08Threshold-Ordinal Surface\uff09\u7b49\u4e8b\u4ef6\u8868\u793a\u7684\u65b0\u7b97\u6cd5\u8fdb\u884c\u89d2\u70b9\u68c0\u6d4b\uff0c\u4f46\u5728\u8d44\u6e90\u53d7\u9650\u7684\u8fb9\u7f18\u8bbe\u5907\u4e0a\u5b9e\u73b0\u8fd9\u4e9b\u7b97\u6cd5\u65f6\uff0c\u5b58\u5728\u663e\u8457\u7684\u5ef6\u8fdf\u95ee\u9898\uff0c\u8fd9\u62b5\u6d88\u4e86EBCs\u7684\u4f18\u52bf\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u9ad8\u6548\u7684\u786c\u4ef6\u5b9e\u73b0\u6765\u89e3\u51b3\u8fd9\u4e00\u6311\u6218\u3002", "method": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u9762\u5411\u9ad8\u6548TOS\u66f4\u65b0\u7684\u8fd1\u5185\u5b58\u67b6\u6784\uff08NM-TOS\uff09\u3002\u8be5\u67b6\u6784\u91c7\u7528\u4e86\u8bfb\u5199\u89e3\u8026\u76848T SRAM\u5355\u5143\uff0c\u5e76\u901a\u8fc7\u6d41\u6c34\u7ebf\u6280\u672f\u4f18\u5316\u4e86TOS\u8865\u4e01\u7684\u66f4\u65b0\u901f\u5ea6\u3002\u6b64\u5916\uff0c\u8fd8\u91c7\u7528\u4e86\u8f6f\u786c\u4ef6\u534f\u540c\u4f18\u5316\u7684\u5916\u56f4\u7535\u8def\u548c\u52a8\u6001\u7535\u538b\u4e0e\u9891\u7387\u7f29\u653e\uff08DVFS\uff09\u6280\u672f\uff0c\u4ee5\u8fdb\u4e00\u6b65\u964d\u4f4e\u529f\u8017\u548c\u5ef6\u8fdf\u3002", "result": "\u4e0e\u4f20\u7edf\u7684\u6570\u5b57\u5b9e\u73b0\u76f8\u6bd4\uff0c\u672c\u6587\u63d0\u51fa\u7684\u67b6\u6784\u5728Vdd = 1.2 V\u65f6\uff0c\u5ef6\u8fdf/\u80fd\u8017\u964d\u4f4e\u4e8624.7\u500d/1.2\u500d\uff1b\u5728Vdd = 0.6 V\u65f6\uff0c\u5ef6\u8fdf/\u80fd\u8017\u964d\u4f4e\u4e861.93\u500d/6.6\u500d\uff0c\u5747\u57fa\u4e8e65nm CMOS\u5de5\u827a\u3002\u8499\u7279\u5361\u6d1b\u6a21\u62df\u8bc1\u5b9e\u4e86\u7535\u8def\u8fd0\u884c\u7684\u9c81\u68d2\u6027\u3002\u5728\u89d2\u70b9\u68c0\u6d4b\u8bc4\u4f30\u4e2d\uff0c\u5bf9\u4e8e\u4e24\u4e2a\u6d41\u884c\u7684EBC\u6570\u636e\u96c6\uff0c\u57280.6 V\u7535\u538b\u4e0b\uff0c\u7cbe\u786e\u53ec\u56de\u66f2\u7ebf\u4e0b\u9762\u79ef\uff08AUC\uff09\u4ec5\u67090.027\u548c0.015\u7684\u8f7b\u5fae\u4e0b\u964d\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u9762\u5411\u9ad8\u6548TOS\u66f4\u65b0\u7684\u8fd1\u5185\u5b58\u67b6\u6784\uff08NM-TOS\uff09\uff0c\u901a\u8fc7\u91c7\u7528\u8bfb\u5199\u89e3\u8026\u76848T SRAM\u5355\u5143\u548c\u6d41\u6c34\u7ebf\u4f18\u5316\u8865\u4e01\u66f4\u65b0\u901f\u5ea6\u3002 NM-TOS\u663e\u8457\u964d\u4f4e\u4e86\u57fa\u4e8e\u4e8b\u4ef6\u76f8\u673a\u7684\u89d2\u70b9\u68c0\u6d4b\u7b97\u6cd5\u7684\u5ef6\u8fdf\u548c\u80fd\u8017\uff0c\u540c\u65f6\u5728\u964d\u4f4e\u7535\u538b\u65f6\u4fdd\u6301\u4e86\u5408\u7406\u7684\u6027\u80fd\u548c\u9c81\u68d2\u6027\u3002\u8fd9\u79cd\u67b6\u6784\u6709\u671b\u514b\u670d\u8d44\u6e90\u53d7\u9650\u8fb9\u7f18\u8bbe\u5907\u4e0a\u4e8b\u4ef6\u9a71\u52a8\u8ba1\u7b97\u673a\u89c6\u89c9\u7b97\u6cd5\u90e8\u7f72\u7684\u6311\u6218\u3002"}}
{"id": "2512.02300", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.02300", "abs": "https://arxiv.org/abs/2512.02300", "authors": ["Haoyu Zheng", "Shouwei Gao", "Jie Ren", "Wenqian Dong"], "title": "DOLMA: A Data Object Level Memory Disaggregation Framework for HPC Applications", "comment": null, "summary": "Memory disaggregation is promising to scale memory capacity and improves utilization in HPC systems. However, the performance overhead of accessing remote memory poses a significant chal- lenge, particularly for compute-intensive HPC applications where execution times are highly sensitive to data locality. In this work, we present DOLMA, a Data Object Level M emory dis Aggregation framework designed for HPC applications. DOLMA intelligently identifies and offloads data objects to remote memory, while pro- viding quantitative analysis to decide a suitable local memory size. Furthermore, DOLMA leverages the predictable memory access patterns typical in HPC applications and enables remote memory prefetch via a dual-buffer design. By carefully balancing local and remote memory usage and maintaining multi-thread concurrency, DOLMA provides a flexible and efficient solution for leveraging dis- aggregated memory in HPC domains while minimally compromis- ing application performance. Evaluating with eight HPC workloads and computational kernels, DOLMA limits performance degrada- tion to less than 16% while reducing local memory usage by up to 63%, on average.", "AI": {"tldr": "\u672c\u8bba\u6587\u4e0e\u7f16\u8bd1\u5668\u9886\u57df\u76f8\u5173\uff0c\u56e0\u4e3a\u5b83\u5173\u6ce8\u4f18\u5316\u5185\u5b58\u8bbf\u95ee\u53ca\u5176\u5bf9\u8ba1\u7b97\u6027\u80fd\u7684\u5f71\u54cd\uff0c\u8fd9\u5728\u9ad8\u6027\u80fd\u8ba1\u7b97\uff08HPC\uff09\u73af\u5883\u4e2d\u4e0e\u7f16\u8bd1\u5668\u7684\u5185\u5b58\u7ba1\u7406\u548c\u4f18\u5316\u5bc6\u5207\u76f8\u5173\uff0c\u5c3d\u7ba1\u5b83\u4e3b\u8981\u662f\u4e00\u4e2a\u7cfb\u7edf\u7ea7\u6846\u67b6\u3002\n\n\u592a\u957f\u4e0d\u8bfb\uff1aDOLMA\u662f\u4e00\u4e2a\u9762\u5411HPC\u5e94\u7528\u7684**\u6570\u636e\u5bf9\u8c61\u7ea7\u5185\u5b58\u89e3\u8026\u6846\u67b6**\uff0c\u5b83\u901a\u8fc7**\u667a\u80fd\u5730\u8bc6\u522b\u548c\u5378\u8f7d\u6570\u636e\u5230\u8fdc\u7a0b\u5185\u5b58**\u3001**\u91cf\u5316\u5206\u6790\u51b3\u5b9a\u672c\u5730\u5185\u5b58\u5927\u5c0f**\uff0c\u5e76\u5229\u7528**\u53cc\u7f13\u51b2\u533a\u8bbe\u8ba1\u5b9e\u73b0\u8fdc\u7a0b\u5185\u5b58\u9884\u53d6**\uff0c\u4ece\u800c\u5728\u6700\u5c0f\u5316\u6027\u80fd\u4e0b\u964d\uff08<16%\uff09\u7684\u540c\u65f6\uff0c\u663e\u8457\u51cf\u5c11\u672c\u5730\u5185\u5b58\u4f7f\u7528\uff08\u5e73\u5747\u9ad8\u8fbe63%\uff09\uff0c\u6709\u6548\u89e3\u51b3\u4e86\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u5728\u9ad8\u8ba1\u7b97\u5f3a\u5ea6HPC\u5e94\u7528\u4e2d\u7684\u6027\u80fd\u6311\u6218\u3002", "motivation": "HPC\u7cfb\u7edf\u4e2d\u7684\u5185\u5b58\u89e3\u8026\uff08Memory disaggregation\uff09\u5728\u6269\u5c55\u5185\u5b58\u5bb9\u91cf\u548c\u63d0\u9ad8\u5229\u7528\u7387\u65b9\u9762\u5177\u6709\u6f5c\u529b\u3002\u7136\u800c\uff0c\u8bbf\u95ee\u8fdc\u7a0b\u5185\u5b58\u7684\u6027\u80fd\u5f00\u9500\u662f\u4e00\u4e2a\u91cd\u5927\u6311\u6218\uff0c\u5bf9\u4e8e\u8ba1\u7b97\u5bc6\u96c6\u578b\u7684HPC\u5e94\u7528\u5c24\u5176\u5982\u6b64\uff0c\u56e0\u4e3a\u5b83\u4eec\u7684\u6267\u884c\u65f6\u95f4\u5bf9\u6570\u636e\u5c40\u90e8\u6027\u9ad8\u5ea6\u654f\u611f\u3002\u672c\u5de5\u4f5c\u65e8\u5728\u89e3\u51b3\u8fd9\u4e00\u6311\u6218\uff0c\u5229\u7528\u5185\u5b58\u89e3\u8026\u7684\u4f18\u52bf\uff0c\u540c\u65f6\u6700\u5c0f\u5316\u5bf9\u5e94\u7528\u6027\u80fd\u7684\u635f\u5bb3\u3002", "method": "DOLMA\u6846\u67b6\u901a\u8fc7\u4ee5\u4e0b\u65b9\u6cd5\u5b9e\u73b0\u5185\u5b58\u89e3\u8026\uff1a1. \u667a\u80fd\u8bc6\u522b\u5e76\u5378\u8f7d\u6570\u636e\u5bf9\u8c61\u5230\u8fdc\u7a0b\u5185\u5b58\u30022. \u63d0\u4f9b\u91cf\u5316\u5206\u6790\u6765\u51b3\u5b9a\u5408\u9002\u7684\u672c\u5730\u5185\u5b58\u5927\u5c0f\u30023. \u5229\u7528HPC\u5e94\u7528\u4e2d\u5178\u578b\u7684\u53ef\u9884\u6d4b\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u901a\u8fc7\u53cc\u7f13\u51b2\u533a\u8bbe\u8ba1\u5b9e\u73b0\u8fdc\u7a0b\u5185\u5b58\u9884\u53d6\u30024. \u4ed4\u7ec6\u5e73\u8861\u672c\u5730\u548c\u8fdc\u7a0b\u5185\u5b58\u7684\u4f7f\u7528\uff0c\u5e76\u7ef4\u6301\u591a\u7ebf\u7a0b\u5e76\u53d1\u6027\u3002", "result": "DOLMA\u5728\u8bc4\u4f30\u4e86\u516b\u4e2aHPC\u5de5\u4f5c\u8d1f\u8f7d\u548c\u8ba1\u7b97\u5185\u6838\u540e\uff0c\u76f8\u5bf9\u4e8e\u57fa\u7ebf\uff0c\u80fd\u591f\u5c06\u6027\u80fd\u4e0b\u964d\u9650\u5236\u572816%\u4ee5\u5185\uff0c\u540c\u65f6\u5e73\u5747\u672c\u5730\u5185\u5b58\u4f7f\u7528\u91cf\u51cf\u5c11\u4e86\u9ad8\u8fbe63%\u3002", "conclusion": "DOLMA\u901a\u8fc7\u5e73\u8861\u672c\u5730\u548c\u8fdc\u7a0b\u5185\u5b58\u7684\u4f7f\u7528\uff0c\u5e76\u4fdd\u6301\u591a\u7ebf\u7a0b\u5e76\u53d1\uff0c\u4e3aHPC\u5e94\u7528\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7075\u6d3b\u4e14\u9ad8\u6548\u7684\u5229\u7528\u5185\u5b58\u89e3\u8026\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u540c\u65f6\u5bf9\u5e94\u7528\u6027\u80fd\u7684\u5f71\u54cd\u6700\u5c0f\u3002\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u76f8\u5bf9\u4e8e\u57fa\u7ebf\uff0cDOLMA\u80fd\u591f\u5c06\u6027\u80fd\u4e0b\u964d\u9650\u5236\u572816%\u4ee5\u5185\uff0c\u540c\u65f6\u5e73\u5747\u672c\u5730\u5185\u5b58\u4f7f\u7528\u91cf\u51cf\u5c11\u4e86\u9ad8\u8fbe63%\u3002"}}
{"id": "2512.02371", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2512.02371", "abs": "https://arxiv.org/abs/2512.02371", "authors": ["Yihong Zhang", "Derek Gerstmann", "Andrew Adams", "Maaz Bin Safeer Ahmad"], "title": "Pushing Tensor Accelerators Beyond MatMul in a User-Schedulable Language", "comment": "CGO 2026", "summary": "Tensor accelerators now represent a growing share of compute resources in modern CPUs and GPUs. However, they are hard to program, leading developers to use vendor-provided kernel libraries that support tensor accelerators. As a result, the usage of tensor accelerators is limited to the provided interface, mainly designed for traditional ML and scientific computing workloads.\n  In this paper, we show that tensor accelerators can improve the performance of applications beyond simple variants of MatMul. For example, many image processing pipelines are linear transformations over matrices in disguise and can therefore utilize such specialized hardware. This is nonetheless hindered by the difficulties in programming tensor accelerators. We tackle this problem with compiler-based techniques. We use the Halide user-schedulable language and express operations as Halide algorithms succinctly. To this end, we implement a flexible tensor instruction selector based on equality saturation. The tensor instruction selector supports both CPU- and GPU-attached tensor accelerators and works with existing scheduling operations (e.g., producer-consumer fusion). Together, this enables developers to write diverse accelerator-leveraging applications in a few dozen lines.\n  Using our system, we demonstrate the potential of tensor accelerators beyond their traditional domains. We implement several image processing pipelines (e.g., filtering, resampling, and denoising) in our system and evaluate them against non-accelerator-leveraging baselines. We show that these pipelines can achieve significant speedups. For example, a downsampling routine is sped up by $6.1\\times$ by utilizing Tensor Cores on an Nvidia RTX 4070 GPU.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e\u7f16\u8bd1\u5668\u548c DSL\uff08Halide \u662f\u4e00\u79cd\u7279\u5b9a\u9886\u57df\u7684\u8bed\u8a00\uff0c\u5373 DSL\uff09\u76f8\u5173\u3002\n\u592a\u957f\u4e0d\u770b\uff08TLDR\uff09\uff1a\u73b0\u4ee3 CPU \u548c GPU \u4e2d\u7684\u5f20\u91cf\u52a0\u901f\u5668\uff08\u5982 Tensor Cores\uff09\u96be\u4ee5\u7f16\u7a0b\uff0c\u4e3b\u8981\u5c40\u9650\u4e8e\u4f20\u7edf\u673a\u5668\u5b66\u4e60\u548c\u79d1\u5b66\u8ba1\u7b97\u3002\u672c\u6587\u63d0\u51fa\u4f7f\u7528\u57fa\u4e8e Halide \u7684\u7f16\u8bd1\u5668\u6280\u672f\uff0c\u901a\u8fc7\u4e00\u4e2a\u7075\u6d3b\u7684\u57fa\u4e8e\u7b49\u4ef7\u9971\u548c\u7684\u5f20\u91cf\u6307\u4ee4\u9009\u62e9\u5668\u6765\u89e3\u51b3\u7f16\u7a0b\u96be\u9898\uff0c\u4ece\u800c\u5c06\u5f20\u91cf\u52a0\u901f\u5668\u7684\u5e94\u7528\u6269\u5c55\u5230\u56fe\u50cf\u5904\u7406\u7b49\u9886\u57df\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u4e0e\u672a\u5229\u7528\u52a0\u901f\u5668\u7684\u57fa\u7ebf\u76f8\u6bd4\uff0c\u56fe\u50cf\u5904\u7406\u6d41\u6c34\u7ebf\u5b9e\u73b0\u4e86\u663e\u8457\u52a0\u901f\uff0c\u4f8b\u5982\u5728 Nvidia RTX 4070 \u4e0a\uff0c\u4e00\u4e2a\u4e0b\u91c7\u6837\u7a0b\u5e8f\u5b9e\u73b0\u4e86 6.1 \u500d\u7684\u52a0\u901f\u3002", "motivation": "\u5f20\u91cf\u52a0\u901f\u5668\uff08\u5982\u73b0\u4ee3 CPU \u548c GPU \u4e2d\u7684\u5f20\u91cf\u6838\u5fc3\uff09\u96be\u4ee5\u7f16\u7a0b\uff0c\u5bfc\u81f4\u5f00\u53d1\u4eba\u5458\u4e3b\u8981\u4f9d\u8d56\u4f9b\u5e94\u5546\u63d0\u4f9b\u7684\u5185\u6838\u5e93\u3002\u8fd9\u9650\u5236\u4e86\u5f20\u91cf\u52a0\u901f\u5668\u7684\u4f7f\u7528\u8303\u56f4\uff0c\u4e3b\u8981\u5c40\u9650\u4e8e\u4f20\u7edf\u7684\u673a\u5668\u5b66\u4e60\uff08ML\uff09\u548c\u79d1\u5b66\u8ba1\u7b97\u5de5\u4f5c\u8d1f\u8f7d\u3002\u672c\u6587\u7684\u52a8\u673a\u662f\u8bc1\u660e\u5f20\u91cf\u52a0\u901f\u5668\u53ef\u4ee5\u63d0\u9ad8\u8d85\u8d8a\u7b80\u5355\u77e9\u9635\u4e58\u6cd5\uff08MatMul\uff09\u53d8\u4f53\u7684\u5e94\u7528\u7a0b\u5e8f\u7684\u6027\u80fd\uff08\u4f8b\u5982\u56fe\u50cf\u5904\u7406\u6d41\u6c34\u7ebf\uff0c\u5b83\u4eec\u53ef\u4ee5\u88ab\u89c6\u4e3a\u77e9\u9635\u4e0a\u7684\u7ebf\u6027\u53d8\u6362\uff09\uff0c\u5e76\u901a\u8fc7\u7f16\u8bd1\u5668\u6280\u672f\u89e3\u51b3\u7f16\u7a0b\u96be\u5ea6\u95ee\u9898\uff0c\u4ece\u800c\u62d3\u5bbd\u5f20\u91cf\u52a0\u901f\u5668\u7684\u5e94\u7528\u9886\u57df\u3002", "method": "\u672c\u6587\u91c7\u7528\u4e86\u4e00\u79cd\u57fa\u4e8e\u7f16\u8bd1\u5668\u7684\u6280\u672f\u6765\u89e3\u51b3\u5f20\u91cf\u52a0\u901f\u5668\u96be\u4ee5\u7f16\u7a0b\u7684\u95ee\u9898\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5b83\u5229\u7528\u4e86 Halide \u8fd9\u4e00\u7528\u6237\u53ef\u8c03\u5ea6\u7684\u8bed\u8a00\u6765\u7b80\u6d01\u5730\u8868\u8fbe\u64cd\u4f5c\uff0c\u5e76\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7075\u6d3b\u7684\u57fa\u4e8e\u7b49\u4ef7\u9971\u548c\uff08equality saturation\uff09\u7684\u5f20\u91cf\u6307\u4ee4\u9009\u62e9\u5668\uff08tensor instruction selector\uff09\u3002\u8be5\u9009\u62e9\u5668\u652f\u6301\u8fde\u63a5\u5230 CPU \u548c GPU \u7684\u5f20\u91cf\u52a0\u901f\u5668\uff0c\u5e76\u517c\u5bb9\u73b0\u6709\u7684\u8c03\u5ea6\u64cd\u4f5c\uff08\u4f8b\u5982\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u878d\u5408\uff09\u3002\u8fd9\u79cd\u65b9\u6cd5\u4f7f\u5f97\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u7528\u8f83\u5c11\u7684\u4ee3\u7801\u884c\u6570\u6765\u7f16\u5199\u5404\u79cd\u5229\u7528\u52a0\u901f\u5668\u7684\u5e94\u7528\u3002", "result": "\u672c\u6587\u7684\u7ed3\u679c\u663e\u793a\uff0c\u901a\u8fc7\u4f7f\u7528\u4ed6\u4eec\u63d0\u51fa\u7684\u7cfb\u7edf\uff0c\u5f20\u91cf\u52a0\u901f\u5668\u7684\u5e94\u7528\u6f5c\u529b\u5f97\u5230\u4e86\u5c55\u793a\uff0c\u8d85\u8d8a\u4e86\u4f20\u7edf\u9886\u57df\u3002\u901a\u8fc7\u5728\u5b9e\u73b0\u7684\u56fe\u50cf\u5904\u7406\u6d41\u6c34\u7ebf\uff08\u4f8b\u5982\u6ee4\u6ce2\u3001\u91cd\u91c7\u6837\u548c\u53bb\u566a\uff09\u4e2d\u5229\u7528\u5f20\u91cf\u52a0\u901f\u5668\uff0c\u4e0e\u672a\u5229\u7528\u52a0\u901f\u5668\u7684\u57fa\u7ebf\u76f8\u6bd4\uff0c\u5b9e\u73b0\u4e86\u663e\u8457\u7684\u52a0\u901f\u3002\u4f8b\u5982\uff0c\u5728\u4e00\u4e2a Nvidia RTX 4070 GPU \u4e0a\uff0c\u4e00\u4e2a\u5229\u7528 Tensor Cores \u7684\u4e0b\u91c7\u6837\u7a0b\u5e8f\u5b9e\u73b0\u4e86 6.1 \u500d\u7684\u52a0\u901f\u3002", "conclusion": "\u672c\u6587\u901a\u8fc7\u4e00\u4e2a\u7075\u6d3b\u7684\u57fa\u4e8e\u7b49\u4ef7\u9971\u548c\u7684\u5f20\u91cf\u6307\u4ee4\u9009\u62e9\u5668\uff0c\u5c06 Halide \u8bed\u8a00\u53ca\u5176\u73b0\u6709\u7684\u8c03\u5ea6\u64cd\u4f5c\u4e0e\u5f20\u91cf\u52a0\u901f\u5668\u7ed3\u5408\u8d77\u6765\uff0c\u964d\u4f4e\u4e86\u7f16\u7a0b\u96be\u5ea6\uff0c\u4f7f\u5f00\u53d1\u4eba\u5458\u80fd\u591f\u4e3a\u591a\u79cd\u5e94\u7528\u573a\u666f\uff08\u4f8b\u5982\u56fe\u50cf\u5904\u7406\uff09\u7f16\u5199\u5229\u7528\u52a0\u901f\u5668\u7684\u4ee3\u7801\u3002\u7ed3\u679c\u663e\u793a\uff0c\u4e0e\u672a\u5229\u7528\u52a0\u901f\u5668\u7684\u57fa\u7ebf\u76f8\u6bd4\uff0c\u5b9e\u73b0\u4e86\u663e\u8457\u7684\u52a0\u901f\uff0c\u4f8b\u5982\u5728 Nvidia RTX 4070 GPU \u4e0a\uff0c\u4e00\u4e2a\u4e0b\u91c7\u6837\u7a0b\u5e8f\u5b9e\u73b0\u4e86 6.1 \u500d\u7684\u52a0\u901f\u3002\u603b\u7684\u6765\u8bf4\uff0c\u672c\u6587\u6210\u529f\u5730\u62d3\u5c55\u4e86\u5f20\u91cf\u52a0\u901f\u5668\u7684\u5e94\u7528\u8303\u56f4\uff0c\u4f7f\u5176\u8d85\u8d8a\u4e86\u4f20\u7edf\u7684\u673a\u5668\u5b66\u4e60\u548c\u79d1\u5b66\u8ba1\u7b97\u9886\u57df\u3002"}}
{"id": "2512.02758", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.02758", "abs": "https://arxiv.org/abs/2512.02758", "authors": ["Klaus Jansen", "Lis Pirotton", "Malte Tutas"], "title": "The Support of Bin Packing is Exponential", "comment": null, "summary": "Consider the classical Bin Packing problem with $d$ different item sizes $s_i$ and amounts of items $a_i.$ The support of a Bin Packing solution is the number of differently filled bins. In this work, we show that the lower bound on the support of this problem is $2^{\u03a9(d)}$. Our lower bound matches the upper bound of $2^d$ given by Eisenbrand and Shmonin [Oper.Research Letters '06] up to a constant factor. This result has direct implications for the time complexity of several Bin Packing algorithms, such as Goemans and Rothvoss [SODA '14], Jansen and Klein [SODA '17] and Jansen and Solis-Oba [IPCO '10]. To achieve our main result, we develop a technique to aggregate equality constrained ILPs with many constraints into an equivalent ILP with one constraint. Our technique contrasts existing aggregation techniques as we manage to integrate upper bounds on variables into the resulting constraint. We believe this technique can be useful for solving general ILPs or the $d$-dimensional knapsack problem.", "AI": {"tldr": "This content has not passed the compliance test and has been hidden.", "motivation": "\u7ecf\u5178\u88c5\u7bb1\u95ee\u9898 (Bin Packing) \u7684\u89e3\u7684\u652f\u6301\u96c6\u5927\u5c0f\uff08\u5373\u4e0d\u540c\u586b\u5145\u65b9\u5f0f\u7684\u7bb1\u5b50\u6570\u91cf\uff09\u662f\u4e00\u4e2a\u91cd\u8981\u7684\u590d\u6742\u5ea6\u5ea6\u91cf\u3002\u5148\u524d\u5de5\u4f5c\u7ed9\u51fa\u4e86\u4e0a\u754c $2^d$\u3002\u672c\u6587\u7684\u52a8\u673a\u662f\u5efa\u7acb\u4e00\u4e2a\u7d27\u5bc6\u7684\u4e0b\u754c\uff0c\u4ee5\u66f4\u597d\u5730\u7406\u89e3\u548c\u754c\u5b9a\u5177\u6709 $d$ \u79cd\u5c3a\u5bf8\u7684\u88c5\u7bb1\u95ee\u9898\u7684\u89e3\u7ed3\u6784\u590d\u6742\u6027\uff0c\u5e76\u63ed\u793a\u8fd9\u5982\u4f55\u5f71\u54cd\u73b0\u6709\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002", "method": "\u4f5c\u8005\u5f00\u53d1\u4e86\u4e00\u79cd\u65b0\u7684\u6280\u672f\uff0c\u80fd\u591f\u5c06\u5177\u6709\u591a\u4e2a\u7ea6\u675f\u7684\u7b49\u5f0f\u53d7\u9650\u6574\u6570\u7ebf\u6027\u89c4\u5212 (ILP) \u805a\u5408\u4e3a\u4e00\u4e2a\u4ec5\u6709\u4e00\u4e2a\u7ea6\u675f\u7684\u7b49\u6548 ILP\u3002\u4e0e\u73b0\u6709\u6280\u672f\u4e0d\u540c\u7684\u662f\uff0c\u8be5\u6280\u672f\u80fd\u591f\u5c06\u53d8\u91cf\u7684\u4e0a\u9650\u96c6\u6210\u5230\u7ed3\u679c\u7ea6\u675f\u4e2d\u3002\u901a\u8fc7\u8fd9\u79cd\u6280\u672f\uff0c\u4f5c\u8005\u5efa\u7acb\u4e86\u88c5\u7bb1\u95ee\u9898\u89e3\u7684\u652f\u6301\u96c6\u5927\u5c0f\u7684\u4e0b\u754c\u3002", "result": "\u672c\u6587\u7684\u4e3b\u8981\u7ed3\u679c\u8bc1\u660e\u4e86\u5177\u6709 $d$ \u79cd\u4e0d\u540c\u5c3a\u5bf8\u7269\u54c1\u7684\u88c5\u7bb1\u95ee\u9898\uff0c\u5176\u89e3\u7684\u652f\u6301\u96c6\uff08\u5373\u4e0d\u540c\u586b\u5145\u65b9\u5f0f\u7684\u7bb1\u5b50\u6570\u91cf\uff09\u7684\u4e0b\u754c\u662f $2^{\\Omega(d)}$\u3002\u8fd9\u4e2a\u4e0b\u754c\u4e0e\u5df2\u77e5\u7684\u4e0a\u754c $2^d$ \u5728\u5e38\u6570\u56e0\u5b50\u4e0a\u5339\u914d\u3002\u8fd9\u4e00\u53d1\u73b0\u76f4\u63a5\u5bf9 Goemans and Rothvoss (SODA '14), Jansen and Klein (SODA '17) \u548c Jansen and Solis-Oba (IPCO '10) \u7b49\u88c5\u7bb1\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\u4ea7\u751f\u4e86\u5f71\u54cd\u3002", "conclusion": "\u672c\u6587\u8bc1\u660e\u4e86\u5177\u6709 $d$ \u79cd\u4e0d\u540c\u5c3a\u5bf8\u7269\u54c1\u7684\u7ecf\u5178\u88c5\u7bb1\u95ee\u9898\uff0c\u5176\u89e3\u7684\u652f\u6301\u96c6\u5927\u5c0f\u7684\u4e0b\u754c\u662f $2^{\\Omega(d)}$\u3002\u8fd9\u4e00\u7ed3\u679c\u4e0e\u73b0\u6709\u4e0a\u754c $2^d$ \u5728\u5e38\u6570\u56e0\u5b50\u4e0a\u5339\u914d\u3002\u8fd9\u4e00\u7ed3\u679c\u76f4\u63a5\u5f71\u54cd\u4e86\u591a\u79cd\u88c5\u7bb1\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5e76\u4e3a\u89e3\u51b3\u4e00\u822c\u6574\u6570\u7ebf\u6027\u89c4\u5212\u548c $d$ \u7ef4\u80cc\u5305\u95ee\u9898\u63d0\u4f9b\u4e86\u4e00\u4e2a\u65b0\u7684\u6280\u672f\u5de5\u5177\u3002"}}
{"id": "2512.02546", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.02546", "abs": "https://arxiv.org/abs/2512.02546", "authors": ["Jan Meizner", "Maciej Malawski"], "title": "Solutions for Distributed Memory Access Mechanism on HPC Clusters", "comment": null, "summary": "Paper presents and evaluates various mechanisms for remote access to memory in distributed systems based on two distinct HPC clusters. We are comparing solutions based on the shared storage and MPI (over Infiniband and Slingshot) to the local memory access. This paper also mentions medical use-cases that would mostly benefit from the described solution. We have found out that results for remote access esp. backed by MPI are similar to local memory access.", "AI": {"tldr": "\u8be5\u8bba\u6587\u6d89\u53ca\u56fe\u5904\u7406\u3001\u7f16\u8bd1\u5668\u3001HLS\u3001MLIR\u3001DSL\u4e2d\u7684 **\u65e0**\u3002\n\u672c\u6587\u5728\u4e24\u4e2a\u4e0d\u540c\u7684HPC\u96c6\u7fa4\u4e0a\uff0c\u8bc4\u4f30\u4e86\u57fa\u4e8e\u5171\u4eab\u5b58\u50a8\u548cMPI\u7684\u5206\u5e03\u5f0f\u7cfb\u7edf\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u673a\u5236\u7684\u6027\u80fd\uff0c\u5e76\u4e0e\u672c\u5730\u5185\u5b58\u8bbf\u95ee\u8fdb\u884c\u4e86\u6bd4\u8f83\u3002\u7814\u7a76\u53d1\u73b0\uff0c\u7279\u522b\u662f\u901a\u8fc7Infiniband\u548cSlingshot\u4e0a\u7684MPI\u5b9e\u73b0\u7684\u8fdc\u7a0b\u8bbf\u95ee\u6027\u80fd\u4e0e\u672c\u5730\u5185\u5b58\u8bbf\u95ee\u6027\u80fd\u76f8\u8fd1\uff0c\u8fd9\u5bf9\u4e3b\u8981\u7684\u533b\u7597\u7528\u4f8b\u975e\u5e38\u6709\u76ca\u3002", "motivation": "\u672c\u6587\u7684\u52a8\u673a\u5728\u4e8e\u63a2\u7d22\u548c\u8bc4\u4f30\u5728\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\uff0c\u5b9e\u73b0\u9ad8\u6548\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u7684\u4e0d\u540c\u673a\u5236\uff0c\u7279\u522b\u662f\u4e3a\u4e86\u6ee1\u8db3\u533b\u7597\u7528\u4f8b\u7b49\u9886\u57df\u7684\u6027\u80fd\u9700\u6c42\u3002", "method": "\u672c\u6587\u901a\u8fc7\u5728\u4e00\u4e2a\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u7684\u4e24\u4e2a\u4e0d\u540c\u7684HPC\u96c6\u7fa4\u4e0a\uff0c\u8bc4\u4f30\u4e86\u57fa\u4e8e\u5171\u4eab\u5b58\u50a8\u548c\u57fa\u4e8eMPI\uff08\u901a\u8fc7Infiniband\u548cSlingshot\uff09\u7684\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u89e3\u51b3\u65b9\u6848\uff0c\u5e76\u5c06\u5176\u6027\u80fd\u4e0e\u672c\u5730\u5185\u5b58\u8bbf\u95ee\u8fdb\u884c\u4e86\u6bd4\u8f83\u3002", "result": "\u7814\u7a76\u53d1\u73b0\uff0c\u5bf9\u4e8e\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\uff0c\u7279\u522b\u662f\u90a3\u4e9b\u7531MPI\u652f\u6301\u7684\u65b9\u6848\uff0c\u5176\u7ed3\u679c\u4e0e\u672c\u5730\u5185\u5b58\u8bbf\u95ee\u7684\u7ed3\u679c\u76f8\u4f3c\u3002\u8fd9\u8868\u660e\u901a\u8fc7MPI\u7b49\u673a\u5236\u53ef\u4ee5\u5b9e\u73b0\u4e0e\u672c\u5730\u5185\u5b58\u8bbf\u95ee\u76f8\u5ab2\u7f8e\u7684\u9ad8\u6548\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u3002", "conclusion": "\u672c\u6587\u8bc4\u4f30\u4e86\u5728\u57fa\u4e8e\u9ad8\u6027\u80fd\u8ba1\u7b97\uff08HPC\uff09\u96c6\u7fa4\u7684\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\uff0c\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u7684\u5404\u79cd\u673a\u5236\uff0c\u5e76\u53d1\u73b0\u7279\u522b\u662f\u57fa\u4e8eMPI\uff08\u901a\u8fc7Infiniband\u548cSlingshot\uff09\u7684\u8fdc\u7a0b\u5185\u5b58\u8bbf\u95ee\u7684\u7ed3\u679c\u4e0e\u672c\u5730\u5185\u5b58\u8bbf\u95ee\u7684\u7ed3\u679c\u76f8\u8fd1\u3002\u8fd9\u8868\u660e\u5728\u5206\u5e03\u5f0f\u73af\u5883\u7279\u522b\u662f\u533b\u7597\u5e94\u7528\u573a\u666f\u4e2d\uff0c\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e9b\u6280\u672f\u5b9e\u73b0\u9ad8\u6548\u7684\u5185\u5b58\u8bbf\u95ee\u3002"}}
{"id": "2512.02738", "categories": ["cs.PL", "cs.CL"], "pdf": "https://arxiv.org/pdf/2512.02738", "abs": "https://arxiv.org/abs/2512.02738", "authors": ["Joel Nyholm", "Wojciech Mostowski", "Christoph Reichenbach"], "title": "Probabilistic energy profiler for statically typed JVM-based programming languages", "comment": null, "summary": "Energy consumption is a growing concern in several fields, from mobile devices to large data centers. Developers need detailed data on the energy consumption of their software to mitigate consumption issues. Previous approaches have a broader focus, such as on specific functions or programs, rather than source code statements. They primarily focus on estimating the CPU's energy consumption using point estimates, thereby disregarding other hardware effects and limiting their use for statistical reasoning and explainability. We developed a novel methodology to address the limitations of measuring only the CPU's consumption and using point estimates, focusing on predicting the energy usage of statically typed JVM-based programming languages, such as Java and Scala. We measure the energy consumption of Bytecode patterns, the translation from the programming language's source code statement to their Java Bytecode representation. With the energy measurements, we construct a statistical model using Bayesian statistics, which allows us to predict the energy consumption through statistical distributions and analyze individual factors. The model includes three factors we obtain statically from the code: data size, data type, operation, and one factor about the hardware platform the code executes on: device. To validate our methodology, we implemented it for Java and evaluated its energy predictions on unseen programs. We observe that all four factors are influential, notably that two devices of the same model may differ in energy consumption and that the operations and data types cause consumption differences. The experiments also show that the energy prediction of programs closely follows the program's real energy consumption, validating our approach. Our work presents a methodology for constructing an energy model that future work, such as verification tools, can use for their energy estimates.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e\u7f16\u8bd1\u5668\u3001DSL\u3001\u56fe\u5904\u7406\u3001MLIR\u3001HLS \u5747\u4e0d\u76f4\u63a5\u76f8\u5173\u3002\n\n\u592a\u957f\u4e0d\u8bfb\u6458\u8981\uff1a\u80fd\u6e90\u6d88\u8017\u662f\u8f6f\u4ef6\u5f00\u53d1\u4e2d\u7684\u4e00\u4e2a\u91cd\u8981\u5173\u6ce8\u70b9\u3002\u73b0\u6709\u65b9\u6cd5\u5728\u7c92\u5ea6\u4e0a\uff08\u975e\u6e90\u4ee3\u7801\u8bed\u53e5\u7ea7\u522b\uff09\u548c\u51c6\u786e\u6027\u4e0a\uff08\u4ec5\u4f30\u8ba1 CPU \u6d88\u8017\u4e14\u4f7f\u7528\u70b9\u4f30\u8ba1\uff09\u5b58\u5728\u5c40\u9650\u3002\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u65b9\u6cd5\u8bba\uff0c\u4e13\u95e8\u9488\u5bf9 Java/Scala \u7b49\u57fa\u4e8e JVM \u7684\u9759\u6001\u7c7b\u578b\u8bed\u8a00\uff0c\u901a\u8fc7\u6d4b\u91cf**\u5b57\u8282\u7801\u6a21\u5f0f**\u7684\u80fd\u6e90\u6d88\u8017\uff0c\u5e76\u4f7f\u7528**\u8d1d\u53f6\u65af\u7edf\u8ba1**\u6784\u5efa**\u7edf\u8ba1\u6a21\u578b**\u6765\u9884\u6d4b\u80fd\u6e90\u6d88\u8017\u3002\u6a21\u578b\u8003\u8651\u4e86**\u6570\u636e\u5927\u5c0f\u3001\u6570\u636e\u7c7b\u578b\u3001\u64cd\u4f5c**\u548c**\u786c\u4ef6\u8bbe\u5907**\u56db\u4e2a\u5173\u952e\u56e0\u7d20\u3002\u5b9e\u9a8c\u8bc1\u660e\u6240\u6709\u56e0\u7d20\u5747\u6709\u5f71\u54cd\uff0c\u7279\u522b\u662f\u8bbe\u5907\u5dee\u5f02\u548c\u64cd\u4f5c/\u6570\u636e\u7c7b\u578b\uff0c\u5e76\u4e14\u8be5\u65b9\u6cd5\u5bf9\u672a\u89c1\u7a0b\u5e8f\u7684\u80fd\u6e90\u9884\u6d4b**\u5177\u6709\u9ad8\u51c6\u786e\u6027**\uff0c\u9a8c\u8bc1\u4e86\u5176\u6709\u6548\u6027\u3002\u8be5\u80fd\u6e90\u6a21\u578b\u53ef\u4f9b\u672a\u6765\u7684\u9a8c\u8bc1\u5de5\u5177\u4f7f\u7528\u3002", "motivation": "\u80fd\u6e90\u6d88\u8017\u65e5\u76ca\u6210\u4e3a\u4e00\u4e2a\u91cd\u8981\u95ee\u9898\uff0c\u5f00\u53d1\u8005\u9700\u8981\u8be6\u7ec6\u7684\u8f6f\u4ef6\u80fd\u6e90\u6d88\u8017\u6570\u636e\u6765\u7f13\u89e3\u95ee\u9898\u3002\u73b0\u6709\u7684\u65b9\u6cd5\u901a\u5e38\u5173\u6ce8\u66f4\u5e7f\u6cdb\u7684\u8303\u56f4\uff08\u5982\u7279\u5b9a\u51fd\u6570\u6216\u7a0b\u5e8f\uff09\uff0c\u800c\u4e0d\u662f\u6e90\u4ee3\u7801\u8bed\u53e5\u7ea7\u522b\uff0c\u5e76\u4e14\u4e3b\u8981\u901a\u8fc7\u70b9\u4f30\u8ba1\u6765\u4f30\u7b97 CPU \u7684\u80fd\u6e90\u6d88\u8017\uff0c\u5ffd\u7565\u4e86\u5176\u4ed6\u786c\u4ef6\u5f71\u54cd\uff0c\u9650\u5236\u4e86\u7edf\u8ba1\u63a8\u7406\u548c\u53ef\u89e3\u91ca\u6027\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u65b0\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u4ec5\u6d4b\u91cf CPU \u6d88\u8017\u548c\u4f7f\u7528\u70b9\u4f30\u8ba1\u7684\u5c40\u9650\u6027\u3002", "method": "\u5f00\u53d1\u4e86\u4e00\u79cd\u65b0\u7684\u65b9\u6cd5\u8bba\uff0c\u7528\u4e8e\u9884\u6d4b\u9759\u6001\u7c7b\u578b\u3001\u57fa\u4e8e JVM \u7684\u7f16\u7a0b\u8bed\u8a00\uff08\u5982 Java \u548c Scala\uff09\u7684\u80fd\u6e90\u4f7f\u7528\u3002\u6838\u5fc3\u65b9\u6cd5\u662f\u6d4b\u91cf\u5b57\u8282\u7801\u6a21\u5f0f\uff08\u5373\u7f16\u7a0b\u8bed\u8a00\u6e90\u4ee3\u7801\u8bed\u53e5\u5230 Java \u5b57\u8282\u7801\u8868\u793a\u7684\u8f6c\u6362\uff09\u7684\u80fd\u6e90\u6d88\u8017\u3002\u5229\u7528\u8fd9\u4e9b\u80fd\u6e90\u6d4b\u91cf\uff0c\u4f7f\u7528\u8d1d\u53f6\u65af\u7edf\u8ba1\u6784\u5efa\u4e86\u4e00\u4e2a\u7edf\u8ba1\u6a21\u578b\uff0c\u8be5\u6a21\u578b\u80fd\u591f\u901a\u8fc7\u7edf\u8ba1\u5206\u5e03\u8fdb\u884c\u80fd\u6e90\u6d88\u8017\u9884\u6d4b\uff0c\u5e76\u5206\u6790\u4e2a\u4f53\u56e0\u7d20\u3002\u6a21\u578b\u5305\u542b\u56db\u4e2a\u56e0\u7d20\uff1a\u9759\u6001\u83b7\u53d6\u7684\u6570\u636e\u5927\u5c0f\u3001\u6570\u636e\u7c7b\u578b\u3001\u64cd\u4f5c\uff0c\u4ee5\u53ca\u5173\u4e8e\u4ee3\u7801\u6267\u884c\u786c\u4ef6\u5e73\u53f0\u7684\u8bbe\u5907\u4fe1\u606f\u3002\u901a\u8fc7\u4e3a Java \u5b9e\u73b0\u8be5\u65b9\u6cd5\u5e76\u5bf9\u672a\u89c1\u8fc7\u7684\u7a0b\u5e8f\u8fdb\u884c\u8bc4\u4f30\u6765\u9a8c\u8bc1\u65b9\u6cd5\u8bba\u3002", "result": "\u56db\u4e2a\u56e0\u7d20\uff08\u6570\u636e\u5927\u5c0f\u3001\u6570\u636e\u7c7b\u578b\u3001\u64cd\u4f5c\u3001\u8bbe\u5907\uff09\u90fd\u88ab\u89c2\u5bdf\u5230\u5bf9\u80fd\u6e90\u6d88\u8017\u6709\u5f71\u54cd\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5373\u4f7f\u662f\u540c\u4e00\u578b\u53f7\u7684\u8bbe\u5907\u4e5f\u53ef\u80fd\u5728\u80fd\u6e90\u6d88\u8017\u4e0a\u6709\u6240\u4e0d\u540c\uff0c\u5e76\u4e14\u64cd\u4f5c\u548c\u6570\u636e\u7c7b\u578b\u4f1a\u5bfc\u81f4\u6d88\u8017\u5dee\u5f02\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u7a0b\u5e8f\u7684\u80fd\u6e90\u9884\u6d4b\u4e0e\u7a0b\u5e8f\u7684\u5b9e\u9645\u80fd\u6e90\u6d88\u8017\u975e\u5e38\u63a5\u8fd1\uff0c\u9a8c\u8bc1\u4e86\u8be5\u65b9\u6cd5\u7684\u6709\u6548\u6027\u3002", "conclusion": "\u6211\u4eec\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u65b9\u6cd5\u8bba\uff0c\u7528\u4e8e\u6784\u5efa\u8f6f\u4ef6\u80fd\u6e90\u6d88\u8017\u6a21\u578b\u3002\u8be5\u6a21\u578b\u57fa\u4e8e\u5bf9 Java \u5b57\u8282\u7801\u6a21\u5f0f\u7684\u80fd\u6e90\u6d4b\u91cf\uff0c\u5e76\u4f7f\u7528\u8d1d\u53f6\u65af\u7edf\u8ba1\u65b9\u6cd5\u8fdb\u884c\u5efa\u6a21\uff0c\u4ece\u800c\u80fd\u591f\u4ee5\u7edf\u8ba1\u5206\u5e03\u7684\u5f62\u5f0f\u9884\u6d4b\u80fd\u6e90\u6d88\u8017\uff0c\u5e76\u5206\u6790\u6570\u636e\u5927\u5c0f\u3001\u6570\u636e\u7c7b\u578b\u3001\u64cd\u4f5c\u548c\u786c\u4ef6\u8bbe\u5907\u7b49\u4e2a\u4f53\u56e0\u7d20\u7684\u5f71\u54cd\u3002\u5b9e\u9a8c\u9a8c\u8bc1\u4e86\u8be5\u65b9\u6cd5\u5728\u9884\u6d4b Java \u7a0b\u5e8f\u80fd\u6e90\u6d88\u8017\u65b9\u9762\u7684\u6709\u6548\u6027\uff0c\u5e76\u63ed\u793a\u4e86\u6240\u6709\u56e0\u7d20\uff0c\u7279\u522b\u662f\u786c\u4ef6\u8bbe\u5907\u5dee\u5f02\u548c\u64cd\u4f5c/\u6570\u636e\u7c7b\u578b\u5bf9\u80fd\u6e90\u6d88\u8017\u7684\u91cd\u8981\u6027\u3002\u8fd9\u9879\u5de5\u4f5c\u4e3a\u672a\u6765\u5982\u9a8c\u8bc1\u5de5\u5177\u7b49\u5229\u7528\u80fd\u6e90\u6a21\u578b\u7684\u5e94\u7528\u5960\u5b9a\u4e86\u57fa\u7840\u3002"}}
{"id": "2512.02875", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.02875", "abs": "https://arxiv.org/abs/2512.02875", "authors": ["Cristian Tirelli", "Lorenzo Ferretti", "Laura Pozzi"], "title": "SAT-MapIt: A SAT-based Modulo Scheduling Mapper for Coarse Grain Reconfigurable Architectures", "comment": null, "summary": "Coarse-Grain Reconfigurable Arrays (CGRAs) are emerging low-power architectures aimed at accelerating compute-intensive application loops. The acceleration that a CGRA can ultimately provide, however, heavily depends on the quality of the mapping, i.e. on how effectively the loop is compiled onto the given platform. State of the Art compilation techniques achieve mapping through modulo scheduling, a strategy which attempts to minimize the II (Iteration Interval) needed to execute a loop, and they do so usually through well known graph algorithms, such as Max-Clique Enumeration.\n  We address the mapping problem through a SAT formulation, instead, and thus explore the solution space more effectively than current SoA tools. To formulate the SAT problem, we introduce an ad-hoc schedule called the \\textit{kernel mobility schedule} (KMS), which we use in conjunction with the data-flow graph and the architectural information of the CGRA in order to create a set of boolean statements that describe all constraints to be obeyed by the mapping for a given II. We then let the SAT solver efficiently navigate this complex space. As in other SoA techniques, the process is iterative: if a valid mapping does not exist for the given II, the II is increased and a new KMS and set of constraints is generated and solved.\n  Our experimental results show that SAT-MapIt obtains better results compared to SoA alternatives in $47.72\\%$ of the benchmarks explored: sometimes finding a lower II, and others even finding a valid mapping when none could previously be found.", "AI": {"tldr": "\u5173\u8054\uff1a\u7f16\u8bd1\u5668\uff08Compilation\uff09\u3001\u56fe\u5904\u7406\uff08Graph Algorithms, Data-Flow Graph\uff09\u3001DSL\uff08\u6307\u4ee3\u5faa\u73af\uff09\uff0cHLS\u6216MLIR\u672a\u63d0\u53ca\uff1b\u56fe\u5904\u7406\u6216\u7f16\u8bd1\u5668\u66f4\u76f8\u5173\u3002Too long; didn't read: Coarse-Grain Reconfigurable Arrays (CGRAs) \u7684\u6027\u80fd\u4f9d\u8d56\u4e8e\u9ad8\u8d28\u91cf\u7684\u5faa\u73af\u6620\u5c04\u3002\u73b0\u6709\u6280\u672f\u4f7f\u7528\u6a21\u8c03\u5ea6\u548c\u6700\u5927\u56e2\u679a\u4e3e\u3002\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8e SAT \u7684 CGRA \u5faa\u73af\u6620\u5c04\u65b9\u6cd5 SAT-MapIt\uff0c\u5b83\u4f7f\u7528\u201c\u5185\u6838\u79fb\u52a8\u6027\u8c03\u5ea6\u201d\uff08KMS\uff09\u5c06\u6620\u5c04\u95ee\u9898\u8868\u8ff0\u4e3a\u4e00\u7cfb\u5217\u5e03\u5c14\u7ea6\u675f\uff0c\u5e76\u5229\u7528 SAT \u6c42\u89e3\u5668\u9ad8\u6548\u5730\u63a2\u7d22\u89e3\u7a7a\u95f4\u3002SAT-MapIt \u91c7\u7528\u8fed\u4ee3\u65b9\u5f0f\u5c1d\u8bd5\u6700\u5c0f\u5316 II (Iteration Interval)\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0cSAT-MapIt \u5728 47.72% \u7684\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u4f18\u4e8e\u73b0\u6709\u6280\u672f\uff0c\u6709\u65f6\u80fd\u53d1\u73b0\u66f4\u5c0f\u7684 II\uff0c\u751a\u81f3\u80fd\u5728\u73b0\u6709\u5de5\u5177\u5931\u8d25\u65f6\u627e\u5230\u6709\u6548\u6620\u5c04\u3002", "motivation": "CGRA \u7684\u52a0\u901f\u6027\u80fd\u9ad8\u5ea6\u4f9d\u8d56\u4e8e\u6620\u5c04\u8d28\u91cf\uff0c\u800c\u73b0\u6709\u6700\u5148\u8fdb\u7684\u57fa\u4e8e\u6a21\u8c03\u5ea6\uff08Modulo Scheduling\uff09\u548c\u56fe\u7b97\u6cd5\uff08\u5982\u6700\u5927\u56e2\u679a\u4e3e\uff09\u7684\u7f16\u8bd1\u6280\u672f\u5728\u6709\u6548\u63a2\u7d22\u89e3\u7a7a\u95f4\u65b9\u9762\u53ef\u80fd\u5b58\u5728\u4e0d\u8db3\uff0c\u9700\u8981\u66f4\u9ad8\u6548\u5730\u89e3\u51b3 CGRA \u5faa\u73af\u6620\u5c04\u95ee\u9898\uff0c\u4ee5\u6700\u5c0f\u5316\u8fed\u4ee3\u95f4\u9694\uff08II\uff09\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3a SAT-MapIt \u7684\u57fa\u4e8e SAT \u7684\u7f16\u8bd1\u65b9\u6cd5\u3002\u8be5\u65b9\u6cd5\u5f15\u5165\u4e86 ad-hoc \u7684\u201c\u5185\u6838\u79fb\u52a8\u6027\u8c03\u5ea6\u201d\uff08KMS\uff09\uff0c\u7ed3\u5408\u6570\u636e\u6d41\u56fe\u548c CGRA \u67b6\u6784\u4fe1\u606f\uff0c\u751f\u6210\u63cf\u8ff0\u7ed9\u5b9a II \u6620\u5c04\u6240\u6709\u7ea6\u675f\u7684\u5e03\u5c14\u8bed\u53e5\u96c6\u3002\u7136\u540e\u4f7f\u7528 SAT \u6c42\u89e3\u5668\u8fed\u4ee3\u5730\u627e\u5230\u6709\u6548\u7684\u6620\u5c04\uff0c\u5982\u679c\u627e\u4e0d\u5230\uff0c\u5219\u589e\u52a0 II\uff0c\u91cd\u65b0\u751f\u6210 KMS \u548c\u7ea6\u675f\u5e76\u518d\u6b21\u6c42\u89e3\u3002", "result": "SAT-MapIt \u5728 47.72% \u7684\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u83b7\u5f97\u4e86\u4f18\u4e8e\u73b0\u6709\u6280\u672f\u7684\u7ed3\u679c\uff0c\u5305\u62ec\u627e\u5230\u66f4\u5c0f\u7684 II\uff0c\u751a\u81f3\u5728\u73b0\u6709\u6280\u672f\u65e0\u6cd5\u627e\u5230\u6709\u6548\u6620\u5c04\u65f6\u6210\u529f\u627e\u5230\u4e86\u6620\u5c04\u3002", "conclusion": "SAT-MapIt \u5728\u5bfb\u627e CGRA \u6700\u4f73\u5faa\u73af\u6620\u5c04\u65b9\u9762\u4f18\u4e8e\u73b0\u6709\u6280\u672f\uff0c\u5728 47.72% \u7684\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u83b7\u5f97\u4e86\u66f4\u597d\u7684\u7ed3\u679c\uff0c\u5305\u62ec\u5b9e\u73b0\u66f4\u5c0f\u7684\u8fed\u4ee3\u95f4\u9694\uff08II\uff09\u3002"}}
{"id": "2512.02646", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.02646", "abs": "https://arxiv.org/abs/2512.02646", "authors": ["Alex Barcel\u00f3", "Sebasti\u00e1n A. Cajas Ordo\u00f1ez", "Jaydeep Samanta", "Andr\u00e9s L. Su\u00e1rez-Cetrulo", "Romila Ghosh", "Ricardo Sim\u00f3n Carbajo", "Anna Queralt"], "title": "Offloading Artificial Intelligence Workloads across the Computing Continuum by means of Active Storage Systems", "comment": "17 pages, 7 tables, 12 figures", "summary": "The increasing demand for artificial intelligence (AI) workloads across diverse computing environments has driven the need for more efficient data management strategies. Traditional cloud-based architectures struggle to handle the sheer volume and velocity of AI-driven data, leading to inefficiencies in storage, computation, and data movement. This paper explores the integration of active storage systems within the computing continuum to optimize AI workload distribution.\n  By embedding computation directly into storage architectures, active storage is able to reduce data transfer overhead, enhancing performance and improving resource utilization. Other existing frameworks and architectures offer mechanisms to distribute certain AI processes across distributed environments; however, they lack the flexibility and adaptability that the continuum requires, both regarding the heterogeneity of devices and the rapid-changing algorithms and models being used by domain experts and researchers.\n  This article proposes a software architecture aimed at seamlessly distributing AI workloads across the computing continuum, and presents its implementation using mainstream Python libraries and dataClay, an active storage platform. The evaluation shows the benefits and trade-offs regarding memory consumption, storage requirements, training times, and execution efficiency across different devices. Experimental results demonstrate that the process of offloading workloads through active storage significantly improves memory efficiency and training speeds while maintaining accuracy. Our findings highlight the potential of active storage to revolutionize AI workload management, making distributed AI deployments more scalable and resource-efficient with a very low entry barrier for domain experts and application developers.", "AI": {"tldr": "\u76f8\u5173\u6027\uff1a\u8be5\u8bba\u6587\u4e0e\u7f16\u8bd1\u5668\uff08\u5e7f\u4e49\u4e0a\u7684\u4f18\u5316\u548c\u5f02\u6784\u8bbe\u5907\u4e0a\u7684\u8d44\u6e90\u7ba1\u7406\u4e0e\u5206\u914d\u7b56\u7565\uff09\u3001\u56fe\u5904\u7406\uff08\u672a\u76f4\u63a5\u63d0\u53ca\uff0c\u4f46\u5206\u5e03\u5f0f\u6570\u636e\u7ba1\u7406\u548c\u8ba1\u7b97\u53ef\u80fd\u6d89\u53ca\uff09\u3001MLIR\uff08\u672a\u76f4\u63a5\u63d0\u53ca\uff0c\u4f46\u5f02\u6784\u8ba1\u7b97\u7684\u62bd\u8c61\u548c\u4f18\u5316\u76f8\u5173\uff09\u3001DSL\uff08\u672a\u76f4\u63a5\u63d0\u53ca\uff0c\u4f46\u8f6f\u4ef6\u67b6\u6784\u548c\u5e93\u7684\u4f7f\u7528\u53ef\u80fd\u6d89\u53ca\uff09\u6216HLS\uff08\u672a\u76f4\u63a5\u63d0\u53ca\uff0c\u4f46\u5f02\u6784\u52a0\u901f\u548c\u8d44\u6e90\u9ad8\u6548\u5229\u7528\u76f8\u5173\uff09\u9886\u57df\u5177\u6709\u4e00\u5b9a\u7684\u76f8\u5173\u6027\uff0c\u4e3b\u8981\u5728AI\u5de5\u4f5c\u8d1f\u8f7d\u5206\u5e03\u5f0f\u7ba1\u7406\u548c\u8d44\u6e90\u4f18\u5316\u65b9\u9762\u3002TLDR\uff1a\u9488\u5bf9\u4f20\u7edf\u4e91\u67b6\u6784\u5904\u7406AI\u5de5\u4f5c\u6570\u636e\u91cf\u7684\u6548\u7387\u4f4e\u4e0b\u548c\u73b0\u6709\u6846\u67b6\u7f3a\u4e4f\u9002\u5e94\u6027\u95ee\u9898\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u96c6\u6210\u4e3b\u52a8\u5b58\u50a8\uff08dataClay\uff09\u7684\u8f6f\u4ef6\u67b6\u6784\uff0c\u7528\u4e8e\u5728\u8ba1\u7b97\u8fde\u7eed\u4f53\u4e2d\u65e0\u7f1d\u5206\u53d1AI\u5de5\u4f5c\u8d1f\u8f7d\u3002\u5b9e\u9a8c\u8bc1\u660e\uff0c\u8be5\u65b9\u6cd5\u901a\u8fc7\u5c06\u8ba1\u7b97\u5d4c\u5165\u5b58\u50a8\u67b6\u6784\u6765\u51cf\u5c11\u6570\u636e\u4f20\u8f93\u5f00\u9500\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u5185\u5b58\u6548\u7387\u548c\u8bad\u7ec3\u901f\u5ea6\uff0c\u4e3a\u5206\u5e03\u5f0fAI\u90e8\u7f72\u63d0\u4f9b\u4e86\u66f4\u5177\u53ef\u6269\u5c55\u6027\u548c\u8d44\u6e90\u6548\u7387\u7684\u89e3\u51b3\u65b9\u6848\u3002", "motivation": "\u4f20\u7edf\u4e91\u8ba1\u7b97\u67b6\u6784\u96be\u4ee5\u6709\u6548\u5904\u7406AI\u9a71\u52a8\u6570\u636e\u7684\u5927\u91cf\u548c\u9ad8\u901f\u589e\u957f\uff0c\u5bfc\u81f4\u5b58\u50a8\u3001\u8ba1\u7b97\u548c\u6570\u636e\u79fb\u52a8\u6548\u7387\u4f4e\u4e0b\u3002\u540c\u65f6\uff0c\u73b0\u6709\u7684\u5206\u5e03\u5f0fAI\u6846\u67b6\u7f3a\u4e4f\u8ba1\u7b97\u8fde\u7eed\u4f53\u6240\u9700\u7684\u7075\u6d3b\u6027\u548c\u9002\u5e94\u6027\uff0c\u5c24\u5176\u5728\u8bbe\u5907\u5f02\u6784\u6027\u548c\u5feb\u901f\u53d8\u5316\u7684AI\u7b97\u6cd5\u548c\u6a21\u578b\u65b9\u9762\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u66f4\u9ad8\u6548\u7684\u6570\u636e\u7ba1\u7406\u7b56\u7565\uff0c\u7279\u522b\u662f\u5c06\u4e3b\u52a8\u5b58\u50a8\u7cfb\u7edf\u96c6\u6210\u5230\u8ba1\u7b97\u8fde\u7eed\u4f53\u4e2d\uff0c\u4ee5\u4f18\u5316AI\u5de5\u4f5c\u8d1f\u8f7d\u5206\u5e03\u3002", "method": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u8f6f\u4ef6\u67b6\u6784\uff0c\u65e8\u5728\u8de8\u8ba1\u7b97\u8fde\u7eed\u4f53\u65e0\u7f1d\u5206\u53d1AI\u5de5\u4f5c\u8d1f\u8f7d\uff0c\u5e76\u4f7f\u7528\u4e3b\u6d41Python\u5e93\u548c\u4e3b\u52a8\u5b58\u50a8\u5e73\u53f0dataClay\u8fdb\u884c\u4e86\u5b9e\u73b0\u3002\u901a\u8fc7\u5b9e\u9a8c\u8bc4\u4f30\u4e86\u8be5\u65b9\u6cd5\u5728\u5185\u5b58\u6d88\u8017\u3001\u5b58\u50a8\u9700\u6c42\u3001\u8bad\u7ec3\u65f6\u95f4\u3001\u4ee5\u53ca\u8de8\u4e0d\u540c\u8bbe\u5907\u7684\u6267\u884c\u6548\u7387\u7b49\u65b9\u9762\u7684\u6027\u80fd\u548c\u6743\u8861\u3002", "result": "\u901a\u8fc7\u4e3b\u52a8\u5b58\u50a8\u5b9e\u73b0\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5378\u8f7d\u663e\u8457\u63d0\u9ad8\u4e86\u5185\u5b58\u6548\u7387\u548c\u8bad\u7ec3\u901f\u5ea6\uff0c\u540c\u65f6\u4fdd\u6301\u4e86\u51c6\u786e\u6027\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u8be5\u65b9\u6cd5\u5728\u63d0\u9ad8AI\u5de5\u4f5c\u8d1f\u8f7d\u5206\u5e03\u5f0f\u90e8\u7f72\u7684\u53ef\u6269\u5c55\u6027\u548c\u8d44\u6e90\u6548\u7387\u65b9\u9762\u5177\u6709\u5de8\u5927\u6f5c\u529b\u3002", "conclusion": "\u4e3b\u52a8\u5b58\u50a8\u901a\u8fc7\u5c06\u8ba1\u7b97\u5d4c\u5165\u5230\u5b58\u50a8\u67b6\u6784\u4e2d\uff0c\u663e\u8457\u63d0\u5347\u4e86AI\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5206\u5e03\u5f0f\u90e8\u7f72\u6548\u7387\u548c\u8d44\u6e90\u5229\u7528\u7387\u3002\u5b83\u5728\u5185\u5b58\u6548\u7387\u548c\u8bad\u7ec3\u901f\u5ea6\u65b9\u9762\u7684\u6539\u8fdb\u8868\u660e\u5176\u6709\u6f5c\u529b\u5f7b\u5e95\u6539\u53d8AI\u5de5\u4f5c\u8d1f\u8f7d\u7ba1\u7406\uff0c\u4f7f\u5206\u5e03\u5f0fAI\u90e8\u7f72\u66f4\u5177\u53ef\u6269\u5c55\u6027\u548c\u8d44\u6e90\u6548\u7387\uff0c\u5e76\u964d\u4f4e\u4e86\u9886\u57df\u4e13\u5bb6\u548c\u5e94\u7528\u5f00\u53d1\u8005\u7684\u4f7f\u7528\u95e8\u69db\u3002"}}
{"id": "2512.02966", "categories": ["cs.PL", "cs.AI", "cs.MA"], "pdf": "https://arxiv.org/pdf/2512.02966", "abs": "https://arxiv.org/abs/2512.02966", "authors": ["Isha Chaudhary", "Vedaant Jain", "Avaljot Singh", "Kavya Sachdeva", "Sayan Ranu", "Gagandeep Singh"], "title": "Lumos: Let there be Language Model System Certification", "comment": null, "summary": "We introduce the first principled framework, Lumos, for specifying and formally certifying Language Model System (LMS) behaviors. Lumos is an imperative probabilistic programming DSL over graphs, with constructs to generate independent and identically distributed prompts for LMS. It offers a structured view of prompt distributions via graphs, forming random prompts from sampled subgraphs. Lumos supports certifying LMS for arbitrary prompt distributions via integration with statistical certifiers. We provide hybrid (operational and denotational) semantics for Lumos, providing a rigorous way to interpret the specifications. Using only a small set of composable constructs, Lumos can encode existing LMS specifications, including complex relational and temporal specifications. It also facilitates specifying new properties - we present the first safety specifications for vision-language models (VLMs) in autonomous driving scenarios developed with Lumos. Using these, we show that the state-of-the-art VLM Qwen-VL exhibits critical safety failures, producing incorrect and unsafe responses with at least 90% probability in right-turn scenarios under rainy driving conditions, revealing substantial safety risks. Lumos's modular structure allows easy modification of the specifications, enabling LMS certification to stay abreast with the rapidly evolving threat landscape. We further demonstrate that specification programs written in Lumos enable finding specific failure cases exhibited by state-of-the-art LMS. Lumos is the first systematic and extensible language-based framework for specifying and certifying LMS behaviors, paving the way for a wider adoption of LMS certification.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e DSL \u548c\u56fe\u5904\u7406\u76f8\u5173\u3002\n**\u592a\u957f\u4e0d\u770b\uff08TLDR\uff09:** Lumos \u662f\u9996\u4e2a\u7528\u4e8e\u89c4\u8303\u548c\u5f62\u5f0f\u5316\u8ba4\u8bc1\u8bed\u8a00\u6a21\u578b\u7cfb\u7edf\uff08LMS\uff09\u884c\u4e3a\u7684\u201c\u53ef\u539f\u7406\u5316\u201d\u6846\u67b6\u3002\u5b83\u662f\u4e00\u4e2a\u547d\u4ee4\u5f0f\u3001\u57fa\u4e8e\u56fe\u7684\u6982\u7387\u7f16\u7a0b DSL\uff0c\u5141\u8bb8\u901a\u8fc7\u56fe\u7ed3\u6784\u5b9a\u4e49\u72ec\u7acb\u540c\u5206\u5e03\u7684\u63d0\u793a\u5206\u5e03\uff0c\u5e76\u96c6\u6210\u7edf\u8ba1\u8ba4\u8bc1\u5668\u8fdb\u884c\u8ba4\u8bc1\u3002Lumos \u4ec5\u7528\u5c11\u91cf\u6784\u9020\u5757\u5c31\u80fd\u7f16\u7801\u590d\u6742\u7684\u5173\u7cfb\u548c\u65f6\u95f4\u89c4\u683c\u3002\u7814\u7a76\u8005\u5229\u7528 Lumos \u5f00\u53d1\u4e86\u81ea\u52a8\u9a7e\u9a76 VLM \u7684\u5b89\u5168\u89c4\u683c\uff0c\u5e76\u53d1\u73b0\u6700\u5148\u8fdb\u7684 VLM (Qwen-VL) \u5728\u7279\u5b9a\u5371\u9669\u573a\u666f\u4e0b\u7684\u5b89\u5168\u5931\u8d25\u7387\u81f3\u5c11\u4e3a 90%\uff0c\u8bc1\u660e\u4e86 Lumos \u5728\u53d1\u73b0\u5173\u952e\u5b89\u5168\u7f3a\u9677\u65b9\u9762\u7684\u6709\u6548\u6027\u548c\u5fc5\u8981\u6027\u3002", "motivation": "\u968f\u7740\u5927\u578b\u8bed\u8a00\u6a21\u578b\u7cfb\u7edf\uff08LMS\uff09\u7684\u5e7f\u6cdb\u5e94\u7528\u548c\u5feb\u901f\u53d1\u5c55\uff0c\u786e\u4fdd\u5176\u884c\u4e3a\u5b89\u5168\uff08\u7279\u522b\u662f\u9762\u5bf9\u4e0d\u65ad\u53d8\u5316\u7684\u5b89\u5168\u5a01\u80c1\uff09\u53d8\u5f97\u81f3\u5173\u91cd\u8981\u3002\u7136\u800c\uff0c\u73b0\u6709\u7684 LMS \u8ba4\u8bc1\u65b9\u6cd5\u7f3a\u4e4f\u4e00\u4e2a\u201c\u53ef\u539f\u7406\u5316\u201d\uff08principled\uff09\u3001\u53ef\u5f62\u5f0f\u5316\u9a8c\u8bc1\u4e14\u6613\u4e8e\u6269\u5c55\u7684\u6846\u67b6\u6765\u51c6\u786e\u5730\u6307\u5b9a\u548c\u7cfb\u7edf\u5730\u8ba4\u8bc1 LMS \u7684\u884c\u4e3a\uff0c\u5c24\u5176\u662f\u5728\u5904\u7406\u590d\u6742\u7684\u63d0\u793a\u5206\u5e03\u548c\u5173\u7cfb/\u65f6\u95f4\u89c4\u683c\u65f6\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u4e2a\u7cfb\u7edf\u6027\u7684\u3001\u57fa\u4e8e\u8bed\u8a00\u7684\u6846\u67b6\u6765\u586b\u8865\u8fd9\u4e00\u7a7a\u767d\uff0c\u63a8\u52a8 LMS \u8ba4\u8bc1\u7684\u66f4\u5e7f\u6cdb\u5e94\u7528\u3002", "method": "Lumos \u662f\u4e00\u4e2a\u547d\u4ee4\u5f0f\u7684\u6982\u7387\u7f16\u7a0b DSL\uff0c\u8fd0\u884c\u5728\u56fe\u7ed3\u6784\u4e4b\u4e0a\u3002\u5b83\u901a\u8fc7\u56fe\u7ed3\u6784\u63d0\u4f9b\u4e86\u5bf9\u63d0\u793a\u5206\u5e03\u7684\u7ed3\u6784\u5316\u89c6\u56fe\uff0c\u5e76\u4ece\u91c7\u6837\u7684\u5b50\u56fe\u4e2d\u5f62\u6210\u968f\u673a\u63d0\u793a\u3002Lumos \u7684\u6838\u5fc3\u65b9\u6cd5\u5305\u62ec\uff1a\n1. **DSL \u8bbe\u8ba1\uff1a** \u5f15\u5165\u53ef\u7ec4\u5408\u7684\u7ed3\u6784\u6765\u7f16\u7801\u590d\u6742\u7684\u73b0\u6709\u548c\u65b0\u9896\u7684 LMS \u89c4\u683c\uff0c\u5305\u62ec\u5173\u7cfb\u548c\u65f6\u95f4\u89c4\u683c\u3002\n2. **\u5f62\u5f0f\u5316\u8bed\u4e49\uff1a** \u63d0\u4f9b\u4e86\u6df7\u5408\uff08\u64cd\u4f5c\u548c\u6307\u79f0\uff09\u8bed\u4e49\uff0c\u4ee5\u4e25\u683c\u89e3\u91ca\u89c4\u683c\u3002\n3. **\u96c6\u6210\u7edf\u8ba1\u8ba4\u8bc1\u5668\uff1a** \u901a\u8fc7\u4e0e\u7edf\u8ba1\u8ba4\u8bc1\u5668\u7684\u96c6\u6210\uff0c\u652f\u6301\u5bf9\u4efb\u610f\u63d0\u793a\u5206\u5e03\u4e0b\u7684 LMS \u8fdb\u884c\u8ba4\u8bc1\u3002\n4. **\u5b9e\u9645\u5e94\u7528\uff1a** \u5229\u7528 Lumos \u5f00\u53d1\u81ea\u52a8\u9a7e\u9a76\u573a\u666f\u4e0b\u89c6\u89c9-\u8bed\u8a00\u6a21\u578b\uff08VLM\uff09\u7684\u9996\u4e2a\u5b89\u5168\u89c4\u683c\uff0c\u5e76\u7528\u5176\u63ed\u793a\u73b0\u6709 VLM \u7684\u5173\u952e\u5b89\u5168\u7f3a\u9677\u3002", "result": "1. **\u6846\u67b6\u7684\u6709\u6548\u6027\uff1a** Lumos \u80fd\u591f\u4ec5\u4f7f\u7528\u5c11\u91cf\u53ef\u7ec4\u5408\u7684\u7ed3\u6784\u6765\u7f16\u7801\u73b0\u6709\u590d\u6742\u7684 LMS \u89c4\u683c\u4ee5\u53ca\u65b0\u7684\u7279\u6027\uff0c\u4f8b\u5982\u81ea\u52a8\u9a7e\u9a76\u573a\u666f\u4e0b VLM \u7684\u9996\u4e2a\u5b89\u5168\u89c4\u683c\u3002\n2. **\u53d1\u73b0\u5173\u952e\u5b89\u5168\u7f3a\u9677\uff1a** \u4f7f\u7528 Lumos \u5f00\u53d1\u7684\u5b89\u5168\u89c4\u683c\uff0c\u7814\u7a76\u4eba\u5458\u53d1\u73b0\u6700\u65b0\u7684 VLM (Qwen-VL) \u5728\u96e8\u5929\u53f3\u8f6c\u573a\u666f\u4e2d\uff0c\u4ea7\u751f\u4e0d\u6b63\u786e\u548c\u4e0d\u5b89\u5168\u7684\u54cd\u5e94\u7684\u6982\u7387\u81f3\u5c11\u4e3a 90%\uff0c\u63ed\u793a\u4e86\u91cd\u5927\u7684\u5b89\u5168\u98ce\u9669\u3002\n3. **\u53ef\u6a21\u5757\u5316\u548c\u53ef\u6269\u5c55\u6027\uff1a** Lumos \u7684\u6a21\u5757\u5316\u7ed3\u6784\u5141\u8bb8\u8f7b\u677e\u4fee\u6539\u89c4\u683c\uff0c\u4f7f\u5176\u80fd\u591f\u8ddf\u4e0a\u5feb\u901f\u6f14\u53d8\u7684\u5b89\u5168\u5a01\u80c1\u3002\n4. **\u6545\u969c\u6848\u4f8b\u751f\u6210\u80fd\u529b\uff1a** \u7ed3\u679c\u8868\u660e\uff0c\u7528 Lumos \u7f16\u5199\u7684\u89c4\u683c\u7a0b\u5e8f\u80fd\u591f\u6709\u6548\u5730\u627e\u5230\u6700\u5148\u8fdb LMS \u6240\u8868\u73b0\u51fa\u7684\u7279\u5b9a\u6545\u969c\u6848\u4f8b\u3002\n5. **\u5f62\u5f0f\u5316\u57fa\u7840\uff1a** \u63d0\u4f9b\u4e86\u6df7\u5408\u8bed\u4e49\uff0c\u4e3a\u89c4\u683c\u7684\u89e3\u91ca\u63d0\u4f9b\u4e86\u4e25\u683c\u7684\u57fa\u7840\u3002", "conclusion": "Lumos \u662f\u9996\u4e2a\u7cfb\u7edf\u4e14\u53ef\u6269\u5c55\u7684\u57fa\u4e8e\u8bed\u8a00\u7684\u6a21\u578b\u7cfb\u7edf\u884c\u4e3a\u89c4\u8303\u548c\u8ba4\u8bc1\u6846\u67b6\uff0c\u4e3a\u66f4\u5e7f\u6cdb\u5730\u91c7\u7528 LMS \u8ba4\u8bc1\u5960\u5b9a\u4e86\u57fa\u7840\u3002\u5b83\u901a\u8fc7\u63d0\u4f9b\u4e00\u79cd\u7ed3\u6784\u5316\u7684\u3001\u53ef\u5f62\u5f0f\u5316\u9a8c\u8bc1\u7684\u89c4\u683c\u8bed\u8a00\uff0c\u89e3\u51b3\u4e86\u73b0\u6709 LMS \u8ba4\u8bc1\u5728\u51c6\u786e\u6027\u548c\u53ef\u6269\u5c55\u6027\u65b9\u9762\u7684\u4e0d\u8db3\u3002"}}
{"id": "2512.02884", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.02884", "abs": "https://arxiv.org/abs/2512.02884", "authors": ["Cristian Tirelli", "Laura Pozzi"], "title": "Mapping code on Coarse Grained Reconfigurable Arrays using a SAT solver", "comment": null, "summary": "Emerging low-powered architectures like Coarse-Grain Reconfigurable Arrays (CGRAs) are becoming more common. Often included as co-processors, they are used to accelerate compute-intensive workloads like loops. The speedup obtained is defined by the hardware design of the accelerator and by the quality of the compilation. State of the art (SoA) compilation techniques leverage modulo scheduling to minimize the Iteration Interval (II), exploit the architecture parallelism and, consequentially, reduce the execution time of the accelerated workload. In our work, we focus on improving the compilation process by finding the lowest II for any given topology, through a satisfiability (SAT) formulation of the mapping problem. We introduce a novel schedule, called Kernel Mobility Schedule, to encode all the possible mappings for a given Data Flow Graph (DFG) and for a given II. The schedule is used together with the CGRA architectural information to generate all the constraints necessary to find a valid mapping. Experimental results demonstrate that our method not only reduces compilation time on average but also achieves higher quality mappings compared to existing SoA techniques.", "AI": {"tldr": "\u672c\u6587\u6d89\u53ca\u5230\u7684\u9886\u57df\u5305\u62ec\uff1a**\u7f16\u8bd1\u5668**\uff08\u901a\u8fc7\u7814\u7a76\u7f16\u8bd1\u8fc7\u7a0b\u548c\u8c03\u5ea6\u6539\u8fdb\u52a0\u901f\u5668\u6027\u80fd\uff09\uff0c**\u56fe\u5904\u7406**\uff08Data Flow Graph DFG\u7684\u5e94\u7528\uff09\uff0c**HLS**\uff08CGRA\u4f5c\u4e3a\u4e00\u79cd\u52a0\u901f\u5668\u67b6\u6784\uff0c\u4e0eHLS\u76ee\u6807\u6709\u76f8\u4f3c\u6027\uff09\u3002\u592a\u957f\u4e0d\u770b\u7248\uff1a\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u57fa\u4e8eSAT\u516c\u5f0f\u5316\u7684CGRA\u6620\u5c04\u65b0\u65b9\u6cd5\uff0c\u5f15\u5165Kernel Mobility Schedule\u6765\u7f16\u7801\u6240\u6709\u53ef\u80fd\u7684\u6620\u5c04\u3002\u5b9e\u9a8c\u8bc1\u660e\uff0c\u8be5\u65b9\u6cd5\u5728\u964d\u4f4e\u7f16\u8bd1\u65f6\u95f4\u7684\u540c\u65f6\uff0c\u80fd\u4e3a\u8ba1\u7b97\u5bc6\u96c6\u578b\u5de5\u4f5c\u8d1f\u8f7d\u5b9e\u73b0\u66f4\u4f4e\u8fed\u4ee3\u95f4\u9694\uff08II\uff09\u548c\u66f4\u9ad8\u8d28\u91cf\u7684\u6620\u5c04\uff0c\u4ece\u800c\u6709\u6548\u63d0\u5347\u52a0\u901f\u5668\u6027\u80fd\u3002", "motivation": "CGRA\u4f5c\u4e3a\u534f\u5904\u7406\u5668\u5e38\u7528\u4e8e\u52a0\u901f\u5faa\u73af\u7b49\u8ba1\u7b97\u5bc6\u96c6\u578b\u5de5\u4f5c\u8d1f\u8f7d\u3002\u52a0\u901f\u6548\u679c\u53d6\u51b3\u4e8e\u786c\u4ef6\u8bbe\u8ba1\u548c\u7f16\u8bd1\u8d28\u91cf\uff0c\u5176\u4e2d\u6700\u65b0\u7684\u7f16\u8bd1\u6280\u672f\u5229\u7528\u6a21\u8c03\u5ea6\u6765\u6700\u5c0f\u5316\u8fed\u4ee3\u95f4\u9694\uff08II\uff09\uff0c\u4ee5\u5229\u7528\u67b6\u6784\u5e76\u884c\u6027\u5e76\u51cf\u5c11\u6267\u884c\u65f6\u95f4\u3002\u672c\u6587\u7684\u52a8\u529b\u5728\u4e8e\u901a\u8fc7\u4e3a\u4efb\u4f55\u7ed9\u5b9a\u7684\u62d3\u6251\u627e\u5230\u6700\u4f4e\u7684II\uff0c\u4ece\u800c\u6539\u8fdb\u7f16\u8bd1\u8fc7\u7a0b\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u5c06CGRA\u6620\u5c04\u95ee\u9898\u5efa\u6a21\u4e3a\u53ef\u6ee1\u8db3\u6027\uff08SAT\uff09\u95ee\u9898\u7684\u65b9\u6cd5\u3002\u5f15\u5165\u4e86\u4e00\u79cd\u65b0\u7684\u8c03\u5ea6\u673a\u5236\uff0c\u79f0\u4e3aKernel Mobility Schedule\uff0c\u7528\u4e8e\u5728\u7ed9\u5b9a\u7684\u6570\u636e\u6d41\u56fe\uff08DFG\uff09\u548c\u8fed\u4ee3\u95f4\u9694\uff08II\uff09\u4e0b\uff0c\u7f16\u7801\u6240\u6709\u53ef\u80fd\u7684\u6620\u5c04\u3002\u8fd9\u79cd\u8c03\u5ea6\u673a\u5236\u7ed3\u5408CGRA\u7684\u67b6\u6784\u4fe1\u606f\uff0c\u751f\u6210\u6240\u6709\u5fc5\u8981\u7684\u7ea6\u675f\u6761\u4ef6\uff0c\u4ee5\u5bfb\u627e\u6709\u6548\u7684\u6620\u5c04\u3002", "result": "\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u4e0e\u73b0\u6709\u7684\u6700\u5148\u8fdb\uff08SoA\uff09\u6280\u672f\u76f8\u6bd4\uff0c\u8be5\u65b9\u6cd5\u4e0d\u4ec5\u5e73\u5747\u51cf\u5c11\u4e86\u7f16\u8bd1\u65f6\u95f4\uff0c\u800c\u4e14\u83b7\u5f97\u4e86\u66f4\u9ad8\u8d28\u91cf\u7684\u6620\u5c04\uff08\u66f4\u4f4e\u7684II\uff09\u3002", "conclusion": "\u672c\u6587\u901a\u8fc7\u5c06CGRA\u7684\u6620\u5c04\u95ee\u9898\u5efa\u6a21\u4e3aSAT\u95ee\u9898\uff0c\u5e76\u5f15\u5165Kernel Mobility Schedule\u6765\u6355\u6349\u6240\u6709\u53ef\u80fd\u7684\u6620\u5c04\uff0c\u4ece\u800c\u6539\u8fdb\u4e86\u7f16\u8bd1\u8fc7\u7a0b\u3002\u5b9e\u9a8c\u7ed3\u679c\u8bc1\u660e\uff0c\u8be5\u65b9\u6cd5\u5728\u964d\u4f4e\u7f16\u8bd1\u65f6\u95f4\u7684\u540c\u65f6\uff0c\u8fd8\u80fd\u5f97\u5230\u6bd4\u73b0\u6709\u6280\u672f\u66f4\u9ad8\u8d28\u91cf\u7684\u6620\u5c04\uff0c\u5b9e\u73b0\u4e86\u66f4\u4f4e\u7684\u8fed\u4ee3\u95f4\u9694\uff08II\uff09\u3002"}}
{"id": "2512.02683", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.02683", "abs": "https://arxiv.org/abs/2512.02683", "authors": ["Luiz A. Rodrigues", "Elias P. Duarte", "Luciana Arantes"], "title": "Distributed and Autonomic Minimum Spanning Trees", "comment": "This preprint is an English translation and slightly extended version of the paper published in Portuguese at the 32nd Brazilian Symposium on Computer Networks and Distributed Systems (2014), reference [1]", "summary": "The most common strategy for enabling a process in a distributed system to broadcast a message is one-to-all communication. However, this approach is not scalable, as it places a heavy load on the sender. This work presents an autonomic algorithm that enables the $n$ processes in a distributed system to build and maintain a spanning tree connecting themselves. In this context, processes are the vertices of the spanning tree. By definition, a spanning tree connects all processes without forming cycles. The proposed algorithm ensures that every vertex in the spanning tree has both an in-degree and the tree depth of at most $log_2 n$. When all processes are correct, the degree of each process is exactly $log_2 n$. A spanning tree is dynamically created from any source process and is transparently reconstructed as processes fail or recover. Up to $n-1$ processes can fail, and the correct processes remain connected through a scalable, functioning spanning tree. To build and maintain the tree, processes use the VCube virtual topology, which also serves as a failure detector. Two broadcast algorithms based on the autonomic spanning tree algorithm are presented: one for best-effort broadcast and one for reliable broadcast. Simulation results are provided, including comparisons with other alternatives.", "AI": {"tldr": "\u90e8\u5206\u6d89\u53ca\u56fe\u5904\u7406\uff08\u6700\u5c0f\u751f\u6210\u6811\uff09\u3002\n\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u81ea\u4e3b\u7b97\u6cd5\uff0c\u7528\u4e8e\u5728\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u6784\u5efa\u548c\u7ef4\u62a4\u4e00\u4e2a\u53ef\u6269\u5c55\u7684\u3001\u5bb9\u9519\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u4ee5\u89e3\u51b3\u4f20\u7edf\u201c\u4e00\u5bf9\u591a\u201d\u5e7f\u64ad\u5e26\u6765\u7684\u53ef\u6269\u5c55\u6027\u95ee\u9898\u548c\u91cd\u8d1f\u8377\u3002\u8be5\u7b97\u6cd5\u5229\u7528 VCube \u865a\u62df\u62d3\u6251\u4f5c\u4e3a\u6545\u969c\u68c0\u6d4b\u5668\uff0c\u4fdd\u8bc1\u4e86\u751f\u6210\u6811\u4e0a\u6bcf\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u53ca\u6811\u6df1\u5ea6\u5747\u4e0d\u5927\u4e8e $log_2 n$\u3002\u8be5\u7b97\u6cd5\u5177\u6709\u52a8\u6001\u521b\u5efa\u548c\u900f\u660e\u91cd\u5efa\u7684\u80fd\u529b\uff0c\u57fa\u4e8e\u6b64\u7b97\u6cd5\u8fd8\u63d0\u51fa\u4e86\u5c3d\u529b\u800c\u4e3a\u5e7f\u64ad\u548c\u53ef\u9760\u5e7f\u64ad\u4e24\u79cd\u65b0\u7684\u5e7f\u64ad\u7b97\u6cd5\uff0c\u5e76\u901a\u8fc7\u4eff\u771f\u9a8c\u8bc1\u4e86\u5176\u6709\u6548\u6027\u3002", "motivation": "\u5728\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\uff0c\u4f20\u7edf\u7684\u201c\u4e00\u5bf9\u591a\u201d\u5e7f\u64ad\u901a\u4fe1\u7b56\u7565\u53ef\u6269\u5c55\u6027\u5dee\uff0c\u4f1a\u5bf9\u53d1\u9001\u65b9\u9020\u6210\u6c89\u91cd\u8d1f\u62c5\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u66f4\u5177\u53ef\u6269\u5c55\u6027\u7684\u65b9\u6cd5\u6765\u5728\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u5b9e\u73b0\u9ad8\u6548\u7684\u6d88\u606f\u5e7f\u64ad\u3002\u672c\u6587\u7684\u52a8\u673a\u662f\u63d0\u51fa\u4e00\u79cd\u80fd\u81ea\u4e3b\u6784\u5efa\u548c\u7ef4\u62a4\u4e00\u4e2a\u53ef\u6269\u5c55\u7684\u6700\u5c0f\u751f\u6210\u6811\u7684\u7b97\u6cd5\u6765\u89e3\u51b3\u8fd9\u4e00\u95ee\u9898\u3002", "method": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u81ea\u4e3b\u7b97\u6cd5\uff0c\u7528\u4e8e\u6784\u5efa\u548c\u7ef4\u62a4\u4e00\u4e2a\u8fde\u63a5\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d $n$ \u4e2a\u8fdb\u7a0b\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002\u8be5\u7b97\u6cd5\u57fa\u4e8e VCube \u865a\u62df\u62d3\u6251\uff0c\u5229\u7528 VCube \u4f5c\u4e3a\u6545\u969c\u68c0\u6d4b\u5668\u6765\u6784\u5efa\u548c\u7ef4\u62a4\u6811\u3002\u7b97\u6cd5\u4fdd\u8bc1\u4e86\u751f\u6210\u6811\u4e2d\u6bcf\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u4ee5\u53ca\u6811\u7684\u6df1\u5ea6\u5747\u4e0d\u5927\u4e8e $log_2 n$\u3002\u57fa\u4e8e\u6b64\u7b97\u6cd5\uff0c\u4f5c\u8005\u8fd8\u63d0\u51fa\u4e86\u4e24\u79cd\u5e7f\u64ad\u7b97\u6cd5\uff0c\u5206\u522b\u7528\u4e8e\u5c3d\u529b\u800c\u4e3a\u5e7f\u64ad\u548c\u53ef\u9760\u5e7f\u64ad\u3002\u901a\u8fc7\u4eff\u771f\u5b9e\u9a8c\u5bf9\u7b97\u6cd5\u8fdb\u884c\u4e86\u9a8c\u8bc1\uff0c\u5e76\u4e0e\u5176\u4ed6\u66ff\u4ee3\u65b9\u6848\u8fdb\u884c\u4e86\u6bd4\u8f83\u3002", "result": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u81ea\u4e3b\u7b97\u6cd5\uff0c\u80fd\u591f\u6784\u5efa\u4e00\u4e2a\u5177\u6709\u826f\u597d\u53ef\u6269\u5c55\u6027\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5e76\u4fdd\u8bc1\u6811\u4e2d\u6bcf\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u53ca\u6811\u6df1\u5ea6\u4e0d\u5927\u4e8e $log_2 n$\u3002\u6240\u6709\u8fdb\u7a0b\u6b63\u786e\u65f6\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u7684\u5ea6\u6070\u597d\u662f $log_2 n$\u3002\u8be5\u751f\u6210\u6811\u53ef\u4ee5\u4ece\u4efb\u4e00\u6e90\u8fdb\u7a0b\u52a8\u6001\u521b\u5efa\uff0c\u5e76\u5728\u8fdb\u7a0b\u5931\u8d25\u6216\u6062\u590d\u65f6\u900f\u660e\u91cd\u5efa\uff0c\u5177\u6709\u5f88\u5f3a\u7684\u5bb9\u9519\u80fd\u529b\u3002\u57fa\u4e8e\u6b64\u751f\u6210\u6811\uff0c\u63d0\u51fa\u4e86\u5c3d\u529b\u800c\u4e3a\u5e7f\u64ad\u548c\u53ef\u9760\u5e7f\u64ad\u4e24\u79cd\u7b97\u6cd5\u3002\u4eff\u771f\u7ed3\u679c\u8bc1\u660e\u4e86\u6240\u63d0\u51fa\u7b97\u6cd5\u7684\u6709\u6548\u6027\uff0c\u5e76\u4e0e\u5176\u4ed6\u66ff\u4ee3\u65b9\u6848\u8fdb\u884c\u4e86\u6bd4\u8f83\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u80fd\u591f\u81ea\u4e3b\u6784\u5efa\u548c\u7ef4\u62a4\u4e00\u4e2a\u5206\u5e03\u5f0f\u7cfb\u7edf\u4e2d\u6240\u6709\u8fdb\u7a0b\u4e4b\u95f4\u8fde\u63a5\u7684\u3001\u5177\u6709\u53ef\u6269\u5c55\u6027\u7684\u6700\u5c0f\u751f\u6210\u6811\u7684\u7b97\u6cd5\u3002\u8be5\u7b97\u6cd5\u786e\u4fdd\u4e86\u751f\u6210\u6811\u4e0a\u6bcf\u4e2a\u9876\u70b9\u7684\u5165\u5ea6\u53ca\u6811\u7684\u6df1\u5ea6\u5747\u4e0d\u8d85\u81ea\u8fc7 $log_2 n$\uff0c\u5f53\u6240\u6709\u8fdb\u7a0b\u6b63\u786e\u65f6\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u7684\u5ea6\u6070\u597d\u4e3a $log_2 n$\u3002\u8be5\u7b97\u6cd5\u5177\u6709\u5bb9\u9519\u6027\uff0c\u53ef\u4ee5\u5728\u8fdb\u7a0b\u5931\u8d25\u6216\u6062\u590d\u65f6\u8fdb\u884c\u900f\u660e\u91cd\u5efa\uff0c\u4e14\u81f3\u591a $n-1$ \u4e2a\u8fdb\u7a0b\u5931\u8d25\u65f6\u4ecd\u80fd\u4fdd\u6301\u6b63\u786e\u8fdb\u7a0b\u4e4b\u95f4\u7684\u8fde\u901a\u3002\u57fa\u4e8e\u6b64\u7b97\u6cd5\uff0c\u4f5c\u8005\u8fd8\u63d0\u51fa\u4e86\u4e24\u79cd\u5e7f\u64ad\u7b97\u6cd5\uff0c\u5206\u522b\u7528\u4e8e\u5c3d\u529b\u800c\u4e3a\u5e7f\u64ad\u548c\u53ef\u9760\u5e7f\u64ad\u3002"}}
{"id": "2512.02818", "categories": ["cs.DC", "cs.DL"], "pdf": "https://arxiv.org/pdf/2512.02818", "abs": "https://arxiv.org/abs/2512.02818", "authors": ["Sean R. Wilkinson", "Patrick Widener", "Sarp Oral", "Rafael Ferreira da Silva"], "title": "Designing FAIR Workflows at OLCF: Building Scalable and Reusable Ecosystems for HPC Science", "comment": null, "summary": "High Performance Computing (HPC) centers provide advanced infrastructure that enables scientific research at extreme scale. These centers operate with hardware configurations, software environments, and security requirements that differ substantially from most users' local systems. As a result, users often develop customized digital artifacts that are tightly coupled to a given HPC center. This practice can lead to significant duplication of effort as multiple users independently create similar solutions to common problems. The FAIR Principles offer a framework to address these challenges. Initially designed to improve data stewardship, the FAIR approach has since been extended to encompass software, workflows, models, and infrastructure. By encouraging the use of rich metadata and community standards, FAIR practices aim to make digital artifacts easier to share and reuse, both within and across scientific domains. Many FAIR initiatives have emerged within individual research communities, often aligned by discipline (e.g. bioinformatics, earth sciences). These communities have made progress in adopting FAIR practices, but their domain-specific nature can lead to silos that limit broader collaboration. Thus, we propose that HPC centers play a more active role in fostering FAIR ecosystems that support research across multiple disciplines. This requires designing infrastructure that enables researchers to discover, share, and reuse computational components more effectively. Here, we build on the architecture of the European Open Science Cloud (EOSC) EOSC-Life FAIR Workflows Collaboratory to propose a model tailored to the needs of HPC. Rather than focusing on entire workflows, we emphasize the importance of making individual workflow components FAIR. This component-based approach better supports the diverse and evolving needs of HPC users while maximizing the long-term value of their work.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e DSL\u3001\u56fe\u5904\u7406\u3001MLIR\u3001\u7f16\u8bd1\u5668\u6216 HLS **\u65e0\u5173**\u3002\n\u672c\u6458\u8981\u8ba8\u8bba\u4e86\u9ad8\u6027\u80fd\u8ba1\u7b97\uff08HPC\uff09\u4e2d\u5fc3\u5728\u63d0\u5347\u79d1\u5b66\u7814\u7a76\u6570\u5b57\u5de5\u4ef6\uff08\u5982\u8f6f\u4ef6\u548c\u5de5\u4f5c\u6d41\uff09\u5171\u4eab\u548c\u91cd\u7528\u65b9\u9762\u7684\u6311\u6218\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u5de5\u4ef6\u5f80\u5f80\u4e0e\u7279\u5b9a\u4e2d\u5fc3\u7684\u73af\u5883\u7d27\u5bc6\u8026\u5408\uff0c\u5bfc\u81f4\u91cd\u590d\u5de5\u4f5c\u3002\u4e3a\u89e3\u51b3\u6b64\u95ee\u9898\uff0c\u4f5c\u8005\u4eec\u63d0\u5021 HPC \u4e2d\u5fc3\u5e94\u501f\u9274 FAIR \u539f\u5219\uff0c\u7279\u522b\u662f\u57fa\u4e8e EOSC-Life FAIR Workflows Collaboratory \u67b6\u6784\uff0c\u5e76\u63d0\u51fa\u4e00\u4e2a\u5b9a\u5236\u5316\u7684\u6a21\u578b\uff1a\u5f3a\u8c03\u4f7f**\u5355\u4e2a\u5de5\u4f5c\u6d41\u7ec4\u4ef6**\u5b9e\u73b0 FAIR\uff0c\u800c\u975e\u5173\u6ce8\u6574\u4e2a\u5de5\u4f5c\u6d41\u3002\u8fd9\u4e00\u7ec4\u4ef6\u5316\u7684\u7b56\u7565\u65e8\u5728\u6784\u5efa\u4e00\u4e2a\u8de8\u5b66\u79d1\u7684 FAIR \u751f\u6001\u7cfb\u7edf\uff0c\u4ee5\u63d0\u5347\u8ba1\u7b97\u7ec4\u4ef6\u7684\u53d1\u73b0\u548c\u91cd\u7528\u6548\u7387\uff0c\u4ece\u800c\u6700\u5927\u5316\u79d1\u5b66\u7814\u7a76\u7684\u957f\u671f\u4ef7\u503c\u3002", "motivation": "\u9ad8\u6027\u80fd\u8ba1\u7b97\uff08HPC\uff09\u4e2d\u5fc3\u7684\u7528\u6237\u5f00\u53d1\u7684\u6570\u5b57\u5de5\u4ef6\uff08\u5982\u8f6f\u4ef6\u548c\u5de5\u4f5c\u6d41\uff09\u901a\u5e38\u4e0e\u7279\u5b9a\u7684\u786c\u4ef6\u3001\u8f6f\u4ef6\u73af\u5883\u548c\u5b89\u5168\u8981\u6c42\u7d27\u5bc6\u8026\u5408\uff0c\u5bfc\u81f4\u8fd9\u4e9b\u5de5\u4ef6\u96be\u4ee5\u5728\u4e0d\u540c\u7528\u6237\u548c\u4e0d\u540c\u4e2d\u5fc3\u4e4b\u95f4\u5171\u4eab\u548c\u91cd\u7528\u3002\u8fd9\u79cd\u201c\u7d27\u8026\u5408\u201d\u7684\u505a\u6cd5\u5bfc\u81f4\u4e86\u5927\u91cf\u91cd\u590d\u6027\u5de5\u4f5c\uff0c\u56e0\u4e3a\u8bb8\u591a\u7528\u6237\u9700\u8981\u72ec\u7acb\u5730\u4e3a\u5e38\u89c1\u95ee\u9898\u521b\u5efa\u7c7b\u4f3c\u7684\u89e3\u51b3\u65b9\u6848\u3002\u73b0\u6709\u7684 FAIR\uff08Findable, Accessible, Interoperable, Reusable\uff09\u5021\u8bae\u867d\u6709\u8fdb\u5c55\uff0c\u4f46\u591a\u5c40\u9650\u4e8e\u7279\u5b9a\u7684\u7814\u7a76\u793e\u533a\u548c\u5b66\u79d1\u9886\u57df\uff0c\u5f62\u6210\u4e86\u201c\u4fe1\u606f\u5b64\u5c9b\u201d\uff0c\u9650\u5236\u4e86\u8de8\u9886\u57df\u7684\u5408\u4f5c\u3002\u56e0\u6b64\uff0c**\u9700\u8981**\u66f4\u7edf\u4e00\u548c\u7cfb\u7edf\u5316\u7684\u65b9\u6848\u6765\u89e3\u51b3 HPC \u73af\u5883\u4e2d\u7684\u5171\u4eab\u548c\u91cd\u7528\u6311\u6218\uff0c\u4ee5\u6700\u5927\u5316\u79d1\u5b66\u7814\u7a76\u7684\u6548\u7387\u548c\u957f\u671f\u4ef7\u503c\u3002", "method": "\u672c\u6587\u901a\u8fc7\u63d0\u51fa\u4e00\u4e2a\u201c\u91cf\u8eab\u5b9a\u5236\u201d\u7684\u6a21\u578b\u6765\u89e3\u51b3 HPC \u9886\u57df\u4e2d\u6570\u5b57\u5de5\u4ef6\u5171\u4eab\u548c\u91cd\u7528\u56f0\u96be\u7684\u95ee\u9898\u3002\u8be5\u65b9\u6cd5\u7684\u6838\u5fc3\u662f\uff1a1. **\u501f\u9274**\u6b27\u6d32\u5f00\u653e\u79d1\u5b66\u4e91\uff08EOSC\uff09\u4e2d EOSC-Life FAIR Workflows Collaboratory \u7684\u67b6\u6784\u7ecf\u9a8c\u30022. **\u8c03\u6574**\u8be5\u67b6\u6784\u4ee5\u9002\u5e94 HPC \u7684\u5177\u4f53\u9700\u6c42\u30023. **\u91cd\u70b9**\u662f\u5efa\u7acb\u4e00\u4e2a\u5f3a\u8c03\u4f7f**\u5355\u4e2a\u5de5\u4f5c\u6d41\u7ec4\u4ef6\uff08individual workflow components\uff09**\u5b9e\u73b0 FAIR\uff08\u53ef\u53d1\u73b0\u3001\u53ef\u8bbf\u95ee\u3001\u53ef\u4e92\u64cd\u4f5c\u3001\u53ef\u91cd\u7528\uff09\u7684\u57fa\u7840\u8bbe\u65bd\uff0c\u800c\u975e\u5173\u6ce8\u6574\u4e2a\u5de5\u4f5c\u6d41\uff0c\u4ee5\u66f4\u597d\u5730\u652f\u6301 HPC \u7528\u6237\u591a\u6837\u5316\u7684\u9700\u6c42\u5e76\u63d0\u5347\u5176\u6570\u5b57\u9057\u4ea7\u7684\u957f\u671f\u4ef7\u503c\u3002", "result": "\u672c\u6587\u63d0\u51fa\u7684\u6a21\u578b\u5f3a\u8c03\u4e86 HPC \u4e2d\u5fc3\u5e94\u901a\u8fc7\u8bbe\u8ba1\u76f8\u5e94\u7684\u57fa\u7840\u8bbe\u65bd\uff0c\u79ef\u6781\u5730\u4fc3\u8fdb\u4e00\u4e2a\u80fd\u591f\u8de8\u591a\u4e2a\u5b66\u79d1\u652f\u6301\u7814\u7a76\u7684 FAIR \u751f\u6001\u7cfb\u7edf\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u901a\u8fc7\u91c7\u7528**\u57fa\u4e8e\u7ec4\u4ef6**\u7684\u65b9\u6cd5\uff0c\u5373\u91cd\u70b9\u5173\u6ce8\u5982\u4f55\u4f7f**\u5355\u4e2a\u5de5\u4f5c\u6d41\u7ec4\u4ef6**\u5b9e\u73b0 FAIR\uff08\u901a\u8fc7\u4f7f\u7528\u4e30\u5bcc\u7684\u5143\u6570\u636e\u548c\u793e\u533a\u6807\u51c6\uff09\uff0c\u53ef\u4ee5\u6709\u6548\u5730\u63d0\u5347\u8ba1\u7b97\u7ec4\u4ef6\u7684\u53d1\u73b0\u3001\u5171\u4eab\u548c\u91cd\u7528\u80fd\u529b\u3002\u8fd9\u88ab\u8ba4\u4e3a\u662f\u4e00\u79cd\u6bd4\u5173\u6ce8\u6574\u4e2a\u5de5\u4f5c\u6d41\u66f4\u9002\u5e94 HPC \u7528\u6237\u591a\u6837\u5316\u548c\u6f14\u8fdb\u9700\u6c42\u7684\u6709\u6548\u65b9\u6cd5\uff0c\u4ece\u800c\u6700\u5927\u5316\u7528\u6237\u5de5\u4f5c\u7684\u957f\u671f\u79d1\u5b66\u4ef7\u503c\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\uff0c\u9ad8\u6027\u80fd\u8ba1\u7b97\uff08HPC\uff09\u4e2d\u5fc3\u5e94\u5728\u63a8\u52a8\u8de8\u5b66\u79d1\u7684 FAIR \u751f\u6001\u7cfb\u7edf\u65b9\u9762\u53d1\u6325\u66f4\u79ef\u6781\u7684\u4f5c\u7528\u3002\u901a\u8fc7\u501f\u9274 EOSC-Life \u7684\u7ecf\u9a8c\uff0c\u4f5c\u8005\u4eec\u63d0\u51fa\u4e86\u4e00\u4e2a\u9488\u5bf9 HPC \u9700\u6c42\u5b9a\u5236\u7684\u6a21\u578b\uff0c\u8be5\u6a21\u578b\u7279\u522b\u5f3a\u8c03\u4e86\u4f7f**\u5355\u4e2a\u5de5\u4f5c\u6d41\u7ec4\u4ef6**\u5b9e\u73b0 FAIR \u7684\u91cd\u8981\u6027\u3002\u8fd9\u79cd\u57fa\u4e8e\u7ec4\u4ef6\u7684\u65b9\u6cd5\u65e8\u5728\u66f4\u597d\u5730\u652f\u6301 HPC \u7528\u6237\u591a\u6837\u5316\u548c\u4e0d\u65ad\u53d8\u5316\u7684\u9700\u6c42\uff0c\u540c\u65f6\u6700\u5927\u5316\u5176\u5de5\u4f5c\u7684\u957f\u671f\u4ef7\u503c\u3002\u5176\u6700\u7ec8\u76ee\u6807\u662f\u4f7f HPC \u7814\u53d1\u6210\u679c\u66f4\u6613\u4e8e\u53d1\u73b0\u3001\u5171\u4eab\u548c\u91cd\u7528\uff0c\u4ece\u800c\u51cf\u5c11\u91cd\u590d\u6027\u5de5\u4f5c\u5e76\u4fc3\u8fdb\u66f4\u5e7f\u6cdb\u7684\u79d1\u5b66\u5408\u4f5c\u3002"}}
