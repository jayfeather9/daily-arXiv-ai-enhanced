{"id": "2512.15981", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.15981", "abs": "https://arxiv.org/abs/2512.15981", "authors": ["Bardiya Aryanfard", "Monika Henzinger", "David Saulpic", "A. R. Sricharan"], "title": "Improved Lower Bounds for Privacy under Continual Release", "comment": null, "summary": "We study the problem of continually releasing statistics of an evolving dataset under differential privacy. In the event-level setting, we show the first polynomial lower bounds on the additive error for insertions-only graph problems such as maximum matching, degree histogram and $k$-core. This is an exponential improvement on the polylogarithmic lower bounds of Fichtenberger et al.[ESA 2021] for the former two problems, and are the first continual release lower bounds for the latter. Our results run counter to the intuition that the difference between insertions-only vs fully dynamic updates causes the gap between polylogarithmic and polynomial additive error. We show that for maximum matching and $k$-core, allowing small multiplicative approximations is what brings the additive error down to polylogarithmic.\n  Beyond graph problems, our techniques also show that polynomial additive error is unavoidable for Simultaneous Norm Estimation in the insertions-only setting. When multiplicative approximations are allowed, we circumvent this lower bound by giving the first continual mechanism with polylogarithmic additive error under $(1+ζ)$ multiplicative approximations, for $ζ>0$, for estimating all monotone symmetric norms simultaneously.\n  In the item-level setting, we show polynomial lower bounds on the product of the multiplicative and the additive error of continual mechanisms for a large range of graph problems. To the best of our knowledge, these are the first lower bounds for any differentially private continual release mechanism with multiplicative error. To obtain this, we prove a new lower bound on the product of multiplicative and additive error for 1-Way-Marginals, from which we reduce to continual graph problems. This generalizes the lower bounds of Hardt and Talwar[STOC 2010] and Bun et al.[STOC 2014] on the additive error for mechanisms with no multiplicative error."}
{"id": "2512.16087", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.16087", "abs": "https://arxiv.org/abs/2512.16087", "authors": ["Mikkel Thorup", "Hanzhi Wang"], "title": "Instance Optimality in PageRank Centrality Estimation", "comment": null, "summary": "We study an adaptive variant of a simple, classic algorithm for estimating a vertex's PageRank centrality within a constant relative error, with constant probability. We show that this algorithm is instance-optimal up to a polylogarithmic factor for any directed graph of order $n$ whose maximal in- and out-degrees are at most a constant fraction of $n$. The instance-optimality also extends to graphs in which up to a polylogarithmic number of vertices have unbounded degree, thereby covering all sparse graphs with $\\widetilde{O}(n)$ edges. Finally, we provide a counterexample showing that the algorithm is not instance-optimal for graphs with degrees mostly equal to $n$."}
{"id": "2512.16414", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.16414", "abs": "https://arxiv.org/abs/2512.16414", "authors": ["Jannes Malanowski"], "title": "Conquering the Multiverse: The River Voting Method with Efficient Parallel Universe Tiebreaking", "comment": "This is my Bachelor's Thesis. Based on this thesis we published arXiv:2512.14409", "summary": "Democracy relies on making collective decisions through voting. In addition, voting procedures have further applications, for example in the training of artificial intelligence. An essential criterion for determining the winner of a fair election is that all alternatives are treated equally: this is called neutrality. The established Ranked Pairs voting method cannot simultaneously guarantee neutrality and be computationally tractable for election with ties. River, the recently introduced voting method, shares desirable properties with Ranked Pairs and has further advantages, such as a new property related to resistance against manipulation. Both Ranked Pairs and River use a weighted margin graph to model the election. Ties in the election can lead to edges of equal margin. To order the edges in such a case, a tiebreaking scheme must be employed. Many tiebreaks violate neutrality or other important properties. A tiebreaking scheme that preserves neutrality is Parallel Universe Tiebreaking (PUT). Ranked Pairs with PUT is NP-hard to compute.\n  The main result of this thesis shows that River with PUT can be computed in polynomial worst-case runtime: We can check whether an alternative is a River PUT winner, by running River with a specially constructed ordering of the edges. To construct this ordering, we introduce the semi-River diagram which contains the edges that can appear in any River diagram for some arbitrary tiebreak. On this diagram we can compute the River winners, by applying a variant of Prims algorithm per alternative. Additionally, we give an algorithm improve the previous naive runtime of River from $\\mathcal{O}(n^4)$ to $\\mathcal{O}(n^2 \\log n)$, where n is the number of alternatives."}
{"id": "2512.16639", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.16639", "abs": "https://arxiv.org/abs/2512.16639", "authors": ["Gramoz Goranci", "Shaofeng Jiang", "Peter Kiss", "Eva Szilagyi", "Qiaoyuan Yang"], "title": "Fully Dynamic Algorithms for Chamfer Distance", "comment": "NeurIPS 2025", "summary": "We study the problem of computing Chamfer distance in the fully dynamic setting, where two set of points $A, B \\subset \\mathbb{R}^{d}$, each of size up to $n$, dynamically evolve through point insertions or deletions and the goal is to efficiently maintain an approximation to $\\mathrm{dist}_{\\mathrm{CH}}(A,B) = \\sum_{a \\in A} \\min_{b \\in B} \\textrm{dist}(a,b)$, where $\\textrm{dist}$ is a distance measure. Chamfer distance is a widely used dissimilarity metric for point clouds, with many practical applications that require repeated evaluation on dynamically changing datasets, e.g., when used as a loss function in machine learning. In this paper, we present the first dynamic algorithm for maintaining an approximation of the Chamfer distance under the $\\ell_p$ norm for $p \\in \\{1,2 \\}$. Our algorithm reduces to approximate nearest neighbor (ANN) search with little overhead. Plugging in standard ANN bounds, we obtain $(1+ε)$-approximation in $\\tilde{O}(ε^{-d})$ update time and $O(1/ε)$-approximation in $\\tilde{O}(d n^{ε^2} ε^{-4})$ update time. We evaluate our method on real-world datasets and demonstrate that it performs competitively against natural baselines."}
{"id": "2512.15827", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.15827", "abs": "https://arxiv.org/abs/2512.15827", "authors": ["FNU Vikas", "Paul Gratz", "Daniel Jiménez"], "title": "Workload Characterization for Branch Predictability", "comment": "This manuscript is an archival version of work conducted as part of the author's 2020 Master's at Texas A\\&M University under the supervision of Professors Paul Gratz and Daniel A.~Jiménez. No part of this work was conducted at, funded by, or related to the author's current employer", "summary": "Conditional branch prediction predicts the likely direction of a conditional branch instruction to support ILP extraction. Branch prediction is a pattern recognition problem that learns mappings between a context to the branch outcome. An accurate predictor reduces the number of instructions executed on the wrong path resulting in an improvement of performance and energy consumption. In this paper, we present a workload characterization methodology for branch prediction. We propose two new workload-driven branch prediction accuracy identifiers -- branch working set size and branch predictability. These parameters are highly correlated with misprediction rates of modern branch prediction schemes (e.g. TAGE and perceptron). We define the branch working set of a trace as a group of most frequently occurring branch contexts, i.e. the 3-part tuple of branch address, and associated global and local history. We analyze the branch working set's size and predictability on a per-trace basis to study its relationship with a modern branch predictor's accuracy. We have characterized 2,451 workload traces into seven branch working set size and nine predictability categories after analyzing their branch behavior. We present further insights into the source of prediction accuracy and favored workload categories for modern branch predictors."}
{"id": "2512.16038", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16038", "abs": "https://arxiv.org/abs/2512.16038", "authors": ["Eric Simon", "Renato B. Hoffmann", "Lucas Alf", "Dalvan Griebler"], "title": "LOG.io: Unified Rollback Recovery and Data Lineage Capture for Distributed Data Pipelines", "comment": null, "summary": "This paper introduces LOG.io, a comprehensive solution designed for correct rollback recovery and fine-grain data lineage capture in distributed data pipelines. It is tailored for serverless scalable architectures and uses a log-based rollback recovery protocol. LOG.io supports a general programming model, accommodating non-deterministic operators, interactions with external systems, and arbitrary custom code. It is non-blocking, allowing failed operators to recover independently without interrupting other active operators, thereby leveraging data parallelization, and it facilitates dynamic scaling of operators during pipeline execution. Performance evaluations, conducted within the SAP Data Intelligence system, compare LOG.io with the Asynchronous Barrier Snapshotting (ABS) protocol, originally implemented in Flink. Our experiments show that when there are straggler operators in a data pipeline and the throughput of events is moderate (e.g., 1 event every 100 ms), LOG.io performs as well as ABS during normal processing and outperforms ABS during recovery. Otherwise, ABS performs better than LOG.io for both normal processing and recovery. However, we show that in these cases, data parallelization can largely reduce the overhead of LOG.io while ABS does not improve. Finally, we show that the overhead of data lineage capture, at the granularity of the event and between any two operators in a pipeline, is marginal, with less than 1.5% in all our experiments."}
{"id": "2512.15766", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2512.15766", "abs": "https://arxiv.org/abs/2512.15766", "authors": ["Yijie Zhi", "Yayu Cao", "Jianhua Dai", "Xiaoyang Han", "Jingwen Pu", "Qingran Wu", "Sheng Cheng", "Ming Cai"], "title": "LOOPRAG: Enhancing Loop Transformation Optimization with Retrieval-Augmented Large Language Models", "comment": "Accepted to ASPLOS 2026", "summary": "Loop transformations are semantics-preserving optimization techniques, widely used to maximize objectives such as parallelism. Despite decades of research, applying the optimal composition of loop transformations remains challenging due to inherent complexities, including cost modeling for optimization objectives. Recent studies have explored the potential of Large Language Models (LLMs) for code optimization. However, our key observation is that LLMs often struggle with effective loop transformation optimization, frequently leading to errors or suboptimal optimization, thereby missing opportunities for performance improvements. To bridge this gap, we propose LOOPRAG, a novel retrieval-augmented generation framework designed to guide LLMs in performing effective loop optimization on Static Control Part. We introduce a parameter-driven method to harness loop properties, which trigger various loop transformations, and generate diverse yet legal example codes serving as a demonstration source. To effectively obtain the most informative demonstrations, we propose a loop-aware algorithm based on loop features, which balances similarity and diversity for code retrieval. To enhance correct and efficient code generation, we introduce a feedback-based iterative mechanism that incorporates compilation, testing and performance results as feedback to guide LLMs. Each optimized code undergoes mutation, coverage and differential testing for equivalence checking. We evaluate LOOPRAG on PolyBench, TSVC and LORE benchmark suites, and compare it against compilers (GCC-Graphite, Clang-Polly, Perspective and ICX) and representative LLMs (DeepSeek and GPT-4). The results demonstrate average speedups over base compilers of up to 11.20$\\times$, 14.34$\\times$, and 9.29$\\times$ for PolyBench, TSVC, and LORE, respectively, and speedups over base LLMs of up to 11.97$\\times$, 5.61$\\times$, and 11.59$\\times$."}
{"id": "2512.16875", "categories": ["cs.DS", "cs.LG", "math.ST", "stat.ML"], "pdf": "https://arxiv.org/pdf/2512.16875", "abs": "https://arxiv.org/abs/2512.16875", "authors": ["Chao Gao", "Liren Shan", "Vaidehi Srinivas", "Aravindan Vijayaraghavan"], "title": "Learning Confidence Ellipsoids and Applications to Robust Subspace Recovery", "comment": null, "summary": "We study the problem of finding confidence ellipsoids for an arbitrary distribution in high dimensions. Given samples from a distribution $D$ and a confidence parameter $α$, the goal is to find the smallest volume ellipsoid $E$ which has probability mass $\\Pr_{D}[E] \\ge 1-α$. Ellipsoids are a highly expressive class of confidence sets as they can capture correlations in the distribution, and can approximate any convex set. This problem has been studied in many different communities. In statistics, this is the classic minimum volume estimator introduced by Rousseeuw as a robust non-parametric estimator of location and scatter. However in high dimensions, it becomes NP-hard to obtain any non-trivial approximation factor in volume when the condition number $β$ of the ellipsoid (ratio of the largest to the smallest axis length) goes to $\\infty$. This motivates the focus of our paper: can we efficiently find confidence ellipsoids with volume approximation guarantees when compared to ellipsoids of bounded condition number $β$?\n  Our main result is a polynomial time algorithm that finds an ellipsoid $E$ whose volume is within a $O(β^{γd})$ multiplicative factor of the volume of best $β$-conditioned ellipsoid while covering at least $1-O(α/γ)$ probability mass for any $γ< α$. We complement this with a computational hardness result that shows that such a dependence seems necessary up to constants in the exponent. The algorithm and analysis uses the rich primal-dual structure of the minimum volume enclosing ellipsoid and the geometric Brascamp-Lieb inequality. As a consequence, we obtain the first polynomial time algorithm with approximation guarantees on worst-case instances of the robust subspace recovery problem."}
{"id": "2512.16045", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.16045", "abs": "https://arxiv.org/abs/2512.16045", "authors": ["Vincent T. Lee", "Tanfer Alan", "Sung Kim", "Ecenur Ustun", "Amr Suleiman", "Ajit Krisshna", "Tim Balbekov", "Armin Alaghi", "Richard Newcombe"], "title": "Full System Architecture Modeling for Wearable Egocentric Contextual AI", "comment": "13 pages, 3 tables, 6 figures, technical report", "summary": "The next generation of human-oriented computing will require always-on, spatially-aware wearable devices to capture egocentric vision and functional primitives (e.g., Where am I? What am I looking at?, etc.). These devices will sense an egocentric view of the world around us to observe all human- relevant signals across space and time to construct and maintain a user's personal context. This personal context, combined with advanced generative AI, will unlock a powerful new generation of contextual AI personal assistants and applications. However, designing a wearable system to support contextual AI is a daunting task because of the system's complexity and stringent power constraints due to weight and battery restrictions. To understand how to guide design for such systems, this work provides the first complete system architecture view of one such wearable contextual AI system (Aria2), along with the lessons we have learned through the system modeling and design space exploration process. We show that an end-to-end full system model view of such systems is vitally important, as no single component or category overwhelmingly dominates system power. This means long-range design decisions and power optimizations need to be made in the full system context to avoid running into limits caused by other system bottlenecks (i.e., Amdahl's law as applied to power) or as bottlenecks change. Finally, we reflect on lessons and insights for the road ahead, which will be important toward eventually enabling all-day, wearable, contextual AI systems."}
{"id": "2512.16056", "categories": ["cs.DC", "cs.NI", "cs.PF"], "pdf": "https://arxiv.org/pdf/2512.16056", "abs": "https://arxiv.org/abs/2512.16056", "authors": ["Lingfeng Tang", "Daoping Zhang", "Junjie Chen", "Peihao Huang", "Feng Jin", "Chengguang Xu", "Yuxin Chen", "Feiqiang Sun", "Guo Chen"], "title": "MultiPath Transfer Engine: Breaking GPU and Host-Memory Bandwidth Bottlenecks in LLM Services", "comment": null, "summary": "The limited bandwidth of PCIe has emerged as the critical bottleneck for large language model (LLM) performance, such as prefix cache fetching and model switching. Although intra-server multipath data transfer between GPU and host memory is theoretically possible, heterogeneous protocols such as PCIe and NVLink currently limit the bandwidth between host memory and GPUs to that of a single PICe link. This limitation resuals in underutilized intra-server bandwidth. To address this issue, we propose Multipath Memory Access (MMA), a scheme that, to the best of our knowledge, is the first to enalbe efficient multipath data transfer between GPU and host memory. MMA supports seamless deployment via dynamic library injection, enabling LLM applications to benefit from MMA without requiring any code modification. In our testbed, MMA significantly improves the data transfer bandwidth between the GPU and memory, achieving a peak bandwidth of 245 GB/s-representing a 4.62x speedup compared to the natice single-path bandwidth. End-to-end evaluations demonstrate that MMA reduces the time-to-first-token (TTFT) for LLM serving by 1.14x to 2.38x and decreases model-switching latency in vLLM's sleep mode by 1.12x to 2.48x."}
{"id": "2512.15788", "categories": ["cs.PL", "cs.FL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2512.15788", "abs": "https://arxiv.org/abs/2512.15788", "authors": ["Anastasia Mavridou", "Marie Farrell", "Gricel Vázquez", "Tom Pressburger", "Timothy E. Wang", "Radu Calinescu", "Michael Fisher"], "title": "Automated Formalization of Probabilistic Requirements from Structured Natural Language", "comment": "Official website https://github.com/NASA-SW-VnV/fret/releases/tag/v3.0.0", "summary": "Integrating autonomous and adaptive behavior into software-intensive systems presents significant challenges for software development, as uncertainties in the environment or decision-making processes must be explicitly captured. These challenges are amplified in safety- and mission-critical systems, which must undergo rigorous scrutiny during design and development. Key among these challenges is the difficulty of specifying requirements that use probabilistic constructs to capture the uncertainty affecting these systems. To enable formal analysis, such requirements must be expressed in precise mathematical notations such as probabilistic logics. However, expecting developers to write requirements directly in complex formalisms is unrealistic and highly error-prone. We extend the structured natural language used by NASA's Formal Requirement Elicitation Tool (FRET) with support for the specification of unambiguous and correct probabilistic requirements, and develop an automated approach for translating these requirements into logical formulas. We propose and develop a formal, compositional, and automated approach for translating structured natural-language requirements into formulas in probabilistic temporal logic. To increase trust in our formalizations, we provide assurance that the generated formulas are well-formed and conform to the intended semantics through an automated validation framework and a formal proof. The extended FRET tool enables developers to specify probabilistic requirements in structured natural language, and to automatically translate them into probabilistic temporal logic, making the formal analysis of autonomous and adaptive systems more practical and less error-prone."}
{"id": "2512.16058", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16058", "abs": "https://arxiv.org/abs/2512.16058", "authors": ["Yifei Qiu", "Tianle Liao", "Xin Jin", "Shaohua Wu", "Dusit Niyato", "Qinyu Zhang"], "title": "Twinning for Space-Air-Ground-Sea Integrated Networks: Beyond Conventional Digital Twin Towards Goal-Oriented Semantic Twin", "comment": null, "summary": "A space-air-ground-sea integrated network (SAGSIN) has emerged as a cornerstone of 6G systems, establishing a unified global architecture by integrating multi-domain network resources. Motivated by the demand for real-time situational awareness and intelligent operational maintenance, digital twin (DT) technology was initially regarded as a promising solution, owing to its capability to create virtual replicas and emulate physical system behaviors. However, in the context of SAGSIN, the high-fidelity, full-scale modeling paradigm inherent to conventional DTs encounters fundamental limitations, including prohibitive computational overhead, delayed model synchronization, and cross-system semantic gaps. To address these limitations, this survey paper proposes a novel twinning framework: goal-oriented semantic twin (GOST). Unlike DTs that pursue physical mirroring, GOST prioritizes ``utility'' over ``fidelity,'' leveraging semantic technologies and goal-oriented principles to construct lightweight, task-specific representations. This paper systematically articulates the GOST framework through three layers: knowledge-based semantics, data-driven semantics, and goal-oriented principles. Furthermore, we provide a comprehensive tutorial on constructing GOST by detailing its core enabling technologies and introduce a multidimensional evaluation framework for GOST. We present a case study targeting collaborative tracking tasks in remote satellite-UAV networks, demonstrating that GOST significantly outperforms conventional DTs in timeliness of perceptual data and collaborative tracking. Finally, we outline research directions, establishing GOST as a transformative twinning paradigm to guide the development of SAGSIN."}
{"id": "2512.15816", "categories": ["cs.PL", "cs.AI", "cs.LO"], "pdf": "https://arxiv.org/pdf/2512.15816", "abs": "https://arxiv.org/abs/2512.15816", "authors": ["Daragh King", "Vasileios Koutavas", "Laura Kovacs"], "title": "A Neurosymbolic Approach to Loop Invariant Generation via Weakest Precondition Reasoning", "comment": null, "summary": "Loop invariant generation remains a critical bottleneck in automated program verification. Recent work has begun to explore the use of Large Language Models (LLMs) in this area, yet these approaches tend to lack a reliable and structured methodology, with little reference to existing program verification theory. This paper presents NeuroInv, a neurosymbolic approach to loop invariant generation. NeuroInv comprises two key modules: (1) a neural reasoning module that leverages LLMs and Hoare logic to derive and refine candidate invariants via backward-chaining weakest precondition reasoning, and (2) a verification-guided symbolic module that iteratively repairs invariants using counterexamples from OpenJML. We evaluate NeuroInv on a comprehensive benchmark of 150 Java programs, encompassing single and multiple (sequential) loops, multiple arrays, random branching, and noisy code segments. NeuroInv achieves a $99.5\\%$ success rate, substantially outperforming the other evaluated approaches. Additionally, we introduce a hard benchmark of $10$ larger multi-loop programs (with an average of $7$ loops each); NeuroInv's performance in this setting demonstrates that it can scale to more complex verification scenarios."}
{"id": "2512.16066", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16066", "abs": "https://arxiv.org/abs/2512.16066", "authors": ["Syed Salauddin Mohammad Tariq", "Foyzul Hassan", "Amiangshu Bosu", "Probir Roy"], "title": "Cold-Start Anti-Patterns and Refactorings in Serverless Systems: An Empirical Study", "comment": null, "summary": "Serverless computing simplifies deployment and scaling, yet cold-start latency remains a major performance bottleneck. Unlike prior work that treats mitigation as a black-box optimization, we study cold starts as a developer-visible design problem. From 81 adjudicated issue reports across open-source serverless systems, we derive taxonomies of initialization anti-patterns, remediation strategies, and diagnostic challenges spanning design, packaging, and runtime layers. Building on these insights, we introduce SCABENCH, a reproducible benchmark, and INITSCOPE, a lightweight analysis framework linking what code is loaded with what is executed. On SCABENCH, INITSCOPE improved localization accuracy by up to 40% and reduced diagnostic effort by 64% compared with prior tools, while a developer study showed higher task accuracy and faster diagnosis. Together, these results advance evidence-driven, performance-aware practices for cold-start mitigation in serverless design. Availability: The research artifact is publicly accessible for future studies and improvements."}
{"id": "2512.15834", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.PF", "cs.SE"], "pdf": "https://arxiv.org/pdf/2512.15834", "abs": "https://arxiv.org/abs/2512.15834", "authors": ["Daniel Nichols", "Prajwal Singhania", "Charles Jekel", "Abhinav Bhatele", "Harshitha Menon"], "title": "Optimizing Agentic Language Model Inference via Speculative Tool Calls", "comment": null, "summary": "Language models (LMs) are becoming increasingly dependent on external tools. LM-based agentic frameworks frequently interact with their environment via such tools to search files, run code, call APIs, etc. Further, modern reasoning-based LMs use tools such as web search and Python code execution to enhance their reasoning capabilities. While tools greatly improve the capabilities of LMs, they also introduce performance bottlenecks during the inference process. In this paper, we introduce novel systems optimizations to address such performance bottlenecks by speculating tool calls and forcing sequences to remain resident in the inference engine to minimize overheads. Our optimizations lead to throughput improvements of several hundred tokens per second when hosting inference for LM agents. We provide a theoretical analysis of our algorithms to provide insights into speculation configurations that will yield the best performance. Further, we recommend a new \"tool cache\" API endpoint to enable LM providers to easily adopt these optimizations."}
{"id": "2512.16099", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16099", "abs": "https://arxiv.org/abs/2512.16099", "authors": ["Hsu-Tzu Ting", "Jerry Chou", "Ming-Hung Chen", "I-Hsin Chung"], "title": "An Online Fragmentation-Aware Scheduler for Managing GPU-Sharing Workloads on Multi-Instance GPUs", "comment": "10 pages, 10 figures", "summary": "Modern GPU workloads increasingly demand efficient resource sharing, as many jobs do not require the full capacity of a GPU. Among sharing techniques, NVIDIA's Multi-Instance GPU (MIG) offers strong resource isolation by enabling hardware-level GPU partitioning. However, leveraging MIG effectively introduces new challenges. First, resource contention persists due to shared components such as PCIe bandwidth. Second, GPU fragmentation becomes a critical issue, which is different from prior fine-grained GPU sharing work due to MIG's limited number of valid MIG configurations. Fragmentation arises not only from spatial discontinuity but also from rigid profile placement constraints, especially after job arrivals and terminations. To address these issues, we propose an online scheduling framework that integrates conditional load balancing, dynamic partitioning, and job migration. Our approach dynamically adapts job placement to minimize contention and reorganizes GPU allocations to combat both internal and external fragmentation. Experimental results show that our method significantly improves system efficiency. When all techniques are applied, the makespan improves by up to 35%."}
{"id": "2512.16134", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2512.16134", "abs": "https://arxiv.org/abs/2512.16134", "authors": ["Jian Tian", "Shuailong Li", "Yang Cao", "Wenbo Cui", "Minghan Zhu", "Wenkang Wu", "Jianming Zhang", "Yanpeng Wang", "Zhiwen Xiao", "Zhenyu Hou", "Dou Shen"], "title": "Staggered Batch Scheduling: Co-optimizing Time-to-First-Token and Throughput for High-Efficiency LLM Inference", "comment": null, "summary": "The evolution of Large Language Model (LLM) serving towards complex, distributed architectures--specifically the P/D-separated, large-scale DP+EP paradigm--introduces distinct scheduling challenges. Unlike traditional deployments where schedulers can treat instances as black boxes, DP+EP architectures exhibit high internal synchronization costs. We identify that immediate request dispatching in such systems leads to severe in-engine queuing and parallelization bubbles, degrading Time-to-First-Token (TTFT). To address this, we propose Staggered Batch Scheduling (SBS), a mechanism that deliberately buffers requests to form optimal execution batches. This temporal decoupling eliminates internal queuing bubbles without compromising throughput. Furthermore, leveraging the scheduling window created by buffering, we introduce a Load-Aware Global Allocation strategy that balances computational load across DP units for both Prefill and Decode phases. Deployed on a production H800 cluster serving Deepseek-V3, our system reduces TTFT by 30%-40% and improves throughput by 15%-20% compared to state-of-the-art immediate scheduling baselines."}
{"id": "2512.16136", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16136", "abs": "https://arxiv.org/abs/2512.16136", "authors": ["Zhisheng Hu", "Pengfei Zuo", "Junliang Hu", "Yizou Chen", "Yingjia Wang", "Ming-Chang Yang"], "title": "Lotus: Optimizing Disaggregated Transactions with Disaggregated Locks", "comment": null, "summary": "Disaggregated memory (DM) separates compute and memory resources, allowing flexible scaling to achieve high resource utilization. To ensure atomic and consistent data access on DM, distributed transaction systems have been adapted, where compute nodes (CNs) rely on one-sided RDMA operations to access remote data in memory nodes (MNs). However, we observe that in existing transaction systems, the RDMA network interface cards at MNs become a primary performance bottleneck. This bottleneck arises from the high volume of one-sided atomic operations used for locks, which hinders the system's ability to scale efficiently.\n  To address this issue, this paper presents Lotus, a scalable distributed transaction system with lock disaggregation on DM. The key innovation of Lotus is to disaggregate locks from data and execute all locks on CNs, thus eliminating the bottleneck at MN RNICs. To achieve efficient lock management on CNs, Lotus employs an application-aware lock management mechanism that leverages the locality of the OLTP workloads to shard locks while maintaining load balance. To ensure consistent transaction processing with lock disaggregation, Lotus introduces a lock-first transaction protocol, which separates the locking phase as the first step in each read-write transaction execution. This protocol allows the system to determine the success of lock acquisitions early and proactively abort conflicting transactions, improving overall efficiency. To tolerate lock loss during CN failures, Lotus employs a lock-rebuild-free recovery mechanism that treats locks as ephemeral and avoids their reconstruction, ensuring lightweight recovery for CN failures. Experimental results demonstrate that Lotus improves transaction throughput by up to 2.1$\\times$ and reduces latency by up to 49.4% compared to state-of-the-art transaction systems on DM."}
{"id": "2512.16148", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16148", "abs": "https://arxiv.org/abs/2512.16148", "authors": ["Zhisheng Hu", "Jiacheng Shen", "Ming-Chang Yang"], "title": "FlexKV: Flexible Index Offloading for Memory-Disaggregated Key-Value Store", "comment": null, "summary": "Disaggregated memory (DM) is a promising data center architecture that decouples CPU and memory into independent resource pools to improve resource utilization. Building on DM, memory-disaggregated key-value (KV) stores are adopted to efficiently manage remote data. Unfortunately, existing approaches suffer from poor performance due to two critical issues: 1) the overdependence on one-sided atomic operations in index processing, and 2) the constrained efficiency in compute-side caches. To address these issues, we propose FlexKV, a memory-disaggregated KV store with index proxying. Our key idea is to dynamically offload the index to compute nodes, leveraging their powerful CPUs to accelerate index processing and maintain high-performance compute-side caches. Three challenges have to be addressed to enable efficient index proxying on DM, i.e., the load imbalance across compute nodes, the limited memory of compute nodes, and the expensive cache coherence overhead. FlexKV proposes: 1) a rank-aware hotness detection algorithm to continuously balance index load across compute nodes, 2) a two-level CN memory optimization scheme to efficiently utilize compute node memory, and 3) an RPC-aggregated cache management mechanism to reduce cache coherence overhead. The experimental results show that FlexKV improves throughput by up to 2.94$\\times$ and reduces latency by up to 85.2%, compared with the state-of-the-art memory-disaggregated KV stores."}
{"id": "2512.16455", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2512.16455", "abs": "https://arxiv.org/abs/2512.16455", "authors": ["Ignacio Heredia", "Álvaro López García", "Germán Moltó", "Amanda Calatrava", "Valentin Kozlov", "Alessandro Costantini", "Viet Tran", "Mario David", "Daniel San Martín", "Marcin Płóciennik", "Marta Obregón Ruiz", "Saúl Fernandez", "Judith Sáinz-Pardo Díaz", "Miguel Caballer", "Caterina Alarcón Marín", "Stefan Dlugolinsky", "Martin Šeleng", "Lisana Berberi", "Khadijeh Alibabaei", "Borja Esteban Sanchis", "Pedro Castro", "Giacinto Donvito", "Diego Aguirre", "Sergio Langarita", "Vicente Rodriguez", "Leonhard Duda", "Andrés Heredia Canales", "Susana Rebolledo Ruiz", "João Machado", "Giang Nguyen", "Fernando Aguilar Gómez", "Jaime Díez"], "title": "AI4EOSC: a Federated Cloud Platform for Artificial Intelligence in Scientific Research", "comment": null, "summary": "In this paper, we describe a federated compute platform dedicated to support Artificial Intelligence in scientific workloads. Putting the effort into reproducible deployments, it delivers consistent, transparent access to a federation of physically distributed e-Infrastructures. Through a comprehensive service catalogue, the platform is able to offer an integrated user experience covering the full Machine Learning lifecycle, including model development (with dedicated interactive development environments), training (with GPU resources, annotation tools, experiment tracking, and federated learning support) and deployment (covering a wide range of deployment options all along the Cloud Continuum). The platform also provides tools for traceability and reproducibility of AI models, integrates with different Artificial Intelligence model providers, datasets and storage resources, allowing users to interact with the broader Machine Learning ecosystem. Finally, it is easily customizable to lower the adoption barrier by external communities."}
{"id": "2512.16473", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16473", "abs": "https://arxiv.org/abs/2512.16473", "authors": ["En-Ming Huang", "Li-Shang Lin", "Chun-Yi Lee"], "title": "Efficient CPU-GPU Collaborative Inference for MoE-based LLMs on Memory-Limited Systems", "comment": "7 pages, 6 figures, to be published in ASP-DAC 2026", "summary": "Large Language Models (LLMs) have achieved impressive results across various tasks, yet their high computational demands pose deployment challenges, especially on consumer-grade hardware. Mixture of Experts (MoE) models provide an efficient solution through selective activation of parameter subsets, which reduces computation requirements. Despite this efficiency, state-of-the-art MoE models still require substantial memory beyond typical consumer GPU capacities. Traditional offloading methods that transfer model weights between CPU and GPU introduce latency, limiting inference performance. This paper presents a novel CPU-GPU collaborative inference framework that incorporates an expert caching mechanism on the GPU to reduce data transfer requirements and enable faster inference through cache hits. Computations are offloaded to CPU for efficient cache miss handling, which benefits from CPU multithreading optimizations. The evaluations of our framework demonstrate performance improvements and highlight the potential of CPU-GPU collaboration to maximize hardware utilization for single-request inference scenarios on consumer-grade systems. The implementation of our framework is available at https://github.com/elsa-lab/MoE-CPU-GPU-Collaborative-Inference."}
{"id": "2512.16792", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2512.16792", "abs": "https://arxiv.org/abs/2512.16792", "authors": ["Endar Suprih Wihidayat", "Sieteng Soh", "Kwan-Wu Chin", "Duc-son Pham"], "title": "Delay-Aware Multi-Stage Edge Server Upgrade with Budget Constraint", "comment": "17 pages, 9 figures", "summary": "In this paper, the Multi-stage Edge Server Upgrade (M-ESU) is proposed as a new network planning problem, involving the upgrading of an existing multi-access edge computing (MEC) system through multiple stages (e.g., over several years). More precisely, the problem considers two key decisions: (i) whether to deploy additional edge servers or upgrade those already installed, and (ii) how tasks should be offloaded so that the average number of tasks that meet their delay requirement is maximized. The framework specifically involves: (i) deployment of new servers combined with capacity upgrades for existing servers, and (ii) the optimal task offloading to maximize the average number of tasks with a delay requirement. It also considers the following constraints: (i) budget per stage, (ii) server deployment and upgrade cost (in $) and cost depreciation rate, (iii) computation resource of servers, (iv) number of tasks and their growth rate (in %), and (v) the increase in task sizes and stricter delay requirements over time. We present two solutions: a Mixed Integer Linear Programming (MILP) model and an efficient heuristic algorithm (M-ESU/H). MILP yields the optimal solution for small networks, whereas M-ESU/H is used in large-scale networks. For small networks, the simulation results show that the solution computed by M-ESU/H is within 1.25% of the optimal solution while running several orders of magnitude faster. For large networks, M-ESU/H is compared against three alternative heuristic solutions that consider only server deployment, or giving priority to server deployment or upgrade. Our experiments show that M-ESU/H yields up to 21.57% improvement in task satisfaction under identical budget and demand growth conditions, confirming its scalability and practical value for long-term MEC systems."}
{"id": "2512.15766", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2512.15766", "abs": "https://arxiv.org/abs/2512.15766", "authors": ["Yijie Zhi", "Yayu Cao", "Jianhua Dai", "Xiaoyang Han", "Jingwen Pu", "Qingran Wu", "Sheng Cheng", "Ming Cai"], "title": "LOOPRAG: Enhancing Loop Transformation Optimization with Retrieval-Augmented Large Language Models", "comment": "Accepted to ASPLOS 2026", "summary": "Loop transformations are semantics-preserving optimization techniques, widely used to maximize objectives such as parallelism. Despite decades of research, applying the optimal composition of loop transformations remains challenging due to inherent complexities, including cost modeling for optimization objectives. Recent studies have explored the potential of Large Language Models (LLMs) for code optimization. However, our key observation is that LLMs often struggle with effective loop transformation optimization, frequently leading to errors or suboptimal optimization, thereby missing opportunities for performance improvements. To bridge this gap, we propose LOOPRAG, a novel retrieval-augmented generation framework designed to guide LLMs in performing effective loop optimization on Static Control Part. We introduce a parameter-driven method to harness loop properties, which trigger various loop transformations, and generate diverse yet legal example codes serving as a demonstration source. To effectively obtain the most informative demonstrations, we propose a loop-aware algorithm based on loop features, which balances similarity and diversity for code retrieval. To enhance correct and efficient code generation, we introduce a feedback-based iterative mechanism that incorporates compilation, testing and performance results as feedback to guide LLMs. Each optimized code undergoes mutation, coverage and differential testing for equivalence checking. We evaluate LOOPRAG on PolyBench, TSVC and LORE benchmark suites, and compare it against compilers (GCC-Graphite, Clang-Polly, Perspective and ICX) and representative LLMs (DeepSeek and GPT-4). The results demonstrate average speedups over base compilers of up to 11.20$\\times$, 14.34$\\times$, and 9.29$\\times$ for PolyBench, TSVC, and LORE, respectively, and speedups over base LLMs of up to 11.97$\\times$, 5.61$\\times$, and 11.59$\\times$."}
{"id": "2512.15834", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.PF", "cs.SE"], "pdf": "https://arxiv.org/pdf/2512.15834", "abs": "https://arxiv.org/abs/2512.15834", "authors": ["Daniel Nichols", "Prajwal Singhania", "Charles Jekel", "Abhinav Bhatele", "Harshitha Menon"], "title": "Optimizing Agentic Language Model Inference via Speculative Tool Calls", "comment": null, "summary": "Language models (LMs) are becoming increasingly dependent on external tools. LM-based agentic frameworks frequently interact with their environment via such tools to search files, run code, call APIs, etc. Further, modern reasoning-based LMs use tools such as web search and Python code execution to enhance their reasoning capabilities. While tools greatly improve the capabilities of LMs, they also introduce performance bottlenecks during the inference process. In this paper, we introduce novel systems optimizations to address such performance bottlenecks by speculating tool calls and forcing sequences to remain resident in the inference engine to minimize overheads. Our optimizations lead to throughput improvements of several hundred tokens per second when hosting inference for LM agents. We provide a theoretical analysis of our algorithms to provide insights into speculation configurations that will yield the best performance. Further, we recommend a new \"tool cache\" API endpoint to enable LM providers to easily adopt these optimizations."}
