{"id": "2602.22240", "categories": ["cs.PL", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22240", "abs": "https://arxiv.org/abs/2602.22240", "authors": ["Linus Bantel", "Moritz Strack", "Alexander Strack", "Dirk Pfl\u00fcger"], "title": "From Prompts to Performance: Evaluating LLMs for Task-based Parallel Code Generation", "comment": "12 pages, 4 figures, 2 tables, Workshop on Asynchronous Many-Task Systems and Applications 2026", "summary": "Large Language Models (LLM) show strong abilities in code generation, but their skill in creating efficient parallel programs is less studied. This paper explores how LLMs generate task-based parallel code from three kinds of input prompts: natural language problem descriptions, sequential reference implementations, and parallel pseudo code. We focus on three programming frameworks: OpenMP Tasking, C++ standard parallelism, and the asynchronous many-task runtime HPX. Each framework offers different levels of abstraction and control for task execution. We evaluate LLM-generated solutions for correctness and scalability. Our results reveal both strengths and weaknesses of LLMs with regard to problem complexity and framework. Finally, we discuss what these findings mean for future LLM-assisted development in high-performance and scientific computing.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.23216", "categories": ["cs.PL", "cs.LO", "cs.SE"], "pdf": "https://arxiv.org/pdf/2602.23216", "abs": "https://arxiv.org/abs/2602.23216", "authors": ["Weijie Lu", "Jingyu Ke", "Hongfei Fu", "Zhouyue Sun", "Yi Zhou", "Guoqiang Li", "Haokun Li"], "title": "Array-Carrying Symbolic Execution for Function Contract Generation", "comment": "30 pages, 2 figures. To appear in the 27th International Symposium on Formal Methods (FM 2026)", "summary": "Function contract generation is a classical problem in program analysis that targets the automated analysis of functions in a program with multiple procedures. The problem is fundamental in inter-procedural analysis where properties of functions are first obtained via the generation of function contracts and then the generated contracts are used as building blocks to analyze the whole program. Typical objectives in function contract generation include pre-/post-conditions and assigns information (that specifies the modification information over program variables and memory segments during function execution). In programs with array manipulations, a crucial point in function contract generation is the treatment of array segments that imposes challenges in inferring invariants and assigns information over such segments. To address this challenge, we propose a novel symbolic execution framework that carries invariants and assigns information over contiguous segments of arrays. We implement our framework as a prototype within LLVM, and further integrate our prototype with the ACSL assertion format and the Frama-C software verification platform. Experimental evaluation over a variety of benchmarks from the literature and functions from realistic libraries shows that our framework is capable of handling array manipulating functions that indeed involve the carry of array information and are beyond existing approaches.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22300", "categories": ["cs.DS", "cs.LG"], "pdf": "https://arxiv.org/pdf/2602.22300", "abs": "https://arxiv.org/abs/2602.22300", "authors": ["Ilias Diakonikolas", "Giannis Iakovidis", "Daniel M. Kane", "Sihan Liu"], "title": "Testable Learning of General Halfspaces under Massart Noise", "comment": null, "summary": "We study the algorithmic task of testably learning general Massart halfspaces under the Gaussian distribution. In the testable learning setting, the aim is the design of a tester-learner pair satisfying the following properties: (1) if the tester accepts, the learner outputs a hypothesis and a certificate that it achieves near-optimal error, and (2) it is highly unlikely that the tester rejects if the data satisfies the underlying assumptions. Our main result is the first testable learning algorithm for general halfspaces with Massart noise and Gaussian marginals. The complexity of our algorithm is $d^{\\mathrm{polylog}(\\min\\{1/\u03b3, 1/\u03b5\\})}$, where $\u03b5$ is the excess error and $\u03b3$ is the bias of the target halfspace, which qualitatively matches the known quasi-polynomial Statistical Query lower bound for the non-testable setting. The analysis of our algorithm hinges on a novel sandwiching polynomial approximation to the sign function with multiplicative error that may be of broader interest.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22506", "categories": ["cs.DS", "cs.SE"], "pdf": "https://arxiv.org/pdf/2602.22506", "abs": "https://arxiv.org/abs/2602.22506", "authors": ["Isaac D. Myhal", "Oliver Serang"], "title": "static_maps: consteval std::map and std::unordered_map Implementations in C++23", "comment": null, "summary": "Using consteval from C++23, we implement efficient, new versions of std::map and std::unordered_map for use when the keys are known at compile time. We demonstrate superior performance of our unordered_map on three demonstration use-cases: Lookup of elemental mass from atomic symbol, lookup of amino acid from codon, and modification of stock prices from S&P 500 ticker symbols all produced runtimes <40%, <35%, <73% of the respective runtimes of the std implementations. Our library runimes were <80%, <45%, <97% of the lookup time of Frozen, an alternative perfect hashing implementation in C++ for problems also using constexpr keys. To our knowledge, this makes our library the overall fastest drop-in (i.e., with a similar API) alternative to std::unordered_map. On one arbitrarily chosen demo, we demonstrate runtimes <35% of PTHash and <89% gperf, state-of-the-art but not drop-in hashing libraries via external tools.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22290", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22290", "abs": "https://arxiv.org/abs/2602.22290", "authors": ["Yahao Ding", "Yinchao Yang", "Jiaxiang Wang", "Zhonghao Liu", "Zhaohui Yang", "Mingzhe Chen", "Mohammad Shikh-Bahaei"], "title": "Energy Efficient Federated Learning with Hyperdimensional Computing (HDC)", "comment": "6 pages, 3 figures", "summary": "This paper investigates the problem of minimizing total energy consumption for secure federated learning (FL) in wireless edge networks, a key paradigm for decentralized big data analytics. To tackle the high computational cost and privacy challenges of processing large-scale distributed data with conventional neural networks, we propose an FL with hyperdimensional computing and differential privacy (FL-HDC-DP) framework. Each edge device employs hyperdimensional computing (HDC) for lightweight local training and applies differential privacy (DP) noise to protect transmitted model updates. The total energy consumption is minimized through a joint optimization of the HDC dimension, transmit power, and CPU frequency. An efficient hybrid algorithm is developed, combining an outer enumeration search for HDC dimensions with an inner one-dimensional search for resource allocation. Simulation results show that the proposed framework achieves up to 83.3% energy reduction compared with baseline schemes, while maintaining high accuracy and faster convergence.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22229", "categories": ["cs.AR", "cs.CR"], "pdf": "https://arxiv.org/pdf/2602.22229", "abs": "https://arxiv.org/abs/2602.22229", "authors": ["Lohit Daksha", "Seyda Guzelhan", "Kaustubh Shivdikar", "Carlos Agull\u00f3 Domingo", "\u00d3scar Vera Lopez", "Gilbert Jonatan", "Hubert Dymarkowski", "Aymane El Jerari", "Jos\u00e9 Cano", "Jos\u00e9 L. Abell\u00e1n", "John Kim", "David Kaeli", "Ajay Joshi"], "title": "FHECore: Rethinking GPU Microarchitecture for Fully Homomorphic Encryption", "comment": null, "summary": "Fully Homomorphic Encryption (FHE) enables computation directly on encrypted data but incurs massive computational and memory overheads, often exceeding plaintext execution by several orders of magnitude. While custom ASIC accelerators can mitigate these costs, their long time-to-market and the rapid evolution of FHE algorithms threaten their long-term relevance. GPUs, by contrast, offer scalability, programmability, and widespread availability, making them an attractive platform for FHE. However, modern GPUs are increasingly specialized for machine learning workloads, emphasizing low-precision datatypes (e.g., INT$8$, FP$8$) that are fundamentally mismatched to the wide-precision modulo arithmetic required by FHE. Essentially, while GPUs offer ample parallelism, their functional units, like Tensor Cores, are not suited for wide-integer modulo arithmetic required by FHE schemes such as CKKS. Despite this constraint, researchers have attempted to map FHE primitives on Tensor Cores by segmenting wide integers into low-precision (INT$8$) chunks.\n  To overcome these bottlenecks, we propose FHECore, a specialized functional unit integrated directly into the GPU's Streaming Multiprocessor. Our design is motivated by a key insight: the two dominant contributors to latency$-$Number Theoretic Transform and Base Conversion$-$can be formulated as modulo-linear transformations. This allows them to be mapped on a common hardware unit that natively supports wide-precision modulo-multiply-accumulate operations. Our simulations demonstrate that FHECore reduces dynamic instruction count by a geometric mean of $2.41\\times$ for CKKS primitives and $1.96\\times$ for end-to-end workloads. These reductions translate to performance speedups of $1.57\\times$ and $2.12\\times$, respectively$-$including a $50\\%$ reduction in bootstrapping latency$-$all while inuring a modest $2.4\\%$ area overhead.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22870", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.22870", "abs": "https://arxiv.org/abs/2602.22870", "authors": ["Kleitos Papadopoulos"], "title": "An $\\mathcal{O}(\\log N)$ Time Algorithm for the Generalized Egg Dropping Problem", "comment": null, "summary": "The generalized egg dropping problem is a canonical benchmark in sequential decision-making. Standard dynamic programming evaluates the minimum number of tests in the worst case in $\\mathcal{O}(K \\cdot N^2)$ time. The previous state-of-the-art approach formulates the testable thresholds as a partial sum of binomial coefficients and applies a combinatorial search to reduce the time complexity to $\\mathcal{O}(K \\log N)$. In this paper, we demonstrate that the discrete binary search over the decision tree can be bypassed entirely. By utilizing a relaxation of the binomial bounds, we compute an approximate root that tightly bounds the optimal value. We mathematically prove that this approximation restricts the remaining search space to exactly $\\mathcal{O}(K)$ discrete steps. Because constraints inherently enforce $K < \\log_2(N+1)$, our algorithm achieves an unconditional worst-case time complexity of $\\mathcal{O}(\\min(K, \\log N))$. Furthermore, we formulate an explicit $\\mathcal{O}(1)$ space deterministic policy to dynamically retrace the optimal sequential choices, eliminating classical state-transition matrices completely.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22350", "categories": ["cs.DC", "physics.soc-ph"], "pdf": "https://arxiv.org/pdf/2602.22350", "abs": "https://arxiv.org/abs/2602.22350", "authors": ["Paul Borrill"], "title": "Engineered Simultaneity: The Physical Impossibility of Consolidated Price Discovery Across Spacelike-Separated Exchanges", "comment": "8 pages, 2 figures, 2 tables", "summary": "We introduce the concept of engineered simultaneity: a system design that (1) requires comparing events at spacelike-separated locations, (2) implements this comparison via an implicit simultaneity convention, and (3) represents the result as objective rather than conventional. The United States National Best Bid and Offer (NBBO), mandated by SEC Regulation NMS Rule 611, is shown to be an instance of engineered simultaneity. We prove that the NBBO is frame-dependent: its value depends on the reference frame in which \"current\" prices are defined. Since the exchanges that generate quote data are separated by distances of 43-1,180 km, light-travel times of 143-3,940 microseconds create unavoidable windows during which no frame-independent price ordering exists. High-frequency trading firms exploit this window by accessing exchange data via direct feeds (latency ~tens of microseconds) while the consolidated Securities Information Processor operates at ~1,128 microseconds -- a ratio exceeding 50:1. We demonstrate that this constitutes a category mistake in the sense of Ryle: the NBBO applies the concept of \"simultaneity\" in a domain where it has no frame-independent meaning. The resulting information asymmetry extracts approximately $5 billion annually from other market participants.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22352", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2602.22352", "abs": "https://arxiv.org/abs/2602.22352", "authors": ["Yuhao Liu", "Salim Ullah", "Akash Kumar"], "title": "GRAU: Generic Reconfigurable Activation Unit Design for Neural Network Hardware Accelerators", "comment": null, "summary": "With the continuous growth of neural network scales, low-precision quantization is widely used in edge accelerators. Classic multi-threshold activation hardware requires 2^n thresholds for n-bit outputs, causing a rapid increase in hardware cost as precision increases. We propose a reconfigurable activation hardware, GRAU, based on piecewise linear fitting, where the segment slopes are approximated by powers of two. Our design requires only basic comparators and 1-bit right shifters, supporting mixed-precision quantization and nonlinear functions such as SiLU. Compared with multi-threshold activators, GRAU reduces LUT consumption by over 90%, achieving higher hardware efficiency, flexibility, and scalability.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22976", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.22976", "abs": "https://arxiv.org/abs/2602.22976", "authors": ["Henrik Reinst\u00e4dtler", "Christian Schulz", "Nodari Sitchinava", "Fabian Walliser"], "title": "Efficient Parallel Algorithms for Hypergraph Matching", "comment": null, "summary": "We present efficient parallel algorithms for computing maximal matchings in hypergraphs. Our algorithm finds locally maximal edges in the hypergraph and adds them in parallel to the matching. In the CRCW PRAM models our algorithms achieve $O(\\log{m})$ time with $O((\u03ba+ n) \\log {m})$ work w.h.p. where $m$ is the number of hyperedges, and $\u03ba$ is the sum of all vertex degrees. The CREW PRAM model algorithm has a running time of $O((\\log\u0394+\\log{d})\\log{m})$ and requires $O((\u03ba+ n) \\log {m})$ work w.h.p. It can be implemented work-optimal with $O(\u03ba+n)$ work in $O((\\log{m}+\\log{n})\\log{m})$ time. We prove a $1/d$-approximation guarantee for our algorithms.\n  We evaluate our algorithms experimentally by implementing and running the proposed algorithms on the GPU using CUDA and Kokkos. Our experimental evaluation demonstrates the practical efficiency of our approach on real-world hypergraph instances, yielding a speed up of up to 76 times compared to a single-core CPU algorithm.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22392", "categories": ["cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2602.22392", "abs": "https://arxiv.org/abs/2602.22392", "authors": ["Md Hasanur Rashid", "Xinyi Li", "Youbiao He", "Forrest Sheng Bao", "Dong Dai"], "title": "DIAL: Decentralized I/O AutoTuning via Learned Client-side Local Metrics for Parallel File System", "comment": null, "summary": "Enabling efficient, high-performance data access in parallel file systems (PFS) is critical for today's high-performance computing systems. PFS client-side I/O heavily impacts the final I/O performance delivered to individual applications and the entire system. Autotuning the key client-side I/O behaviors has been extensively studied and shows promising results. However, existing work has heavily relied on extensive number of global runtime metrics to monitor and accurate modeling of applications' I/O patterns. Such heavy overheads significantly limit the ability to enable fine-grained, dynamic tuning in practical systems. In this study, we propose DIAL (Decentralized I/O AutoTuning via Learned Client-side Local Metrics) which takes a drastically different approach. Instead of trying to extract the global I/O patterns of applications, DIAL takes a decentralized approach, treating each I/O client as an independent unit and tuning configurations using only its locally observable metrics. With the help of machine learning models, DIAL enables multiple tunable units to make independent but collective decisions, reacting to what is happening in the global storage systems in a timely manner and achieving better I/O performance globally for the application.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.23196", "categories": ["cs.DS", "cs.CC", "math.CO"], "pdf": "https://arxiv.org/pdf/2602.23196", "abs": "https://arxiv.org/abs/2602.23196", "authors": ["Amir Abboud", "Ron Safier", "Nathan Wallheimer"], "title": "Equivalent Dichotomies for Triangle Detection in Subgraph, Induced, and Colored H-Free Graphs", "comment": null, "summary": "A recent paper by the authors (ITCS'26) initiates the study of the Triangle Detection problem in graphs avoiding a fixed pattern $H$ as a subgraph and proposes a \\emph{dichotomy hypothesis} characterizing which patterns $H$ make the Triangle Detection problem easier in $H$-free graphs than in general graphs.\n  In this work, we demonstrate that this hypothesis is, in fact, equivalent to analogous hypotheses in two broader settings that a priori seem significantly more challenging: \\emph{induced} $H$-free graphs and \\emph{colored} $H$-free graphs.\n  Our main contribution is a reduction from the induced $H$-free case to the non-induced $\\H^+$-free case, where $\\H^+$ preserves the structural properties of $H$ that are relevant for the dichotomy, namely $3$-colorability and triangle count. A similar reduction is given for the colored case.\n  A key technical ingredient is a self-reduction to Unique Triangle Detection that preserves the induced $H$-freeness property, via a new color-coding-like reduction.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22409", "categories": ["cs.DC", "cs.PF", "eess.SY"], "pdf": "https://arxiv.org/pdf/2602.22409", "abs": "https://arxiv.org/abs/2602.22409", "authors": ["Md Hasanur Rashid", "Dong Dai"], "title": "AdapTBF: Decentralized Bandwidth Control via Adaptive Token Borrowing for HPC Storage", "comment": null, "summary": "Modern high-performance computing (HPC) applications run on compute resources but share global storage systems. This design can cause problems when applications consume a disproportionate amount of storage bandwidth relative to their allocated compute resources. For example, an application running on a single compute node can issue many small, random writes and consume excessive I/O bandwidth from a storage server. This can hinder larger jobs that write to the same storage server and are allocated many compute nodes, resulting in significant resource waste.\n  A straightforward solution is to limit each application's I/O bandwidth on storage servers in proportion to its allocated compute resources. This approach has been implemented in parallel file systems using Token Bucket Filter (TBF). However, strict proportional limits often reduce overall I/O efficiency because HPC applications generate short, bursty I/O. Limiting bandwidth can waste server capacity when applications are idle or prevent applications from temporarily using higher bandwidth during bursty phases.\n  We argue that I/O control should maximize per-application performance and overall storage efficiency while ensuring fairness (e.g., preventing small jobs from blocking large-scale ones). We propose AdapTBF, which builds on TBF in modern parallel file systems (e.g., Lustre) and introduces a decentralized bandwidth control approach using adaptive borrowing and lending. We detail the algorithm, implement AdapTBF in Lustre, and evaluate it using synthetic workloads modeled after real-world scenarios. Results show that AdapTBF manages I/O bandwidth effectively while maintaining high storage utilization, even under extreme conditions.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.23334", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2602.23334", "abs": "https://arxiv.org/abs/2602.23334", "authors": ["Yuhao Liu", "Salim Ullah", "Akash Kumar"], "title": "Bitwise Systolic Array Architecture for Runtime-Reconfigurable Multi-precision Quantized Multiplication on Hardware Accelerators", "comment": null, "summary": "Neural network accelerators have been widely applied to edge devices for complex tasks like object tracking, image recognition, etc. Previous works have explored the quantization technologies in related lightweight accelerator designs to reduce hardware resource consumption. However, low precision leads to high accuracy loss in inference. Therefore, mixed-precision quantization becomes an alternative solution by applying different precision in different layers to trade off resource consumption and accuracy. Because regular designs for multiplication on hardware cannot support the precision reconfiguration for a multi-precision Quantized Neural Network (QNN) model in runtime, we propose a runtime reconfigurable multi-precision multi-channel bitwise systolic array design for QNN accelerators. We have implemented and evaluated our work on the Ultra96 FPGA platform. Results show that our work can achieve 1.3185 to 3.5671 times speedup in inferring mixed-precision models and has less critical path delay, supporting a higher clock frequency (250MHz).", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22916", "categories": ["cs.DC", "cs.DS"], "pdf": "https://arxiv.org/pdf/2602.22916", "abs": "https://arxiv.org/abs/2602.22916", "authors": ["Yaseen Abd-Elhaleem", "Michal Dory", "Oren Weimann"], "title": "A Simple Distributed Deterministic Planar Separator", "comment": "19 pages, to appear in SIROCCO 2026", "summary": "A balanced separator of a graph $G$ is a set of vertices whose removal disconnects the graph into connected components that are a constant factor smaller than $G$. Lipton and Tarjan [FOCS'77] famously proved that every planar graph admits a balanced separator of size $O(\\sqrt{n})$, as well as a balanced separator of size $O(D)$ that is a simple path (where $D$ is $G$'s diameter). In the centralized setting, both separators can be found in linear time. In the distributed setting, $D$ is a universal lower bound for the round complexity of solving many optimization problems, so, separators of size $O(D)$ are preferable.\n  It was not until [DISC'17] that a distributed algorithm was devised by Ghaffari and Parter to compute such an $O(D)$-size separator in $\\tilde O(D)$ rounds, by adapting the Lipton-Tarjan algorithm to the distributed model. Since then, this algorithm was used in several distributed algorithms for planar graphs, e.g., [GP, DISC'17], [LP, STOC'19], [AEDPW, PODC'25]. However, the algorithm is randomized, deeming the algorithms that use it to be randomized as well. Obtaining a deterministic algorithm remained an interesting open question until [PODC'25], when a (complex) deterministic separator algorithm was given by Jauregui, Montealegre and Rapaport.\n  We present a much simpler deterministic separator algorithm with the same (near-optimal) $\\tilde O(D)$-round complexity. While previous works devised either complicated or randomized ways of transferring weights from vertices to faces of $G$, we show that a straightforward way also works: Each vertex simply transfers its weight to one arbitrary face it lies on. That's it!\n  We note that a deterministic separator algorithm directly derandomizes the state-of-the-art distributed algorithms for classical problems on planar graphs such as single-source shortest-paths, maximum-flow, directed global min-cut, and reachability.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22423", "categories": ["cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2602.22423", "abs": "https://arxiv.org/abs/2602.22423", "authors": ["Md Hasanur Rashid", "Nathan R. Tallent", "Forrest Sheng Bao", "Dong Dai"], "title": "CARAT: Client-Side Adaptive RPC and Cache Co-Tuning for Parallel File Systems", "comment": "to be published in 40th IEEE International Parallel & Distributed Processing Symposium (IPDPS), 2026", "summary": "Tuning parallel file system in High-Performance Computing (HPC) systems remains challenging due to the complex I/O paths, diverse I/O patterns, and dynamic system conditions. While existing autotuning frameworks have shown promising results in tuning PFS parameters based on applications' I/O patterns, they lack scalability, adaptivity, and the ability to operate online. In this work, focusing on scalable online tuning, we present CARAT, an ML-guided framework to co-tune client-side RPC and caching parameters of PFS, leveraging only locally observable metrics. Unlike global or pattern-dependent approaches, CARAT enables each client to make independent and intelligent tuning decisions online, responding to real-time changes in both application I/O behaviors and system states. We then prototyped CARAT using Lustre and evaluated it extensively across dynamic I/O patterns, real-world HPC workloads, and multi-client deployments. The results demonstrated that CARAT can achieve up to 3x performance improvement over the default or static configurations, validating the effectiveness and generality of our approach. Due to its scalability and lightweight, we believe CARAT has the potential to be widely deployed into existing PFS and benefit various data-intensive applications.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22434", "categories": ["cs.DC", "cs.AI", "cs.DB", "cs.LG"], "pdf": "https://arxiv.org/pdf/2602.22434", "abs": "https://arxiv.org/abs/2602.22434", "authors": ["Alex Aizman", "Abhishek Gaikwad", "Piotr \u017belasko"], "title": "GetBatch: Distributed Multi-Object Retrieval for ML Data Loading", "comment": "11 pages, 3 figures, 2 tables. Preprint", "summary": "Machine learning training pipelines consume data in batches. A single training step may require thousands of samples drawn from shards distributed across a storage cluster. Issuing thousands of individual GET requests incurs per-request overhead that often dominates data transfer time. To solve this problem, we introduce GetBatch - a new object store API that elevates batch retrieval to a first-class storage operation, replacing independent GET operations with a single deterministic, fault-tolerant streaming execution. GetBatch achieves up to 15x throughput improvement for small objects and, in a production training workload, reduces P95 batch retrieval latency by 2x and P99 per-object tail latency by 3.7x compared to individual GET requests.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22437", "categories": ["cs.DC", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2602.22437", "abs": "https://arxiv.org/abs/2602.22437", "authors": ["Zezhou Wang", "Youjie Li", "Zhiqi Lin", "Jiacheng Yang", "Cong Xie", "Guanyu Feng", "Zheng Zhong", "Ziyue Huang", "Hongyu Zhu", "Zhi Zhang", "Yanghua Peng", "Xin Liu"], "title": "veScale-FSDP: Flexible and High-Performance FSDP at Scale", "comment": null, "summary": "Fully Sharded Data Parallel (FSDP), also known as ZeRO, is widely used for training large-scale models, featuring its flexibility and minimal intrusion on model code. However, current FSDP systems struggle with structure-aware training methods (e.g., block-wise quantized training) and with non-element-wise optimizers (e.g., Shampoo and Muon) used in cutting-edge models (e.g., Gemini, Kimi K2). FSDP's fixed element- or row-wise sharding formats conflict with the block-structured computations. In addition, today's implementations fall short in communication and memory efficiency, limiting scaling to tens of thousands of GPUs. We introduce veScale-FSDP, a redesigned FSDP system that couples a flexible sharding format, RaggedShard, with a structure-aware planning algorithm to deliver both flexibility and performance at scale. veScale-FSDP natively supports efficient data placement required by FSDP, empowering block-wise quantization and non-element-wise optimizers. As a result, veScale-FSDP achieves 5~66% higher throughput and 16~30% lower memory usage than existing FSDP systems, while scaling efficiently to tens of thousands of GPUs.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22445", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22445", "abs": "https://arxiv.org/abs/2602.22445", "authors": ["Martin Kuettler", "Hermann Haertig"], "title": "Fault-tolerant Reduce and Allreduce operations based on correction", "comment": null, "summary": "Implementations of Broadcast based on some information dissemination algorithm -- e.g., gossip or tree-based communication -- followed by a correction algorithm has been proposed previously. This work describes an approach to apply a similar idea to Reduce. In it, a correction-like communication phase precedes a tree-based phase. This provides a Reduce algorithm which is tolerant to a number of failed processes. Semantics of the resulting algorithm are provided and proven.\n  Based on these results, Broadcast and Reduce are combined to provide Allreduce.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22457", "categories": ["cs.DC", "cs.ET"], "pdf": "https://arxiv.org/pdf/2602.22457", "abs": "https://arxiv.org/abs/2602.22457", "authors": ["Dong Xu", "Han Meng", "Xinyu Chen", "Dengcheng Zhu", "Wei Tang", "Fei Liu", "Liguang Xie", "Wu Xiang", "Rui Shi", "Yue Li", "Henry Hu", "Hui Zhang", "Jianping Jiang", "Dong Li"], "title": "CCCL: Node-Spanning GPU Collectives with CXL Memory Pooling", "comment": null, "summary": "Large language models (LLMs) training or inference across multiple nodes introduces significant pressure on GPU memory and interconnect bandwidth. The Compute Express Link (CXL) shared memory pool offers a scalable solution by enabling memory sharing across nodes, reducing over-provisioning and improving resource utilization. We propose \\name, a collective communication library, leveraging the CXL shared memory pool to support cross-node GPU operations without relying on traditional RDMA-based networking. Our design addresses the challenges on synchronization, data interleaving, and communication parallelization faced by using the CXL shared memory pool for collective communications. Evaluating on multiple nodes with a TITAN-II CXL switch and six Micron CZ120 memory cards, we show that \\name achieves highly efficient collective operations across hosts, demonstrating CXL's potential for scalable, memory-centric GPU communication. Our evaluation demonstrates that \\name achieves average performance improvements of 1.34$\\times$ for AllGather, 1.84$\\times$ for Broadcast, 1.94$\\times$ for Gather, and 1.04$\\times$ for Scatter, compared to the original RDMA-based implementation over 200 Gbps InfiniBand. \\textcolor{dong}{In addition, the evaluation with a case of LLM training shows 1.11$\\times$ speedup compared with the InfiniBand while saving production cost by $2.75\\times$ in hardware.}", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22580", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22580", "abs": "https://arxiv.org/abs/2602.22580", "authors": ["Yuhao Lin", "Zhipeng Tang", "Jiayan Tong", "Junqing Xiao", "Bin Lu", "Yuhang Li", "Chao Li", "Zhiguo Zhang", "Junhua Wang", "Hao Luo", "James Cheng", "Chuang Hu", "Jiawei Jiang", "Xiao Yan"], "title": "FuxiShuffle: An Adaptive and Resilient Shuffle Service for Distributed Data Processing on Alibaba Cloud", "comment": "14 pages, 13 figures", "summary": "Shuffle exchanges intermediate results between upstream and downstream operators in distributed data processing and is usually the bottleneck due to factors such as small random I/Os and network contention. Several systems have been designed to improve shuffle efficiency, but from our experiences of running ultra-large clusters at Alibaba Cloud MaxCompute platform, we observe that they can not adapt to highly dynamic job characteristics and cluster resource conditions, and their fault tolerance mechanisms are passive and inefficient when failures are inevitable. To tackle their limitations, we design and implement FuxiShuffle as a general data shuffle service for the ultra-large production environment of MaxCompute, featuring good adaptability and efficient failure resilience. Specifically, to achieve good adaptability, FuxiShuffle dynamically selects the shuffle mode based on runtime information, conducts progress-aware scheduling for the downstream workers, and automatically determines the most suitable backup strategy for each shuffle data chunk. To make failure resilience efficient, FuxiShuffle actively ensures data availability with multi-replica failover, prevents memory overflow with careful memory management, and employs an incremental recovery mechanism that does not lose computation progress. Our experiments show that, compared to baseline systems, FuxiShuffle significantly reduces not only end-to-end job completion time but also aggregate resource consumption. Micro experiments suggest that our designs are effective in improving adaptability and failure resilience.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22593", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22593", "abs": "https://arxiv.org/abs/2602.22593", "authors": ["Shouwei Gao", "Junqi Yin", "Feiyi Wang", "Wenqian Dong"], "title": "FLYING SERVING: On-the-Fly Parallelism Switching for Large Language Model Serving", "comment": null, "summary": "Production LLM serving must simultaneously deliver high throughput, low latency, and sufficient context capacity under non-stationary traffic and mixed request requirements. Data parallelism (DP) maximizes throughput by running independent replicas, while tensor parallelism (TP) reduces per-request latency and pools memory for long-context inference. However, existing serving stacks typically commit to a static parallelism configuration at deployment; adapting to bursts, priorities, or long-context requests is often disruptive and slow. We present Flying Serving, a vLLM-based system that enables online DP-TP switching without restarting engine workers. Flying Serving makes reconfiguration practical by virtualizing the state that would otherwise force data movement: (i) a zero-copy Model Weights Manager that exposes TP shard views on demand, (ii) a KV Cache Adaptor that preserves request KV state across DP/TP layouts, (iii) an eagerly initialized Communicator Pool to amortize collective setup, and (iv) a deadlock-free scheduler that coordinates safe transitions under execution skew. Across three popular LLMs and realistic serving scenarios, Flying Serving improves performance by up to $4.79\\times$ under high load and $3.47\\times$ under low load while supporting latency- and memory-driven requests.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22760", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2602.22760", "abs": "https://arxiv.org/abs/2602.22760", "authors": ["Philipp Wiesner", "Soeren Becker", "Brett Cornick", "Dominik Scheinert", "Alexander Acker", "Odej Kao"], "title": "Distributed LLM Pretraining During Renewable Curtailment Windows: A Feasibility Study", "comment": "Technical report", "summary": "Training large language models (LLMs) requires substantial compute and energy. At the same time, renewable energy sources regularly produce more electricity than the grid can absorb, leading to curtailment, the deliberate reduction of clean generation that would otherwise go to waste. These periods represent an opportunity: if training is aligned with curtailment windows, LLMs can be pretrained using electricity that is both clean and cheap. This technical report presents a system that performs full-parameter LLM training across geo-distributed GPU clusters during regional curtailment windows, elastically switching between local single-site training and federated multi-site synchronization as sites become available or unavailable. Our prototype trains a 561M-parameter transformer model across three clusters using the Flower federated learning framework, with curtailment periods derived from real-world marginal carbon intensity traces. Preliminary results show that curtailment-aware scheduling preserves training quality while reducing operational emissions to 5-12% of single-site baselines.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22780", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22780", "abs": "https://arxiv.org/abs/2602.22780", "authors": ["Qingyuan Zhang"], "title": "An Artificial Intelligence Framework for Joint Structural-Temporal Load Forecasting in Cloud Native Platforms", "comment": null, "summary": "This study targets cloud native environments where microservice invocation relations are complex, load fluctuations are multi-scale and superimposed, and cross-service impacts are significant. We propose a structured temporal joint load prediction framework oriented to microservice topology. The method represents the system as a coupled entity of a time-evolving service invocation graph and multivariate load sequences. It constructs neighborhood-aggregated and global summarized views based on service level observations. This forms layered load representations across instance, service, and cluster levels. A unified sequence encoder models multi-scale historical context. To strengthen the expression of invocation dependencies, the framework introduces a lightweight structural prior into attention computation. This enables more effective capture of load propagation and accumulation along invocation chains, while maintaining consistent modeling of local bursts and overall trends. The training objective adopts a multi-objective regression strategy that jointly optimizes service level and cluster level predictions to improve cross-granularity stability. We further conduct single-factor sensitivity analyses on key structural and training hyperparameters. We systematically examine the effects of time window length, encoding depth, and regularization strength. The results support the necessity of multi-granularity fusion and structural injection and clarify their effective configuration ranges. Overall, the framework provides a reusable modeling paradigm and implementation path for capacity assessment, resource orchestration, and runtime situational understanding in cloud environments.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.22852", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.22852", "abs": "https://arxiv.org/abs/2602.22852", "authors": ["Oliver Larsson", "Thijs Metsch", "Cristian Klein", "Erik Elmroth"], "title": "Workload Buoyancy: Keeping Apps Afloat by Identifying Shared Resource Bottlenecks", "comment": "14 pages, 10 figures, 4 tables", "summary": "Modern multi-tenant, hardware-heterogeneous computing environments pose significant challenges for effective workload orchestration. Simple heuristics for assessing workload performance, such as CPU utilization or application-level metrics, are often insufficient to capture the complex performance dynamics arising from resource contention and noisy-neighbor effects. In such environments, performance bottlenecks may emerge in any shared system resource, leading to unexpected and difficult-to-diagnose degradation.\n  This paper introduces buoyancy, a novel abstraction for characterizing workload performance in multi-tenant systems. Unlike traditional approaches, buoyancy integrates application-level metrics with system-level insights of shared resource contention to provide a holistic view of performance dynamics. By explicitly capturing bottlenecks and headroom across multiple resources, buoyancy facilitates resource-aware and application-aware orchestration in a manner that is intuitive, extensible, and generalizable across heterogeneous platforms. We evaluate buoyancy using representative multi-tenant workloads to illustrate its ability to expose performance-limiting resource interactions. Buoyancy provides a 19.3% better indication of bottlenecks compared to traditional heuristics on average. We additionally show how buoyancy can act as a drop-in replacement for conventional performance metrics, enabling improved observability and more informed scheduling and optimization decisions.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
