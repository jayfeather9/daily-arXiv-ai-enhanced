<div id=toc></div>

# Table of Contents

- [cs.DC](#cs.DC) [Total: 1]
- [cs.PL](#cs.PL) [Total: 1]
- [cs.DS](#cs.DS) [Total: 2]


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [1] [Multi-Modal Style Transfer-based Prompt Tuning for Efficient Federated Domain Generalization](https://arxiv.org/abs/2601.05955)
*Yuliang Chen,Xi Lin,Jun Wu,Xiangrui Cai,Qiaolun Zhang,Xichun Fan,Jiapeng Xu,Xiu Su*

Main category: cs.DC

TL;DR: Paper is not related to DSL, graph processing, MLIR, compiler, or HLS. The paper is about Federated Domain Generalization (FDG). Summary: FaST-PT是一种联邦域泛化（FDG）框架。它通过轻量级多模态风格迁移（MST）增强局部特征以扩大数据分布和减轻域偏移，并通过设计双提示模块（分解为全局和域提示）和引入领域感知提示生成（DPG）来实现高效的未见域适应和知识融合。实验证明FaST-PT的性能优于现有的先进FDG方法。


<details>
  <summary>Details</summary>
Motivation: 现有的联邦域泛化（FDG）方法通常难以应对跨客户端数据异构性，并带来显著的通信和计算开销，而FDG的目标是协作训练一个能够很好地泛化到未见域的全局模型。

Method: 1. **轻量级多模态风格迁移（MST）**: 在文本监督下转换图像嵌入，以扩大训练数据分布并减轻域偏移。2. **双提示模块**: 将提示分解为全局提示（捕获来自增强嵌入的通用知识）和域提示（捕获来自局部数据的特定域知识）。3. **领域感知提示生成（DPG）**: 自适应地为每个样本生成合适的提示，通过知识融合促进未见域适应。

Result: 在PACS和DomainNet等四个跨域基准数据集上的广泛实验证明，FaST-PT的性能优于现有的先进FDG方法（如FedDG-GA和DiPrompt）。消融研究进一步验证了FaST-PT的有效性和效率。

Conclusion: FaST-PT是一种新颖的联邦域泛化（FDG）框架，通过轻量级多模态风格迁移进行局部特征增强，并通过双提示模块和领域感知提示生成来实现高效的未见域适应和知识融合。实验证明FaST-PT在跨域基准数据集上性能优于现有的先进FDG方法。

Abstract: Federated Domain Generalization (FDG) aims to collaboratively train a global model across distributed clients that can generalize well on unseen domains. However, existing FDG methods typically struggle with cross-client data heterogeneity and incur significant communication and computation overhead. To address these challenges, this paper presents a new FDG framework, dubbed FaST-PT, which facilitates local feature augmentation and efficient unseen domain adaptation in a distributed manner. First, we propose a lightweight Multi-Modal Style Transfer (MST) method to transform image embedding under text supervision, which could expand the training data distribution and mitigate domain shift. We then design a dual-prompt module that decomposes the prompt into global and domain prompts. Specifically, global prompts capture general knowledge from augmented embedding across clients, while domain prompts capture domain-specific knowledge from local data. Besides, Domain-aware Prompt Generation (DPG) is introduced to adaptively generate suitable prompts for each sample, which facilitates unseen domain adaptation through knowledge fusion. Extensive experiments on four cross-domain benchmark datasets, e.g., PACS and DomainNet, demonstrate the superior performance of FaST-PT over SOTA FDG methods such as FedDG-GA and DiPrompt. Ablation studies further validate the effectiveness and efficiency of FaST-PT.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [2] [Categorical Foundations for CuTe Layouts](https://arxiv.org/abs/2601.05972)
*Jack Carlisle,Jay Shah,Reuben Stern,Paul VanKoughnett*

Main category: cs.PL

TL;DR: 这个论文与编译器、DSL、以及图处理不直接相关，但与高性能计算库（如CUTLASS）中的张量数据布局和操作有关。这与编译器和HLS中的数据表示和优化有间接联系。
总结：NVIDIA CUTLASS库中的CuTe布局及其复杂的代数操作缺乏形式化基础。本文通过定义Tuple和Nest两个范畴，将一类可处理的CuTe布局置于一个严谨的范畴学框架下，并证明了范畴学态射操作与CuTe布局代数操作的兼容性。最后，作者提供了一个Python实现来佐证其理论构建。


<details>
  <summary>Details</summary>
Motivation: CUTLASS库中的CuTe布局（layout）及其复杂的代数操作（如组合、逻辑乘积和逻辑除法）尽管强大，但缺乏一个统一的、形式化的理论基础。本文旨在提供一个范畴学框架，以更清晰、更严谨的方式理解、描述和操作这些多维张量数据布局，尤其关注一类自然出现的可处理布局（tractable layouts）。

Method: 定义了两个范畴：Tuple和Nest，它们的态射（morphisms）用于表示CUTLASS CuTe布局中的一类可处理布局。定义了范畴中的一系列操作，并证明这些操作与CuTe布局代数中的相应操作（组合、逻辑乘积、逻辑除法）是兼容的。提供了一个完整的特征描述，说明了哪些布局可以通过这种范畴学构造产生。通过一个Python实现验证了构造与CUTLASS行为的一致性。

Result: 成功地建立了一个基于范畴学（Tuple和Nest）的框架，用于刻画CUTLASS的CuTe布局代数。证明了范畴学构造中的操作与CuTe布局操作的兼容性。给出了可由该构造产生的布局的完整特征描述。提供了相应的Python实现，验证了理论与CUTLASS行为的一致性。

Conclusion: 本文将CUTLASS库中的CuTe布局及其代数操作（如组合、逻辑乘积和逻辑除法）置于一个范畴学框架下进行理解。通过定义Tuple和Nest两个范畴，并利用它们的态射来表示布局，文章成功地为一类特定的可处理布局建立了一个形式化的数学基础。作者证明了其构造中的态射操作与CuTe布局代数操作的兼容性，并给出了一个完整的特征描述。这为理解、分析和形式化CUTLASS等高性能计算库中的张量数据布局提供了全新的、严谨的视角。

Abstract: NVIDIA's CUTLASS library provides a robust and expressive set of methods for describing and manipulating multi-dimensional tensor data on the GPU. These methods are conceptually grounded in the abstract notion of a CuTe layout and a rich algebra of such layouts, including operations such as composition, logical product, and logical division. In this paper, we present a categorical framework for understanding this layout algebra by focusing on a naturally occurring class of tractable layouts. To this end, we define two categories Tuple and Nest whose morphisms give rise to layouts. We define a suite of operations on morphisms in these categories and prove their compatibility with the corresponding layout operations. Moreover, we give a complete characterization of the layouts which arise from our construction. Finally, we provide a Python implementation of our categorical constructions, along with tests that demonstrate alignment with CUTLASS behavior. This implementation can be found at our git repository https://github.com/ColfaxResearch/layout-categories.

</details>


<div id='cs.DS'></div>

# cs.DS [[Back]](#toc)

### [3] [On the closest pair of points problem](https://arxiv.org/abs/2601.05681)
*Martin Hitz,Michaela Hitz*

Main category: cs.DS

TL;DR: 该论文与图处理（在点云中查找最近点对是计算几何和点云处理中的一个基本问题，点云可以看作是图的一种隐式表示，但并非直接针对图结构的算法）和编译器（在实现和性能测试中使用了 C++ 环境）相关。

该论文基于数学最优堆积理论，提出了两种确定性的、易于实现的最近点对查找算法：cppMM 和 cppAPs。cppMM 在均匀分布点云下证明了 $O(n)$ 的时间复杂度，并且在对大问题规模的实证测试中性能优于其他主流算法；cppAPs 实现简单，经验运行时间极快，但最坏情况时间复杂度为 $O(n^2)$。


<details>
  <summary>Details</summary>
Motivation: 寻找点云中最近点对是计算几何中的一个基本问题。该研究的动机是基于数学最优堆积理论，提出更有效、确定性强、易于实现且具有快速运行时间的最近点对查找算法。

Method: 提出了两种新的、确定性的最近点对算法：cppMM 和 cppAPs，它们基于数学最优堆积理论的发现。理论上，证明了主要算法 cppMM 在均匀分布点云的情况下具有 $O(n)$ 的时间复杂度。将新算法与现有主流算法进行比较，并在 C++ 测试环境中对高达 $n = 33,554,432$ 的点云进行了实证运行时间分析。

Result: 主要算法 cppMM 在均匀分布点云的情况下，被证明具有 $O(n)$ 的时间复杂度，并在实际测试中，对于大型问题规模 $n$，其性能优于其他竞争算法。第二种算法 cppAPs 经验运行时间极快，但最坏情况时间复杂度为 $O(n^2)$。两种算法都是确定性的，易于实现，并且具有快速有效的运行时间。

Conclusion: 我们基于数学最优堆积理论提出了两种新的最近点对查找算法：cppMM 和 cppAPs。cppMM 在均匀分布点云的情况下具有理论上的 $O(n)$ 时间复杂度，并且在实际测试中对于大问题规模 $n$ 表现出优于其他现有算法的性能。cppAPs 虽然实现简单，经验运行时间极快，但其最坏情况时间复杂度为 $O(n^2)$。这两种新算法具有确定性、易于实现和快速有效运行时间的特点。

Abstract: We introduce two novel algorithms for the problem of finding the closest pair in a cloud of $n$ points based on findings from mathematical optimal packing theory. Both algorithms are deterministic, show fast effective runtimes, and are very easy to implement. For our main algorithm, cppMM, we prove $O(n)$ time complexity for the case of uniformly distributed points. Our second algorithm, cppAPs, is almost as simple as the brute-force approach, but exhibits an extremely fast empirical running time, although its worst-case time complexity is also $O(n^2)$. We embed the new algorithms in a review of the most prominent contenders and empirically demonstrate their runtime behavior for problem sizes up to $n =$ 33,554,432 points observed in our C++ test environment. For large $n$, cppMM dominates the other algorithms under study.

</details>


### [4] [Spectral Clustering in Birthday Paradox Time](https://arxiv.org/abs/2601.05883)
*Michael Kapralov,Ekaterina Kochetkova,Weronika Wrzos-Kaminska*

Main category: cs.DS

TL;DR: 该论文与图处理相关。具体来说，它研究了在可聚类图上确定顶点所属聚类的问题，并使用了随机游走和聚类分析等图处理技术。
太长不读：本文针对$(k, \varphi, \varepsilon)$-可聚类图，提出了一种基于对数长度随机游走混合的新型顶点表示方法，实现了最优的$\approx (n/k)^{1/2+O(\varepsilon/\varphi^2)}$查询复杂度，构建了一个与生日悖论界限相匹配的高效聚类预言机，解决了现有研究中查询复杂度与聚类数量$k$的依赖关系不一致的问题。


<details>
  <summary>Details</summary>
Motivation: 现有研究（如$k=2$时的生日悖论现象）表明，查询复杂度应随着聚类数量$k$的增加而降低，预期的复杂度应为$\approx (n/k)^{1/2+O(\varepsilon/\varphi^2)}$。然而，对于一般的$k>2$情况，先前的结果是$\approx \text{poly}(k)\cdot n^{1/2+O(\varepsilon/\varphi^2)}$，这与$k=2$的结果仅相差多项式因子，但与生日悖论所暗示的趋势（查询复杂度随$k$增加而减少）在概念上不一致。因此，本文的动机是设计一种新的方法来实现与生日悖论界限相匹配的最优查询复杂度。

Method: 本文设计了一种新的顶点表示方法，该方法通过日志长度游走的“混合”来表示$(k, \varphi, \varepsilon)$-可聚类图中的顶点。这种表示方法使用了最优数量的随机游走样本 $\approx (n/k)^{1/2+O(\varepsilon/\varphi^2)}$，并允许进行快速的最近邻搜索。具体来说，给定代表$k$个簇的$k$个顶点，可以使用与查询顶点$x$表示大小近似线性的时间找到$x$所属的簇。

Result: 本文提出的顶点表示方法使用了最优的$\approx (n/k)^{1/2+O(\varepsilon/\varphi^2)}$次随机游走样本。基于这种表示，本文设计了一个聚类预言机，其查询时间为$\approx (n/k)^{1/2+O(\varepsilon/\varphi^2)}$，空间复杂度为$k\cdot (n/k)^{1/2+O(\varepsilon/\varphi^2)}$。这个结果与生日悖论所预期的下界相匹配，并且解决了先前研究中查询复杂度和$k$的关系在概念上的不一致性问题。

Conclusion: 本文设计了一种新的顶点表示方法，利用对数长度的随机游走混合来表示$(k, \varphi, \varepsilon)$-可聚类图中的顶点。这种方法实现了最优的查询复杂度，即$\approx (n/k)^{1/2+O(\varepsilon/\varphi^2)}$次随机游走，从而得到了一个具有最优查询时间和空间复杂度的聚类预言机。这解决了先前研究中查询复杂度与聚类数量$k$的依赖关系不一致的问题。

Abstract: Given a vertex in a $(k, \varphi, ε)$-clusterable graph, i.e. a graph whose vertex set can be partitioned into a disjoint union of $\varphi$-expanders of size $\approx n/k$ with outer conductance bounded by $ε$, can one quickly tell which cluster it belongs to? This question goes back to the expansion testing problem of Goldreich and Ron'11. For $k=2$ a sample of $\approx n^{1/2+O(ε/\varphi^2)}$ logarithmic length walks from a given vertex approximately determines its cluster membership by the birthday paradox: two vertices whose random walk samples are `close' are likely in the same cluster.
  The study of the general case $k>2$ was initiated by Czumaj, Peng and Sohler [STOC'15], and the works of Chiplunkar et al. [FOCS'18], Gluch et al. [SODA'21] showed that $\approx \text{poly}(k)\cdot n^{1/2+O(ε/\varphi^2)}$ random walk samples suffice for general $k$. This matches the $k=2$ result up to polynomial factors in $k$, but creates a conceptual inconsistency: if the birthday paradox is the guiding phenomenon, then the query complexity should decrease with the number of clusters $k$! Since clusters have size $\approx n/k$, we expect to need $\approx (n/k)^{1/2+O(ε/\varphi^2)}$ random walk samples, which decreases with $k$.
  We design a novel representation of vertices in a $(k, \varphi, ε)$-clusterable graph by a mixture of logarithmic length walks. This representation uses the optimal $\approx (n/k)^{1/2+O(ε/\varphi^2)}$ walks per vertex, and allows for a fast nearest neighbor search: given $k$ vertices representing the clusters, we can find the cluster of a given query vertex $x$ using nearly linear time in the representation size of $x$. This gives a clustering oracle with query time $\approx (n/k)^{1/2+O(ε/\varphi^2)}$ and space complexity $k\cdot (n/k)^{1/2+O(ε/\varphi^2)}$, matching the birthday paradox bound.

</details>
