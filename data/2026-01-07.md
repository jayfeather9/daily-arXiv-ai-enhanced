<div id=toc></div>

# Table of Contents

- [cs.DC](#cs.DC) [Total: 2]
- [cs.PL](#cs.PL) [Total: 1]
- [cs.DS](#cs.DS) [Total: 2]


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [1] [Proceedings of the 1st International Workshop on Low Carbon Computing (LOCO 2024)](https://arxiv.org/abs/2601.02898)
*Wim Vanderbauwhede,Lauritz Thamsen,José Cano*

Main category: cs.DC

TL;DR: 该论文与编译器、DSL、图处理、MLIR 或 HLS 无直接关系，它是一个会议论文集。
首届国际低碳计算研讨会 (LOCO 2024) 的会议记录。


<details>
  <summary>Details</summary>
Motivation: 本报告的动机是记录和传播首届国际低碳计算研讨会（LOCO 2024）的会议内容和研究成果，以促进低碳计算领域的研究和交流。

Method: 本论文集采用的方法是收集和汇编在首届国际低碳计算研讨会（LOCO 2024）上发表或提交的研究论文和工作成果。

Result: 本论文集的结果是首届国际低碳计算研讨会（LOCO 2024）所有提交和接受的论文的集合，代表了该领域最新的研究进展。具体的学术研究成果蕴含在论文集中的各篇论文中。

Conclusion: 本论文集是首届国际低碳计算研讨会（LOCO 2024）的记录，其结论是会议已成功举办，并收集了与低碳计算相关的研究成果。具体的学术结论需要查阅论文集中的各篇论文。

Abstract: This is the proceedings of the 1st International Workshop on Low Carbon Computing (LOCO 2024).

</details>


### [2] [Software-Defined Agentic Serving](https://arxiv.org/abs/2601.03197)
*Saurabh Agarwal,Marco Laju,Jayanth Srinivasa,Myungjin Lee,Aditya Akella*

Main category: cs.DC

TL;DR: 该论文与 **编译器** 有关，因为它提出了一种新的**服务范式**，涉及到资源的调度和管理，这与编译器优化的目标和手段有相通之处，但更直接的关联点在于**系统感知**和**运行时动态调整**，这在某些高级编译器（如 JIT 编译器）和运行时系统中是核心概念。论文还可能与 **图处理** 有关，因为多智能体 LLM 流水线可以看作是一种计算图。太长不看：随着多智能体 LLM 流水线变得复杂，现有静态的服务范式不再适用。本文提出一个受 SDN 启发的、可编程和具有系统感知能力的智能体服务框架，它能根据运行时状态动态控制通信属性，从而实现服务高效和高响应性，并为未来意图驱动的服务打下基础。


<details>
  <summary>Details</summary>
Motivation: 现有的服务范式无法适应日益复杂的**多智能体 LLM 流水线**及其动态的服务条件。现有服务系统静态地编码参数，缺乏灵活性和系统感知能力。因此，需要一个可编程、具有系统感知能力的智能体服务系统。

Method: 提出了一种新的、受 SDN 启发的智能体服务框架。该框架的核心思想是支持可编程和系统感知能力，能够根据运行时状态动态地控制通信的关键属性。

Result: 所提出的架构能够实现**服务高效（serving-efficient）**和**响应迅速（responsive）**的智能体系统，并为实现**高层意图驱动（high-level intent-driven）**的智能体服务铺平了道路。

Conclusion: 本文提出了一种受 SDN 启发的，可编程、具有系统感知能力的智能体服务框架，它能根据运行时状态动态调整通信的关键属性，克服了现有静态服务范式在处理复杂多智能体 LLM 流水线时的局限性，实现了高效、响应迅速的智能体系统，并为未来实现高层意图驱动的智能体服务奠定了基础。

Abstract: As multi-agent LLM pipelines grow in complexity, existing serving paradigms fail to adapt to the dynamic serving conditions. We argue that agentic serving systems should be programmable and system-aware, unlike existing serving which statically encode the parameters. In this work, we propose a new SDN-inspired agentic serving framework that helps control the key attributes of communication based on runtime state. This architecture enables serving-efficient, responsive agent systems and paves the way for high-level intent-driven agentic serving.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [3] [Backwards Data-Flow Analysis using Prophecy Variable in the BuildIt System](https://arxiv.org/abs/2601.02653)
*Ajay Brahmakshatriya,Saman Amarasinghe,Martin Rinard*

Main category: cs.PL

TL;DR: 该论文与 DSL（领域特定语言）、Compiler（编译器）和 Graph Processing（图处理）相关。其中，BuildIt 是一个轻量级的 DSL 实现系统，利用了分阶段编译技术，并且提出了使用预言变量进行优化，这也是编译器优化的范畴。
太长不看版：为了避免传统的反向程序分析在程序优化和转换中所需的工程开销，本文提出了使用“预言变量”来预测程序未来的执行信息。该方法在轻量级 DSL 实现系统 BuildIt 中实现，BuildIt 利用分阶段编译（将 C++ 代码执行作为第一阶段以生成优化的第二阶段代码）极大地减少了实现 DSL 的工程量。预言变量结合重复的前向执行，使得 BuildIt 能够进行需要未来信息的优化，实验证明了这种方法带来的益处。


<details>
  <summary>Details</summary>
Motivation: 许多程序转换和优化需要未来的程序行为信息，传统上是通过构建中间程序表示和使用反向程序分析来获取，这带来了额外的工程开销。作者的目标是找到一种更轻量级、工程量更小的方法（无需反向分析和相关实现开销）来获取这些未来执行信息，并应用于 DSL 的实现和优化中。

Method: 本文通过提出并使用“预言变量”来预测程序未来执行的信息，以替代传统的反向程序分析来获取进行转换和优化所需的信息。具体实现是在 BuildIt 系统中，该系统利用分阶段编译（staged compilation）和重复的前向程序执行（repeated forward program execution）来支持预言变量。BuildIt 的第一阶段使用标准 C++ 执行来生成优化的 C、C++ 和 CUDA 代码（第二阶段代码），这种方法同时消除了对解析器和中间表示（IR）等组件的需求，从而减少了实现 DSL 的工程工作量。论文还形式化了预言变量的用法，并讨论了其在 BuildIt 中的实现。

Result: 在 BuildIt 中，结合预言变量和重复前向程序执行的方法成功地实现了对需要未来执行信息才能进行的程序转换和优化，而无需传统的反向分析。这种方法极大地降低了实现领域特定语言（DSL）的工程难度。实验结果表明，BuildIt 中受益于预言变量所提供优化信息的计算获得了性能提升。

Conclusion: 本文提出了一种利用预言变量 (prophecy variables) 和重复前向程序执行相结合的方法，在不需要反向分析和相关工程开销的情况下，为程序转换和优化提供未来的执行信息。这种方法在轻量级 DSL 实现系统 BuildIt 中得到了有效的实施，极大地减少了实现 DSL 所需的工程工作量。实验结果也证实了预言变量提供的优化信息所带来的益处。

Abstract: Many program transformations and optimizations require information about the future behavior of the program. A standard way to obtain this information is to build an intermediate program representation, then use a backwards program analysis to propagate relevant information against the flow of control back to the transformation/optimization site. We instead propose to use prophecy variables, which predict information about the future execution of the program, to enable such transformations and optimizations. We implement prophecy variables in BuildIt, a lightweight domain specific language implementation system. BuildIt uses staged compilation to implement high performance domain specific languages embedded within a standard general purpose programming language (C++). The BuildIt first phase uses standard C++ program execution to generate optimized C, C++, and CUDA second phase code. This approach enables BuildIt to eliminate programming language implementation components such as parsers and intermediate representations, delivering a dramatic decrease in the engineering effort required to implement domain specific languages. The combination of prophecy variables and repeated forward program execution enables BuildIt to extend this approach to include transformations and optimizations that require information about the future execution of the program without backwards analyses and without the engineering overhead associated with implementing these analyses. We formalize the use of prophecy variables for this purpose, discuss the implementation of prophecy variables and repeated execution in BuildIt, and present experimental results for BuildIt computations that benefit from optimizations enabled by the information that prophecy variables provide.

</details>


<div id='cs.DS'></div>

# cs.DS [[Back]](#toc)

### [4] [A Practical 73/50 Approximation for Contiguous Monotone Moldable Job Scheduling](https://arxiv.org/abs/2601.02836)
*Klaus Jansen,Felix Ohnesorge*

Main category: cs.DS

TL;DR: This paper is related to graph processing (as scheduling problems often involve job dependencies which can be represented as a graph, though not explicitly mentioned). The paper presents a novel and practically efficient approximation algorithm for monotone moldable job scheduling with an approximation ratio of $\approx (1.4593 + \varepsilon)$ and a time complexity of $O(nm \log \frac{1}{\varepsilon})$, significantly improving upon existing results in terms of efficiency and approximation quality for a broad range of problem instances.


<details>
  <summary>Details</summary>
Motivation: 现有的单调可塑作业调度算法存在效率不足（PTAS的超指数时间复杂度）或近似比不理想（$\frac{3}{2}$近似算法）或适用范围有限（FPAS需要机器数远大于作业数）。因此，需要一种在近似比和时间复杂度之间取得更好平衡的、更实用的高效算法。

Method: 本文提出了一种具有$\approx (1.4593 + \varepsilon)$近似比和$O(nm \log \frac{1}{\varepsilon})$时间复杂度的新算法，并将其应用于单调可塑作业调度问题，包括其连续变体。此外，作者还实现了该算法并对其实际性能进行了评估。

Result: 提出了一种近似比为$\approx (1.4593 + \varepsilon)$的新算法，其时间复杂度为$O(nm \log \frac{1}{\varepsilon})$，这比现有最好的$\frac{3}{2}$近似算法（$O(nm\log(mn))$）更有效率。此外，该算法也适用于问题的连续变体，并且实验表明其实际性能显著优于理论最坏情况近似比。

Conclusion: 本文提出了一种新的、实用的、高效的算法，用于具有$\approx (1.4593 + \varepsilon)$近似比的单调可塑作业调度问题。该算法的时间复杂度为$O(nm \log \frac{1}{\varepsilon})$，显著优于现有算法。研究还表明，该算法的实际性能远优于其理论最坏情况近似比。

Abstract: In moldable job scheduling, we are provided $m$ identical machines and $n$ jobs that can be executed on a variable number of machines. The execution time of each job depends on the number of machines assigned to execute that job. For the specific problem of monotone moldable job scheduling, jobs are assumed to have a processing time that is non-increasing in the number of machines.
  The previous best-known algorithms are: (1) a polynomial-time approximation scheme with time complexity $Ω(n^{g(1/\varepsilon)})$, where $g(\cdot)$ is a super-exponential function [Jansen and Thöle '08; Jansen and Land '18], (2) a fully polynomial approximation scheme for the case of $m \geq 8\frac{n}{\varepsilon}$ [Jansen and Land '18], and (3) a $\frac{3}{2}$ approximation with time complexity $O(nm\log(mn))$ [Wu, Zhang, and Chen '23].
  We present a new practically efficient algorithm with an approximation ratio of $\approx (1.4593 + \varepsilon)$ and a time complexity of $O(nm \log \frac{1}{\varepsilon})$. Our result also applies to the contiguous variant of the problem. In addition to our theoretical results, we implement the presented algorithm and show that the practical performance is significantly better than the theoretical worst-case approximation ratio.

</details>


### [5] [Hardness of Regular Expression Matching with Extensions](https://arxiv.org/abs/2601.03020)
*Taisei Nogami,Tachio Terauchi*

Main category: cs.DS

TL;DR: 这个论文与图处理（通过 $k$-团猜想）和编译器（正则表达式通常用于词法分析）相关，但不直接与 DSL、MLIR 或 HLS 相关。

该研究分析了带有反向引用、交集和补集等扩展的正则表达式匹配问题的计算复杂性。基于理论猜想（如正交向量猜想和 $k$-团猜想），文章证明了这些扩展的匹配问题不可能被显著快于已知算法的多项式时间算法所解决。特别是，扩展正则表达式（ERE，即带补集的）的匹配算法 $O(n^\omega m)$ 在 $n$ 方面被证明是近乎最优的，从而解释了为何在过去 45 年中，该领域的优化努力举步维艰。


<details>
  <summary>Details</summary>
Motivation: 正则表达式是文本处理中的核心工具，但其扩展（如反向引用、交集和补集）在理论上的计算复杂性尚未得到充分理解，尤其是与常用于实际应用且已证明可有效解决的先行断言（lookaround）扩展相比。本文的动机在于量化和理解这些关键扩展（反向引用、交集和补集）对正则表达式匹配问题时间复杂度的影响和理论下界，并解释为何在优化扩展正则表达式（ERE）匹配算法方面长期停滞不前。

Method: 本文首先回顾了标准正则表达式匹配的 $O(nm)$ 时间复杂度和带先行断言（lookaround）的正则表达式的匹配时间复杂性。然后，通过计算复杂性理论的归约方法（基于正交向量猜想、k-团猜想和组合 k-团猜想）来证明三种特定扩展（反向引用、交集和补集）的正则表达式匹配问题的硬度界限。本文的分析侧重于证明在不满足这些计算复杂性猜想的前提下，不可能有显著快于现有算法的匹配算法。

Result: 1. 对于带有反向引用（即使限制为一个捕获组）、交集或补集三种扩展中的任何一种的正则表达式匹配问题，在正交向量猜想下，不存在 $O(n^{2-\varepsilon} \mathrm{poly}(m))$ 时间的算法。 2. 对于扩展正则表达式（ERE，即带补集的正则表达式），在 $k$-团猜想下，不存在 $O(n^{\omega-\varepsilon} \mathrm{poly}(m))$ 时间的算法（其中 $\omega$ 是矩阵乘法的指数）。 3. 对于 ERE 匹配，在组合 $k$-团猜想下，不存在 $O(n^{3-\varepsilon} \mathrm{poly}(m))$ 时间的纯组合算法。这些结果表明，\[\text{Hopcroft 和 Ullman (1979) 的 } O(n^3 m) \text{ 算法以及 Bille 等人最近改进的 } O(n^\omega m) \text{ 算法（使用快速矩阵乘法）在某种意义上已经是最优的。}\]

Conclusion: 本文通过理论分析和假设证明了，对于带有反向引用、交集和补集这三种扩展的正则表达式匹配问题，不可能存在显著优于当前已知算法的多项式时间算法，这基于正交向量猜想（OV）、$k$-团猜想和组合 $k$-团猜想。这为理解正则表达式匹配（特别是扩展正则表达式匹配）的理论复杂性界限提供了重要的洞察。这些结果解释了为什么在过去 45 年中，改善扩展正则表达式匹配算法的时间复杂度的努力一直很困难。

Abstract: The regular expression matching problem asks whether a given regular expression of length $m$ matches a given string of length $n$. As is well known, the problem can be solved in $O(nm)$ time using Thompson's algorithm. Moreover, recent studies have shown that the matching problem for regular expressions extended with a practical extension called lookaround can be solved in the same time complexity. In this work, we consider three well-known extensions to regular expressions called backreference, intersection and complement, and we show that, unlike in the case of lookaround, the matching problem for regular expressions extended with any of the three (for backreference, even when restricted to one capturing group) cannot be solved in $O(n^{2-\varepsilon} \mathrm{poly}(m))$ time for any constant $\varepsilon > 0$ under the Orthogonal Vectors Conjecture. Moreover, we study the matching problem for regular expressions extended with complement in more detail, which is also known as extended regular expression (ERE) matching. We show that there is no ERE matching algorithm that runs in $O(n^{ω-\varepsilon} \mathrm{poly}(m))$ time ($2 \le ω< 2.3716$ is the exponent of square matrix multiplication) for any constant $\varepsilon > 0$ under the $k$-Clique Hypothesis, and there is no combinatorial ERE matching algorithm that runs in $O(n^{3-\varepsilon} \mathrm{poly}(m))$ time for any constant $\varepsilon > 0$ under the Combinatorial $k$-Clique Hypothesis. This shows that the $O(n^3 m)$-time algorithm introduced by Hopcroft and Ullman in 1979 and recently improved by Bille et al. to run in $O(n^ωm)$ time using fast matrix multiplication was already optimal in a sense, and sheds light on why the theoretical computer science community has struggled to improve the time complexity of ERE matching with respect to $n$ and $m$ for more than 45 years.

</details>
