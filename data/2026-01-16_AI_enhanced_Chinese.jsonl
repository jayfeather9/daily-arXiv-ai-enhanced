{"id": "2601.09808", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.09808", "abs": "https://arxiv.org/abs/2601.09808", "authors": ["Chen Ling", "Yachen Wang"], "title": "From Dynamic to Lexical: A Comparative Exploration of Scoping Rules in SAS and R", "comment": "This paper was originally published in the SESUG 2025 Conference Proceedings. Cary, NC", "summary": "Variable scoping dictates how and where variables are accessible within programming languages, playing a crucial role in code efficiency and organization. This paper examines the distinct scoping rules in SAS and R, focusing on SAS's dynamic scoping and R's lexical scoping. In SAS, dynamic scoping utilizes symbol tables, resolving variables at runtime by dynamically searching through active macro layers. R, in contrast, employs lexical scoping, using environments to resolve variables based on the structure in which functions are defined. Illustrative examples highlight the differences between these scoping strategies, showcasing their impact on code behavior. Additionally, the paper outlines methods for inspecting variables in SAS's symbol tables and R's environments, offering practical insights for debugging and optimization. Strategies for controlling variable scope in both languages are discussed, enhancing code precision and reliability. This exploration equips programmers with critical understanding to optimize variable management, improving their programming practices in SAS and R.", "AI": {"tldr": "\u8fd9\u4e2a\u8bba\u6587**\u4e0d\u76f8\u5173**\u4e8eDSL\u3001\u56fe\u5904\u7406\u3001MLIR\u3001\u7f16\u8bd1\u5668\u6216HLS\u3002\nTLDR: \u672c\u6587\u5206\u6790\u548c\u6bd4\u8f83\u4e86\u7f16\u7a0b\u8bed\u8a00SAS\u7684\u52a8\u6001\u4f5c\u7528\u57df\uff08\u57fa\u4e8e\u7b26\u53f7\u8868\uff0c\u8fd0\u884c\u65f6\u641c\u7d22\uff09\u548cR\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\uff08\u57fa\u4e8e\u73af\u5883\uff0c\u57fa\u4e8e\u51fd\u6570\u5b9a\u4e49\uff09\uff0c\u901a\u8fc7\u793a\u4f8b\u8bf4\u660e\u4e86\u5b83\u4eec\u5bf9\u4ee3\u7801\u884c\u4e3a\u7684\u5f71\u54cd\uff0c\u5e76\u63d0\u51fa\u4e86\u5728\u4e24\u79cd\u8bed\u8a00\u4e2d\u68c0\u67e5\u548c\u63a7\u5236\u53d8\u91cf\u4f5c\u7528\u57df\u4ee5\u4f18\u5316\u7f16\u7a0b\u5b9e\u8df5\u7684\u65b9\u6cd5\u548c\u7b56\u7565\u3002", "motivation": "\u53d8\u91cf\u4f5c\u7528\u57df\u662f\u7f16\u7a0b\u8bed\u8a00\u4e2d\u51b3\u5b9a\u53d8\u91cf\u53ef\u8bbf\u95ee\u6027\u548c\u8303\u56f4\u7684\u6838\u5fc3\u673a\u5236\uff0c\u5bf9\u4ee3\u7801\u6548\u7387\u548c\u7ec4\u7ec7\u81f3\u5173\u91cd\u8981\u3002\u672c\u6587\u7684\u52a8\u673a\u662f\u6df1\u5165\u6bd4\u8f83SAS\u7684\u52a8\u6001\u4f5c\u7528\u57df\u548cR\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\uff0c\u5e2e\u52a9\u7a0b\u5e8f\u5458\u7406\u89e3\u8fd9\u4e9b\u4f5c\u7528\u57df\u7b56\u7565\u7684\u533a\u522b\u53ca\u5176\u5bf9\u4ee3\u7801\u884c\u4e3a\u7684\u5f71\u54cd\uff0c\u4ece\u800c\u4f18\u5316\u53d8\u91cf\u7ba1\u7406\uff0c\u63d0\u5347\u7f16\u7a0b\u5b9e\u8df5\u3002", "method": "\u672c\u6587\u901a\u8fc7\u5bf9\u6bd4\u5206\u6790SAS\uff08\u52a8\u6001\u4f5c\u7528\u57df\uff0c\u4f7f\u7528\u7b26\u53f7\u8868\u5e76\u5728\u8fd0\u884c\u65f6\u52a8\u6001\u641c\u7d22\u6d3b\u52a8\u7684\u5b8f\u5c42\uff09\u548cR\uff08\u8bcd\u6cd5\u4f5c\u7528\u57df\uff0c\u4f7f\u7528\u73af\u5883\u5e76\u5728\u51fd\u6570\u5b9a\u4e49\u7ed3\u6784\u7684\u57fa\u7840\u4e0a\u89e3\u6790\u53d8\u91cf\uff09\u7684\u4f5c\u7528\u57df\u89c4\u5219\uff0c\u5e76\u901a\u8fc7\u5b9e\u4f8b\u8fdb\u884c\u8bf4\u660e\u3002\u6b64\u5916\uff0c\u6587\u7ae0\u8fd8\u4ecb\u7ecd\u4e86\u5728SAS\u7684\u7b26\u53f7\u8868\u548cR\u7684\u73af\u5883\u4e2d\u68c0\u67e5\u53d8\u91cf\u7684\u65b9\u6cd5\uff0c\u4ee5\u53ca\u5728\u4e24\u79cd\u8bed\u8a00\u4e2d\u63a7\u5236\u53d8\u91cf\u4f5c\u7528\u57df\u7684\u7b56\u7565\u3002", "result": "\u672c\u6587\u6e05\u6670\u5730\u754c\u5b9a\u4e86SAS\u7684\u52a8\u6001\u4f5c\u7528\u57df\uff08\u57fa\u4e8e\u7b26\u53f7\u8868\uff0c\u8fd0\u884c\u65f6\u52a8\u6001\u641c\u7d22\uff09\u548cR\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\uff08\u57fa\u4e8e\u73af\u5883\uff0c\u57fa\u4e8e\u51fd\u6570\u5b9a\u4e49\u7ed3\u6784\u89e3\u6790\u53d8\u91cf\uff09\u7684\u533a\u522b\uff0c\u5e76\u901a\u8fc7\u5b9e\u4f8b\u5c55\u793a\u4e86\u8fd9\u4e9b\u5dee\u5f02\u5bf9\u4ee3\u7801\u884c\u4e3a\u7684\u5177\u4f53\u5f71\u54cd\u3002\u6587\u7ae0\u8fd8\u63d0\u4f9b\u4e86\u5728\u4e24\u79cd\u8bed\u8a00\u4e2d\u68c0\u67e5\u53d8\u91cf\u4f5c\u7528\u57df\uff08\u5982\u5728SAS\u4e2d\u68c0\u67e5\u7b26\u53f7\u8868\uff0c\u5728R\u4e2d\u68c0\u67e5\u73af\u5883\uff09\u4ee5\u53ca\u63a7\u5236\u53d8\u91cf\u4f5c\u7528\u57df\u7684\u5b9e\u7528\u65b9\u6cd5\u548c\u7b56\u7565\u3002", "conclusion": "\u672c\u6587\u5bf9\u6bd4\u4e86SAS\u7684\u52a8\u6001\u4f5c\u7528\u57df\u548cR\u7684\u8bcd\u6cd5\u4f5c\u7528\u57df\uff0c\u5e76\u901a\u8fc7\u5b9e\u4f8b\u8bf4\u660e\u4e86\u5b83\u4eec\u5bf9\u4ee3\u7801\u884c\u4e3a\u7684\u5f71\u54cd\u3002\u6587\u7ae0\u8fd8\u63d0\u4f9b\u4e86\u5728\u4e24\u79cd\u8bed\u8a00\u4e2d\u68c0\u67e5\u548c\u63a7\u5236\u53d8\u91cf\u4f5c\u7528\u57df\u7684\u65b9\u6cd5\u548c\u7b56\u7565\uff0c\u65e8\u5728\u5e2e\u52a9\u7a0b\u5e8f\u5458\u4f18\u5316\u53d8\u91cf\u7ba1\u7406\uff0c\u63d0\u9ad8\u7f16\u7a0b\u6548\u7387\u548c\u4ee3\u7801\u53ef\u9760\u6027\u3002"}}
{"id": "2601.09839", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.09839", "abs": "https://arxiv.org/abs/2601.09839", "authors": ["Chen Ling", "Yachen Wang"], "title": "Lazy Evaluation: A Comparative Analysis of SAS MACROs and R Functions", "comment": "This paper was originally published in SESUG 2025 Conference Proceedings. Cary, NC: SouthEast SAS Users Group", "summary": "Lazy evaluation is a powerful technique that can optimize code execution by deferring evaluations until their results are required, thus enhancing efficiency. In most modern programming languages, like R, lazy evaluation is commonly applied to function arguments. However, the application of lazy evaluation in SAS has not been extensively explored. This paper focuses on the mechanisms of lazy evaluation in SAS MACROs and R functions, offering a comparative analysis of the underlying principles that drive these processes.\n  R's lazy evaluation is driven by a data structure called Promise, which postpones evaluation and does not occupy memory until the value is needed, utilizing a call-by-need strategy. SAS, on the other hand, achieves lazy evaluation through its symbol tables, employing memory to store parameters, and operates on a call-by-name basis. These discrepancies in lazy evaluation strategies can notably impact the results of R functions and SAS MACROs. By examining these distinct approaches, the paper illuminates the impact of lazy evaluation on programming efficiency, supported by illustrative examples. As the shift from SAS to R becomes increasingly prevalent in the pharmaceutical industry, understanding these techniques enables programmers to optimize their code for greater efficacy. This exploration serves as a guide to enhance programming capabilities and performance in both languages.", "AI": {"tldr": "\u672c\u6587\u4e0e DSL\u3001\u56fe\u5904\u7406\u3001MLIR\u3001\u7f16\u8bd1\u5668\u6216 HLS \u65e0\u5173\u3002\n\n\u60f0\u6027\u6c42\u503c\u662f\u4e00\u79cd\u53ef\u4ee5\u4f18\u5316\u4ee3\u7801\u6267\u884c\u6548\u7387\u7684\u5f3a\u5927\u6280\u672f\uff0c\u5728 R \u7b49\u73b0\u4ee3\u7f16\u7a0b\u8bed\u8a00\u4e2d\u5e38\u7528\u4e8e\u51fd\u6570\u53c2\u6570\u3002\u672c\u6587\u9996\u6b21\u6df1\u5165\u63a2\u8ba8\u5e76\u6bd4\u8f83\u4e86 R \u51fd\u6570\uff08\u57fa\u4e8e Promise\uff0c\u6309\u9700\u8c03\u7528\uff09\u548c SAS MACROs\uff08\u57fa\u4e8e\u7b26\u53f7\u8868\uff0c\u6309\u540d\u8c03\u7528\uff09\u4e2d\u7684\u60f0\u6027\u6c42\u503c\u673a\u5236\u3002\u901a\u8fc7\u5206\u6790\u5b83\u4eec\u5728\u5185\u5b58\u4f7f\u7528\u548c\u6c42\u503c\u7b56\u7565\u4e0a\u7684\u5dee\u5f02\uff0c\u672c\u6587\u9610\u660e\u4e86\u5176\u5bf9\u7a0b\u5e8f\u6027\u80fd\u548c\u7ed3\u679c\u7684\u5f71\u54cd\uff0c\u65e8\u5728\u5e2e\u52a9\u7a0b\u5e8f\u5458\u5728\u5236\u836f\u884c\u4e1a\u7b49\u9886\u57df\u52a0\u901f\u4ece SAS \u5411 R \u7684\u8fc7\u6e21\uff0c\u4ece\u800c\u4f18\u5316\u4ee3\u7801\u4ee5\u63d0\u9ad8\u6548\u7387\u548c\u6027\u80fd\u3002", "motivation": "\u60f0\u6027\u6c42\u503c\u662f\u4e00\u79cd\u5f3a\u5927\u7684\u4ee3\u7801\u4f18\u5316\u6280\u672f\uff0c\u5b83\u901a\u8fc7\u5ef6\u8fdf\u6c42\u503c\u76f4\u5230\u7ed3\u679c\u88ab\u9700\u8981\u65f6\u624d\u8fdb\u884c\uff0c\u4ece\u800c\u63d0\u9ad8\u6267\u884c\u6548\u7387\u3002\u7136\u800c\uff0c\u60f0\u6027\u6c42\u503c\u5728 SAS \u4e2d\u7684\u5e94\u7528\u5c1a\u672a\u5f97\u5230\u5e7f\u6cdb\u63a2\u7d22\u3002\u9274\u4e8e\u5236\u836f\u884c\u4e1a\u7b49\u9886\u57df\u6b63\u52a0\u901f\u4ece SAS \u5411 R \u7684\u8f6c\u53d8\uff0c\u7406\u89e3\u8fd9\u4e24\u79cd\u8bed\u8a00\u4e2d\u60f0\u6027\u6c42\u503c\u7684\u673a\u5236\u5bf9\u4e8e\u7a0b\u5e8f\u5458\u4f18\u5316\u4ee3\u7801\u3001\u63d0\u5347\u7f16\u7a0b\u80fd\u529b\u81f3\u5173\u91cd\u8981\u3002", "method": "\u672c\u6587\u91c7\u7528\u6bd4\u8f83\u5206\u6790\u7684\u65b9\u6cd5\uff0c\u5bf9 R \u8bed\u8a00\u4e2d\u57fa\u4e8e Promise\uff08\u5ef6\u8fdf\u6c42\u503c\u3001\u6309\u9700\u8c03\u7528\uff09\u548c SAS \u5b8f\u4e2d\u57fa\u4e8e\u7b26\u53f7\u8868\uff08\u5b58\u50a8\u53c2\u6570\u3001\u6309\u540d\u8c03\u7528\uff09\u7684\u60f0\u6027\u6c42\u503c\u673a\u5236\u8fdb\u884c\u4e86\u8be6\u7ec6\u7684\u63a2\u8ba8\u548c\u5bf9\u6bd4\uff0c\u5e76\u901a\u8fc7\u5b9e\u4f8b\u8bf4\u660e\u4e86\u8fd9\u4e9b\u5dee\u5f02\u5bf9\u7a0b\u5e8f\u6548\u7387\u548c\u7ed3\u679c\u7684\u5f71\u54cd\u3002", "result": "R \u8bed\u8a00\u7684\u60f0\u6027\u6c42\u503c\u7531 Promise \u6570\u636e\u7ed3\u6784\u9a71\u52a8\uff0c\u91c7\u7528\u201c\u6309\u9700\u8c03\u7528\u201d\uff08call-by-need\uff09\u7b56\u7565\uff0c\u5ef6\u8fdf\u6c42\u503c\u4e14\u5728\u9700\u8981\u524d\u4e0d\u5360\u7528\u5185\u5b58\uff1b\u800c SAS \u901a\u8fc7\u7b26\u53f7\u8868\u5b9e\u73b0\u60f0\u6027\u6c42\u503c\uff0c\u91c7\u7528\u201c\u6309\u540d\u8c03\u7528\u201d\uff08call-by-name\uff09\u7b56\u7565\uff0c\u5c06\u53c2\u6570\u5b58\u50a8\u5728\u5185\u5b58\u4e2d\u3002\u8fd9\u4e9b\u7b56\u7565\u4e0a\u7684\u5dee\u5f02\u4f1a\u5bf9 R \u51fd\u6570\u548c SAS \u5b8f\u7684\u6267\u884c\u7ed3\u679c\u4ea7\u751f\u663e\u8457\u5f71\u54cd\u3002\u7406\u89e3\u8fd9\u4e9b\u5dee\u5f02\u6709\u52a9\u4e8e\u63d0\u5347\u7f16\u7a0b\u6548\u7387\u548c\u6027\u80fd\u3002", "conclusion": "\u672c\u6587\u901a\u8fc7\u5bf9 R \u548c SAS \u5b8f\u4e2d\u60f0\u6027\u6c42\u503c\u673a\u5236\u7684\u6bd4\u8f83\u5206\u6790\uff0c\u63ed\u793a\u4e86\u4e24\u79cd\u8bed\u8a00\u5728\u60f0\u6027\u6c42\u503c\u7b56\u7565\u4e0a\u7684\u5dee\u5f02\u53ca\u5176\u5bf9\u7a0b\u5e8f\u6267\u884c\u6548\u7387\u548c\u7ed3\u679c\u7684\u5f71\u54cd\u3002\u672c\u6587\u7684\u89c1\u89e3\u65e8\u5728\u5e2e\u52a9\u7a0b\u5e8f\u5458\u5728\u5236\u836f\u884c\u4e1a\u7b49\u9886\u57df\u52a0\u901f\u4ece SAS \u5230 R \u7684\u8fc7\u6e21\uff0c\u63d0\u5347\u5728\u8fd9\u4e24\u79cd\u8bed\u8a00\u4e2d\u7684\u7f16\u7a0b\u80fd\u529b\u548c\u6027\u80fd\u3002"}}
{"id": "2601.09986", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2601.09986", "abs": "https://arxiv.org/abs/2601.09986", "authors": ["Cheng Zhang", "Qiancheng Fu", "Hang Ji", "Ines Santacruz Del Valle", "Alexandra Silva", "Marco Gaboardi"], "title": "Outrunning Big KATs: Efficient Decision Procedures for Variants of GKAT", "comment": "Conditionally Accepted at ESOP 2026", "summary": "This paper presents several efficient decision procedures for trace equivalence of GKAT automata, which make use of on-the-fly symbolic techniques via SAT solvers. To demonstrate applicability of our algorithms, we designed symbolic derivatives for CF-GKAT, a practical system based on GKAT designed to validate control-flow transformations. We implemented the algorithms in Rust and evaluated them on both randomly generated benchmarks and real-world control-flow transformations. Indeed, we observed order-of-magnitude performance improvements against existing implementations for both KAT and CF-GKAT. Notably, our experiments also revealed a bug in Ghidra, an industry-standard decompiler, highlighting the practical viability of these systems.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e\u7f16\u8bd1\u5668\uff08\u901a\u8fc7\u63a7\u5236\u6d41\u8f6c\u6362\u7684\u9a8c\u8bc1\uff09\u3001\u56fe\u5904\u7406\uff08\u81ea\u52a8\u673a\u548c\u7b49\u4ef7\u6027\u5224\u65ad\uff09\u76f8\u5173\u3002\n\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u51e0\u79cd\u5229\u7528\u201c\u5373\u65f6\u201d\u7b26\u53f7\u6280\u672f\u548cSAT\u6c42\u89e3\u5668\u5bf9GKAT\uff08Generalized Kleene Algebra with Tests\uff09\u81ea\u52a8\u673a\u8fdb\u884c\u8ff9\u7b49\u4ef7\u6027\uff08trace equivalence\uff09\u5224\u65ad\u7684\u9ad8\u6548\u51b3\u7b56\u8fc7\u7a0b\uff0c\u5e76\u8bbe\u8ba1\u4e86\u7528\u4e8e\u9a8c\u8bc1\u63a7\u5236\u6d41\u8f6c\u6362\u7684\u5b9e\u7528\u7cfb\u7edfCF-GKAT\u7684\u7b26\u53f7\u5bfc\u6570\u3002\u4f5c\u8005\u4f7f\u7528Rust\u5b9e\u73b0\u4e86\u8fd9\u4e9b\u7b97\u6cd5\u5e76\u5728\u968f\u673a\u751f\u6210\u548c\u771f\u5b9e\u4e16\u754c\u7684\u57fa\u51c6\u4e0a\u8fdb\u884c\u4e86\u8bc4\u4f30\uff0c\u7ed3\u679c\u663e\u793a\u6027\u80fd\u6bd4\u73b0\u6709\u5b9e\u73b0\u63d0\u9ad8\u4e86\u6570\u91cf\u7ea7\uff0c\u5e76\u4e14\u6210\u529f\u53d1\u73b0\u4e86\u4e00\u4e2a\u884c\u4e1a\u6807\u51c6\u53cd\u7f16\u8bd1\u5668Ghidra\u4e2d\u7684\u9519\u8bef\uff0c\u7a81\u663e\u4e86\u8be5\u65b9\u6cd5\u7684\u5b9e\u7528\u6027\u3002", "motivation": "\u73b0\u6709\u7684GKAT\u81ea\u52a8\u673a\u7b49\u4ef7\u6027\u5224\u65ad\u65b9\u6cd5\u53ef\u80fd\u6548\u7387\u4e0d\u591f\u9ad8\uff0c\u56e0\u6b64\u9700\u8981\u5f00\u53d1\u66f4\u9ad8\u6548\u7684\u51b3\u7b56\u8fc7\u7a0b\u3002\u540c\u65f6\uff0c\u9700\u8981\u8bc1\u660e\u8fd9\u4e9b\u9ad8\u6548\u51b3\u7b56\u8fc7\u7a0b\u5728\u5904\u7406\u5b9e\u9645\u7cfb\u7edf\u4e2d\u7684\u63a7\u5236\u6d41\u8f6c\u6362\u95ee\u9898\u7684\u6709\u6548\u6027\u548c\u5b9e\u7528\u6027\u3002", "method": "\u672c\u6587\u65b9\u6cd5\u57fa\u4e8e\u5bf9GKAT\u81ea\u52a8\u673a\u7684\u7b49\u4ef7\u6027\u5224\u65ad\uff0c\u6838\u5fc3\u5728\u4e8e\u5229\u7528\u201c\u5373\u65f6\u201d\u7684\u7b26\u53f7\u6280\u672f\u5e76\u7ed3\u5408SAT\u6c42\u89e3\u5668\u3002\u4e3a\u4e86\u5e94\u7528\u4e8e\u5b9e\u9645\u7cfb\u7edf\uff0c\u4f5c\u8005\u8bbe\u8ba1\u4e86CF-GKAT\uff08\u4e00\u79cd\u57fa\u4e8eGKAT\u7684\u5b9e\u7528\u7cfb\u7edf\uff09\u7684\u7b26\u53f7\u5bfc\u6570\uff0c\u5e76\u4f7f\u7528Rust\u8bed\u8a00\u5b9e\u73b0\u8fd9\u4e9b\u7b97\u6cd5\u3002", "result": "\u672c\u6587\u63d0\u51fa\u7684\u7b97\u6cd5\u5728\u6027\u80fd\u4e0a\u53d6\u5f97\u4e86\u663e\u8457\u7684\u63d0\u5347\uff0c\u76f8\u5bf9\u4e8e\u73b0\u6709\u7684KAT\u548cCF-GKAT\u5b9e\u73b0\uff0c\u89c2\u5bdf\u5230\u4e86\u63d0\u9ad8\u4e86\u6570\u91cf\u7ea7\u7684\u6027\u80fd\u6539\u8fdb\u3002\u6b64\u5916\uff0c\u901a\u8fc7\u5b9e\u9645\u5e94\u7528\uff0c\u53d1\u73b0\u4e86\u884c\u4e1a\u6807\u51c6\u53cd\u7f16\u8bd1\u5668Ghidra\u4e2d\u7684\u4e00\u4e2a\u9519\u8bef\uff0c\u8bc1\u660e\u4e86\u8fd9\u4e9b\u7cfb\u7edf\u7684\u5b9e\u7528\u6027\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u901a\u8fc7\u5229\u7528\u7b26\u53f7\u6280\u672f\u548cSAT\u6c42\u89e3\u5668\u5bf9GKAT\u81ea\u52a8\u673a\u8fdb\u884c\u7b49\u4ef7\u6027\u5224\u65ad\u7684\u9ad8\u6548\u51b3\u7b56\u8fc7\u7a0b\u3002\u8fd9\u5e26\u6765\u4e86\u6bd4\u73b0\u6709\u5b9e\u73b0\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\uff0c\u5e76\u4e14\u8bc1\u660e\u4e86\u8fd9\u79cd\u65b9\u6cd5\u5728\u5b9e\u9645\u5e94\u7528\u4e2d\u7684\u6709\u6548\u6027\uff0c\u751a\u81f3\u53ef\u4ee5\u53d1\u73b0\u884c\u4e1a\u6807\u51c6\u8f6f\u4ef6\u4e2d\u7684\u9519\u8bef\u3002"}}
{"id": "2601.09773", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2601.09773", "abs": "https://arxiv.org/abs/2601.09773", "authors": ["Binglei Lou", "Ruilin Wu", "Philip Leong"], "title": "Enhancing LUT-based Deep Neural Networks Inference through Architecture and Connectivity Optimization", "comment": "arXiv admin note: substantial text overlap with arXiv:2503.12829, arXiv:2406.04910", "summary": "Deploying deep neural networks (DNNs) on resource-constrained edge devices such as FPGAs requires a careful balance among latency, power, and hardware resource usage, while maintaining high accuracy. Existing Lookup Table (LUT)-based DNNs -- such as LogicNets, PolyLUT, and NeuraLUT -- face two critical challenges: the exponential growth of LUT size and inefficient random sparse connectivity. This paper presents SparseLUT, a comprehensive framework that addresses these challenges through two orthogonal optimizations. First, we propose an architectural enhancement that aggregates multiple PolyLUT sub-neurons via an adder, significantly reducing LUT consumption by 2.0x-13.9x and lowering inference latency by 1.2x-1.6x, all while maintaining comparable accuracy. Building upon this foundation, we further introduce a non-greedy training algorithm that optimizes neuron connectivity by selectively pruning less significant inputs and strategically regrowing more effective ones. This training optimization, which incurs no additional area and latency overhead, delivers consistent accuracy improvements across benchmarks -- achieving up to a 2.13% gain on MNIST and 0.94% on Jet Substructure Classification compared to existing LUT-DNN approaches.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e**DSL**\uff08\u65e0\uff09\u3001**Graph Processing**\uff08\u65e0\uff09\u3001**MLIR**\uff08\u65e0\uff09\u3001**Compiler**\uff08\u65e0\uff09\u3001**HLS**\uff08\u65e0\uff09\u3001**FPGA**\uff08\u6709\uff0c\u6d89\u53caDNN\u5728FPGA\u4e0a\u7684\u90e8\u7f72\uff09\u76f8\u5173\u3002\n\nSparseLUT \u63d0\u51fa\u4e86\u4e00\u4e2a\u7528\u4e8e\u57fa\u4e8e\u67e5\u627e\u8868\uff08LUT-based\uff09DNN\u7684\u5168\u9762\u6846\u67b6\uff0c\u901a\u8fc7\u805a\u5408\u591a\u4e2a PolyLUT \u5b50\u795e\u7ecf\u5143\uff08\u67b6\u6784\u4f18\u5316\uff09\u548c\u975e\u8d2a\u5a6a\u7684\u8fde\u63a5\u7a00\u758f\u6027\u8bad\u7ec3\u7b97\u6cd5\uff08\u8bad\u7ec3\u4f18\u5316\uff09\uff0c\u89e3\u51b3\u4e86\u73b0\u6709 LUT-DNN \u5b58\u5728\u7684 LUT \u5c3a\u5bf8\u6307\u6570\u589e\u957f\u548c\u4f4e\u6548\u7a00\u758f\u8fde\u63a5\u95ee\u9898\u3002\u7ed3\u679c\u663e\u793a\uff0cSparseLUT \u5728\u4fdd\u6301\u6216\u63d0\u9ad8\u51c6\u786e\u6027\u7684\u540c\u65f6\uff0c\u663e\u8457\u51cf\u5c11\u4e86 LUT \u6d88\u8017\uff08\u6700\u9ad8 13.9 \u500d\uff09\u548c\u63a8\u7406\u5ef6\u8fdf\uff08\u6700\u9ad8 1.6 \u500d\uff09\uff0c\u4e3a\u8d44\u6e90\u53d7\u9650\u7684\u8fb9\u7f18\u8bbe\u5907\u4e0a\u7684\u9ad8\u6548 DNN \u90e8\u7f72\u63d0\u4f9b\u4e86\u89e3\u51b3\u65b9\u6848\u3002", "motivation": "\u73b0\u6709\u57fa\u4e8e\u67e5\u627e\u8868\uff08LUT\uff09\u7684DNN\uff08\u5982LogicNets, PolyLUT, NeuraLUT\uff09\u5728\u90e8\u7f72\u5230\u8d44\u6e90\u53d7\u9650\u7684FPGA\u7b49\u8fb9\u7f18\u8bbe\u5907\u65f6\uff0c\u9762\u4e34\u4e24\u4e2a\u5173\u952e\u6311\u6218\uff1aLUT\u5c3a\u5bf8\u5448\u6307\u6570\u589e\u957f\u548c\u968f\u673a\u7a00\u758f\u8fde\u63a5\u6548\u7387\u4f4e\u4e0b\u3002\u672c\u6587\u65e8\u5728\u5f00\u53d1\u4e00\u4e2a\u5168\u9762\u7684\u6846\u67b6SparseLUT\uff0c\u4ee5\u5728\u4fdd\u6301\u9ad8\u51c6\u786e\u6027\u7684\u540c\u65f6\uff0c\u89e3\u51b3\u8fd9\u4e9b\u6311\u6218\uff0c\u5b9e\u73b0\u5ef6\u8fdf\u3001\u529f\u8017\u548c\u786c\u4ef6\u8d44\u6e90\u4f7f\u7528\u4e4b\u95f4\u7684\u5e73\u8861\u3002", "method": "SparseLUT\u6846\u67b6\u7ed3\u5408\u4e86\u4e24\u79cd\u6b63\u4ea4\u4f18\u5316\uff1a1. **\u67b6\u6784\u589e\u5f3a\uff1a** \u901a\u8fc7\u52a0\u6cd5\u5668\u805a\u5408\u591a\u4e2aPolyLUT\u5b50\u795e\u7ecf\u5143\uff0c\u4ee5\u964d\u4f4eLUT\u6d88\u8017\u548c\u63a8\u7406\u5ef6\u8fdf\u30022. **\u8bad\u7ec3\u4f18\u5316\uff1a** \u5f15\u5165\u4e00\u79cd\u975e\u8d2a\u5a6a\u7684\u8bad\u7ec3\u7b97\u6cd5\uff0c\u901a\u8fc7\u9009\u62e9\u6027\u5730\u526a\u679d\u4e0d\u91cd\u8981\u7684\u8f93\u5165\u548c\u7b56\u7565\u6027\u5730\u518d\u589e\u957f\u66f4\u6709\u6548\u7684\u8f93\u5165\u6765\u4f18\u5316\u795e\u7ecf\u5143\u8fde\u63a5\u6027\uff0c\u4ece\u800c\u63d0\u9ad8\u51c6\u786e\u6027\uff0c\u4e14\u4e0d\u589e\u52a0\u989d\u5916\u7684\u9762\u79ef\u548c\u5ef6\u8fdf\u5f00\u9500\u3002", "result": "SparseLUT\u53d6\u5f97\u4e86\u663e\u8457\u7684\u6539\u8fdb\uff1a1. **LUT\u6d88\u8017\uff1a** \u76f8\u6bd4\u73b0\u6709\u6280\u672f\uff0cLUT\u6d88\u8017\u51cf\u5c11\u4e862.0x-13.9x\u30022. **\u63a8\u7406\u5ef6\u8fdf\uff1a** \u63a8\u7406\u5ef6\u8fdf\u964d\u4f4e\u4e861.2x-1.6x\u30023. **\u51c6\u786e\u6027\uff1a** \u5728\u4fdd\u6301\u53ef\u6bd4\u51c6\u786e\u6027(\u67b6\u6784\u4f18\u5316)\u6216\u4ea4\u4ed8\u4e00\u81f4\u7684\u51c6\u786e\u6027\u63d0\u9ad8(\u8bad\u7ec3\u4f18\u5316)\u65b9\u9762\u8868\u73b0\u51fa\u8272\u3002\u4f8b\u5982\uff0c\u5728MNIST\u4e0a\u51c6\u786e\u6027\u63d0\u9ad8\u4e862.13%\uff0c\u5728Jet Substructure Classification\u4e0a\u63d0\u9ad8\u4e860.94%\u3002\u8fd9\u4e9b\u6539\u8fdb\u6ca1\u6709\u5e26\u6765\u989d\u5916\u7684\u9762\u79ef\u548c\u5ef6\u8fdf\u5f00\u9500\uff08\u6307\u8bad\u7ec3\u4f18\u5316\u90e8\u5206\uff09\u3002", "conclusion": "SparseLUT\u901a\u8fc7\u67b6\u6784\u4f18\u5316\uff08\u805a\u5408PolyLUT\u5b50\u795e\u7ecf\u5143\u7684\u52a0\u6cd5\u5668\uff09\u548c\u8bad\u7ec3\u4f18\u5316\uff08\u975e\u8d2a\u5a6a\u7684\u7a00\u758f\u8fde\u63a5\u526a\u679d\u548c\u518d\u589e\u957f\uff09\u6709\u6548\u5730\u89e3\u51b3\u4e86\u73b0\u6709LUT-DNN\u5728LUT\u5c3a\u5bf8\u548c\u7a00\u758f\u8fde\u63a5\u6548\u7387\u4e0a\u7684\u6311\u6218\u3002\u8fd9\u4f7f\u5176\u5728\u4fdd\u6301\u751a\u81f3\u63d0\u9ad8\u51c6\u786e\u6027\u7684\u540c\u65f6\uff0c\u663e\u8457\u51cf\u5c11\u4e86LUT\u6d88\u8017\uff082.0x-13.9x\uff09\u548c\u63a8\u7406\u5ef6\u8fdf\uff081.2x-1.6x\uff09\uff0c\u4e3aFPGA\u4e0a\u7684\u9ad8\u6548DNN\u90e8\u7f72\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6709\u524d\u666f\u7684\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2601.09860", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2601.09860", "abs": "https://arxiv.org/abs/2601.09860", "authors": ["Sepideh Mahabadi", "Sherry Sarkar", "Jakub Tarnawski"], "title": "Improved Algorithms for Fair Matroid Submodular Maximization", "comment": null, "summary": "Submodular maximization subject to matroid constraints is a central problem with many applications in machine learning. As algorithms are increasingly used in decision-making over datapoints with sensitive attributes such as gender or race, it is becoming crucial to enforce fairness to avoid bias and discrimination. Recent work has addressed the challenge of developing efficient approximation algorithms for fair matroid submodular maximization. However, the best algorithms known so far are only guaranteed to satisfy a relaxed version of the fairness constraints that loses a factor 2, i.e., the problem may ask for $\\ell$ elements with a given attribute, but the algorithm is only guaranteed to find $\\lfloor \\ell/2 \\rfloor$. In particular, there is no provable guarantee when $\\ell=1$, which corresponds to a key special case of perfect matching constraints.\n  In this work, we achieve a new trade-off via an algorithm that gets arbitrarily close to full fairness. Namely, for any constant $\\varepsilon>0$, we give a constant-factor approximation to fair monotone matroid submodular maximization that in expectation loses only a factor $(1-\\varepsilon)$ in the lower-bound fairness constraint. Our empirical evaluation on a standard suite of real-world datasets -- including clustering, recommendation, and coverage tasks -- demonstrates the practical effectiveness of our methods.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0eML\u76f8\u5173\uff08\u5b50\u6a21\u6700\u5927\u5316\u53d7\u62df\u9635\u7ea6\u675f\u3001\u516c\u5e73\u6027\uff09\u3002\n\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u65b0\u7684\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u7528\u4e8e\u89e3\u51b3\u516c\u5e73\u5355\u8c03\u62df\u9635\u5b50\u6a21\u6700\u5927\u5316\u95ee\u9898\uff0c\u8be5\u7b97\u6cd5\u5728\u4fdd\u6301\u5e38\u6570\u56e0\u5b50\u8fd1\u4f3c\u6bd4\u7684\u540c\u65f6\uff0c\u4fdd\u8bc1\u5728\u671f\u671b\u4e0a\u80fd\u5b9e\u73b0\u63a5\u8fd1\u5b8c\u5168\u516c\u5e73\u7684\u7ea6\u675f\uff08\u635f\u5931\u56e0\u5b50\u4ec5\u4e3a1-\u03b5\uff09\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u7b97\u6cd5\u5728\u516c\u5e73\u6027\u7ea6\u675f\u4fdd\u8bc1\u4e0a\u635f\u5931\u8f83\u5927\u7684\u95ee\u9898\uff0c\u5e76\u901a\u8fc7\u5b9e\u8bc1\u8bc4\u4f30\u8bc1\u660e\u4e86\u5176\u6709\u6548\u6027\u3002", "motivation": "\u5b50\u6a21\u6700\u5927\u5316\u53d7\u62df\u9635\u7ea6\u675f\u662f\u673a\u5668\u5b66\u4e60\u4e2d\u7684\u4e00\u4e2a\u6838\u5fc3\u95ee\u9898\u3002\u968f\u7740\u7b97\u6cd5\u8d8a\u6765\u8d8a\u591a\u5730\u5e94\u7528\u4e8e\u6d89\u53ca\u654f\u611f\u5c5e\u6027\u7684\u51b3\u7b56\u5236\u5b9a\uff0c\u5f3a\u5236\u516c\u5e73\u6027\u4ee5\u907f\u514d\u504f\u89c1\u548c\u6b67\u89c6\u53d8\u5f97\u81f3\u5173\u91cd\u8981\u3002\u73b0\u6709\u7528\u4e8e\u516c\u5e73\u62df\u9635\u5b50\u6a21\u6700\u5927\u5316\u7684\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u5728\u516c\u5e73\u6027\u4fdd\u8bc1\u65b9\u9762\u53ea\u80fd\u6ee1\u8db3\u4e00\u4e2a\u677e\u5f1b\u7248\u672c\uff08\u635f\u5931\u56e0\u5b50\u4e3a2\uff0c\u5373\u53ea\u80fd\u4fdd\u8bc1\u627e\u5230\u6240\u9700\u6570\u91cf\u7684\u4e00\u534a\uff09\uff0c\u7279\u522b\u662f\u5728\u5173\u952e\u7684 $\\ell=1$ \u60c5\u51b5\uff08\u5bf9\u5e94\u4e8e\u5b8c\u7f8e\u5339\u914d\u7ea6\u675f\uff09\u4e0b\u6ca1\u6709\u53ef\u8bc1\u660e\u7684\u4fdd\u8bc1\u3002\u56e0\u6b64\uff0c\u9700\u8981\u5f00\u53d1\u80fd\u591f\u66f4\u7d27\u5bc6\u5730\u6ee1\u8db3\u516c\u5e73\u6027\u7ea6\u675f\u7684\u7b97\u6cd5\u3002", "method": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u7528\u4e8e\u89e3\u51b3\u516c\u5e73\u5355\u8c03\u62df\u9635\u5b50\u6a21\u6700\u5927\u5316\u95ee\u9898\u3002\u8be5\u7b97\u6cd5\u80fd\u591f\u4ee5\u5e38\u6570\u56e0\u5b50\u8fd1\u4f3c\u6bd4\uff0c\u5c06\u516c\u5e73\u6027\u4e0b\u754c\u7ea6\u675f\u7684\u635f\u5931\u56e0\u5b50\u63a7\u5236\u5728 $(1-\\varepsilon)$ \u5185\uff08\u5176\u4e2d $\\varepsilon>0$ \u662f\u4e00\u4e2a\u5e38\u6570\uff09\u3002", "result": "\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u7b97\u6cd5\uff0c\u8be5\u7b97\u6cd5\u5728\u516c\u5e73\u5355\u8c03\u62df\u9635\u5b50\u6a21\u6700\u5927\u5316\u95ee\u9898\u4e0a\u5b9e\u73b0\u4e86\u65b0\u7684\u6743\u8861\u3002\u5bf9\u4e8e\u4efb\u610f\u5e38\u6570 $\\varepsilon>0$\uff0c\u8be5\u7b97\u6cd5\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5e38\u6570\u56e0\u5b50\u8fd1\u4f3c\uff0c\u5e76\u5728\u671f\u671b\u4e0a\uff0c\u516c\u5e73\u6027\u4e0b\u754c\u7ea6\u675f\u7684\u635f\u5931\u56e0\u5b50\u4ec5\u4e3a $(1-\\varepsilon)$\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u63a5\u8fd1\u5b8c\u5168\u516c\u5e73\u7684\u4fdd\u8bc1\u3002\u5728\u5305\u62ec\u96c6\u7fa4\u3001\u63a8\u8350\u548c\u8986\u76d6\u4efb\u52a1\u5728\u5185\u7684\u6807\u51c6\u771f\u5b9e\u4e16\u754c\u6570\u636e\u96c6\u4e0a\u7684\u5b9e\u8bc1\u8bc4\u4f30\u8bc1\u660e\u4e86\u8be5\u65b9\u6cd5\u7684\u5b9e\u9645\u6709\u6548\u6027\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u65b0\u7684\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u65e8\u5728\u89e3\u51b3\u516c\u5e73\u5355\u8c03\u62df\u9635\u5b50\u6a21\u6700\u5927\u5316\u95ee\u9898\u4e2d\uff0c\u73b0\u6709\u7b97\u6cd5\u5728\u516c\u5e73\u6027\u7ea6\u675f\u677e\u5f1b\u4e0a\u635f\u5931\u8f83\u5927\u7684\u95ee\u9898\u3002\u65b0\u7b97\u6cd5\u5728\u4fdd\u6301\u5e38\u6570\u56e0\u5b50\u8fd1\u4f3c\u6bd4\u7684\u540c\u65f6\uff0c\u80fd\u591f\u4f7f\u516c\u5e73\u6027\u4e0b\u754c\u7ea6\u675f\u7684\u635f\u5931\u56e0\u5b50\u4efb\u610f\u63a5\u8fd1\u4e8e1\uff08\u5373\u63a5\u8fd1\u5b8c\u5168\u516c\u5e73\uff09\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\u4e86\u8be5\u65b9\u6cd5\u5728\u73b0\u5b9e\u4e16\u754c\u6570\u636e\u96c6\u4e0a\u7684\u6709\u6548\u6027\u3002"}}
{"id": "2601.10177", "categories": ["cs.DC", "cs.IT"], "pdf": "https://arxiv.org/pdf/2601.10177", "abs": "https://arxiv.org/abs/2601.10177", "authors": ["Ziting Zhang", "Kai Wan", "Minquan Cheng", "Shuo Shao", "Giuseppe Caire"], "title": "Distributed Linearly Separable Computation with Arbitrary Heterogeneous Data Assignment", "comment": null, "summary": "Distributed linearly separable computation is a fundamental problem in large-scale distributed systems, requiring the computation of linearly separable functions over different datasets across distributed workers. This paper studies a heterogeneous distributed linearly separable computation problem, including one master and N distributed workers. The linearly separable task function involves Kc linear combinations of K messages, where each message is a function of one dataset. Distinguished from the existing homogeneous settings that assume each worker holds the same number of datasets, where the data assignment is carefully designed and controlled by the data center (e.g., the cyclic assignment), we consider a more general setting with arbitrary heterogeneous data assignment across workers, where `arbitrary' means that the data assignment is given in advance and `heterogeneous' means that the workers may hold different numbers of datasets. Our objective is to characterize the fundamental tradeoff between the computable dimension of the task function and the communication cost under arbitrary heterogeneous data assignment. Under the constraint of integer communication costs, for arbitrary heterogeneous data assignment, we propose a universal computing scheme and a universal converse bound by characterizing the structure of data assignment, where they coincide under some parameter regimes. We then extend the proposed computing scheme and converse bound to the case of fractional communication costs.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e DSL\u3001\u56fe\u5904\u7406\u3001MLIR\u3001\u7f16\u8bd1\u5668\u6216 HLS \u4e0d\u76f8\u5173\u3002\u8fd9\u7bc7\u8bba\u6587\u7814\u7a76\u4e86\u5f02\u6784\u5206\u5e03\u5f0f\u7ebf\u6027\u53ef\u5206\u79bb\u8ba1\u7b97\u95ee\u9898\uff0c\u5176\u4efb\u52a1\u51fd\u6570\u6d89\u53ca$K_c$\u4e2a\u7ebf\u6027\u7ec4\u5408\u7684$K$\u4e2a\u6d88\u606f\u3002\u4e0e\u73b0\u6709\u540c\u6784\u8bbe\u7f6e\u4e0d\u540c\uff0c\u672c\u6587\u8003\u8651\u4e86\u4efb\u610f\u5f02\u6784\u6570\u636e\u5206\u914d\uff08\u5de5\u4eba\u6301\u6709\u4e0d\u540c\u6570\u91cf\u7684\u6570\u636e\u96c6\uff0c\u4e14\u5206\u914d\u56fa\u5b9a\uff09\uff0c\u76ee\u6807\u662f\u8868\u5f81\u4efb\u52a1\u51fd\u6570\u7684\u53ef\u8ba1\u7b97\u7ef4\u5ea6\u4e0e\u901a\u4fe1\u6210\u672c\u4e4b\u95f4\u7684\u57fa\u672c\u6743\u8861\u3002\u4f5c\u8005\u63d0\u51fa\u4e86\u666e\u9002\u7684\u8ba1\u7b97\u65b9\u6848\u548c\u9006\u5b9a\u7406\u754c\u9650\uff0c\u5e76\u5728\u67d0\u4e9b\u53c2\u6570\u8303\u56f4\u5185\uff0c\u5728\u6574\u6570\u548c\u5206\u6570\u901a\u4fe1\u6210\u672c\u7ea6\u675f\u4e0b\uff0c\u5b83\u4eec\u662f\u543b\u5408\u7684\u3002", "motivation": "\u73b0\u6709\u7684\u5206\u5e03\u5f0f\u7ebf\u6027\u53ef\u5206\u79bb\u8ba1\u7b97\u5de5\u4f5c\u4e3b\u8981\u96c6\u4e2d\u5728\u540c\u6784\u73af\u5883\u4e2d\uff08\u5373\u6bcf\u4e2a\u5de5\u4f5c\u8282\u70b9\u6301\u6709\u76f8\u540c\u6570\u91cf\u7684\u6570\u636e\u96c6\uff09\uff0c\u6570\u636e\u5206\u914d\u7531\u6570\u636e\u4e2d\u5fc3\u7cbe\u5fc3\u8bbe\u8ba1\u548c\u63a7\u5236\uff08\u5982\u5faa\u73af\u5206\u914d\uff09\u3002\u672c\u6587\u7684\u52a8\u673a\u662f\u7814\u7a76\u66f4\u4e00\u822c\u3001\u66f4\u5b9e\u9645\u7684\u5f02\u6784\u8bbe\u7f6e\uff1a\u5de5\u4eba\u6301\u6709\u7684\u6570\u636e\u96c6\u6570\u91cf\u53ef\u80fd\u4e0d\u540c\uff08\u5f02\u6784\uff09\uff0c\u5e76\u4e14\u8fd9\u79cd\u5206\u914d\u662f\u9884\u5148\u7ed9\u5b9a\u7684\uff08\u4efb\u610f\uff09\uff0c\u4ece\u800c\u8868\u5f81\u4efb\u52a1\u51fd\u6570\u7684\u53ef\u8ba1\u7b97\u7ef4\u5ea6\u548c\u901a\u4fe1\u6210\u672c\u4e4b\u95f4\u7684\u57fa\u672c\u6743\u8861\u3002", "method": "\u672c\u6587\u901a\u8fc7\u8868\u5f81\u6570\u636e\u5206\u914d\u7684\u7ed3\u6784\uff0c\u63d0\u51fa\u4e86\u4e00\u4e2a\u666e\u9002\u7684\u8ba1\u7b97\u65b9\u6848\uff08universal computing scheme\uff09\u548c\u4e00\u4e2a\u666e\u9002\u7684\u9006\u5b9a\u7406\u754c\u9650\uff08universal converse bound\uff09\uff0c\u7528\u4e8e\u5728\u6574\u6570\u901a\u4fe1\u6210\u672c\u4e0b\u8868\u5f81\u4efb\u52a1\u51fd\u6570\u7684\u53ef\u8ba1\u7b97\u7ef4\u5ea6\u4e0e\u901a\u4fe1\u6210\u672c\u4e4b\u95f4\u7684\u57fa\u672c\u6743\u8861\u3002\u968f\u540e\uff0c\u5c06\u8be5\u8ba1\u7b97\u65b9\u6848\u548c\u9006\u5b9a\u7406\u754c\u9650\u6269\u5c55\u5230\u5206\u6570\u901a\u4fe1\u6210\u672c\u7684\u60c5\u51b5\u3002", "result": "\u5728\u4efb\u610f\u5f02\u6784\u6570\u636e\u5206\u914d\u4e0b\uff0c\u672c\u6587\u63d0\u51fa\u4e86\u666e\u9002\u7684\u8ba1\u7b97\u65b9\u6848\u548c\u9006\u5b9a\u7406\u754c\u9650\uff0c\u5728\u6574\u6570\u901a\u4fe1\u6210\u672c\u7ea6\u675f\u4e0b\uff0c\u5b83\u4eec\u5728\u67d0\u4e9b\u53c2\u6570\u8303\u56f4\u5185\u662f\u543b\u5408\u7684\u3002\u8fd9\u79cd\u6743\u8861\u5173\u7cfb\u5df2\u6269\u5c55\u5230\u5206\u6570\u901a\u4fe1\u6210\u672c\u7684\u60c5\u51b5\u3002", "conclusion": "\u672c\u6587\u7814\u7a76\u4e86\u5f02\u6784\u5206\u5e03\u5f0f\u7ebf\u6027\u53ef\u5206\u79bb\u8ba1\u7b97\u95ee\u9898\uff0c\u5e76\u63d0\u51fa\u4e86\u666e\u9002\u7684\u8ba1\u7b97\u65b9\u6848\u548c\u76f8\u5e94\u7684\u9006\u5b9a\u7406\u754c\u9650\uff0c\u7528\u4ee5\u8868\u5f81\u5728\u4efb\u610f\u5f02\u6784\u6570\u636e\u5206\u914d\u4e0b\uff0c\u4efb\u52a1\u51fd\u6570\u7684\u53ef\u8ba1\u7b97\u7ef4\u5ea6\u4e0e\u901a\u4fe1\u6210\u672c\u4e4b\u95f4\u7684\u57fa\u672c\u6743\u8861\u3002\u5728\u67d0\u4e9b\u53c2\u6570\u8303\u56f4\u5185\uff0c\u6240\u63d0\u51fa\u7684\u65b9\u6848\u548c\u754c\u9650\u662f\u4e00\u81f4\u7684\u3002"}}
{"id": "2601.10706", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2601.10706", "abs": "https://arxiv.org/abs/2601.10706", "authors": ["Quinten De Man", "Atharva Sharma", "Kishen N Gowda", "Laxman Dhulipala"], "title": "UFO Trees: Practical and Provably-Efficient Parallel Batch-Dynamic Trees", "comment": "To appear in PPoPP 2026", "summary": "The dynamic trees problem is to maintain a tree under edge updates while supporting queries like connectivity queries or path queries. Despite the first data structure for this fundamental problem -- the link-cut tree -- being invented 40 years ago, our experiments reveal that they are still the fastest sequential data structure for the problem. However, link-cut trees cannot support parallel batch-dynamic updates and have limitations on the kinds of queries they support.\n  In this paper, we design a new parallel batch-dynamic trees data structure called UFO trees that simultaneously supports a wide range of query functionality, supports work-efficient parallel batch-dynamic updates, and is competitive with link-cut trees when run sequentially. We prove that a key reason for the strong practical performance of both link-cut trees and UFO trees is that they can perform updates and queries in sub-logarithmic time for low-diameter trees. We perform an experimental study of our optimized C++ implementations of UFO trees with ten other dynamic tree implementations, several of which are new, in a broad benchmark of both synthetic and real-world trees of varying diameter and size. Our results show that, in both sequential and parallel settings, UFO trees are the fastest dynamic tree data structure that supports a wide range of queries. Our new implementation of UFO trees has low space usage and easily scales to billion-size inputs, making it a promising building block for implementing more complex dynamic graph algorithms in practice.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e\u56fe\u5904\u7406\uff08\u52a8\u6001\u6811\u662f\u56fe\u7684\u4e00\u79cd\u7279\u6b8a\u5f62\u5f0f\uff09\u76f8\u5173\u3002\nUFO\u6811\u662f\u4e00\u79cd\u65b0\u578b\u7684\u5e76\u884c\u6279\u91cf\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u65e2\u80fd\u4e0eLink-Cut\u6811\u7ade\u4e89\u987a\u5e8f\u6027\u80fd\uff0c\u53c8\u9996\u6b21\u652f\u6301\u5de5\u4f5c\u9ad8\u6548\u7684\u5e76\u884c\u6279\u91cf\u52a8\u6001\u66f4\u65b0\u548c\u5e7f\u6cdb\u7684\u67e5\u8be2\u529f\u80fd\uff1b\u5b9e\u9a8c\u8bc1\u660e\uff0cUFO\u6811\u5728\u987a\u5e8f\u548c\u5e76\u884c\u73af\u5883\u4e0b\u90fd\u662f\u652f\u6301\u5e7f\u6cdb\u67e5\u8be2\u7684\u6700\u5feb\u52a8\u6001\u6811\u7ed3\u6784\uff0c\u4e14\u5177\u6709\u826f\u597d\u7684\u53ef\u6269\u5c55\u6027\u3002", "motivation": "\u52a8\u6001\u6811\u95ee\u9898\u662f\u4e00\u4e2a\u57fa\u7840\u6027\u95ee\u9898\uff0c\u9700\u8981\u7ef4\u62a4\u5728\u8fb9\u66f4\u65b0\u4e0b\u7684\u6811\u7ed3\u6784\u5e76\u652f\u6301\u8fde\u901a\u6027\u6216\u8def\u5f84\u67e5\u8be2\u7b49\u64cd\u4f5c\u3002\u4f20\u7edf\u7684Link-Cut\u6811\u867d\u7136\u5df2\u88ab\u53d1\u73b0\u662f\u76ee\u524d\u6700\u5feb\u7684\u987a\u5e8f\u52a8\u6001\u6570\u636e\u7ed3\u6784\uff0c\u4f46\u5b83\u4e0d\u652f\u6301\u5e76\u884c\u6279\u91cf\u52a8\u6001\u66f4\u65b0\uff0c\u5e76\u4e14\u5728\u652f\u6301\u7684\u67e5\u8be2\u79cd\u7c7b\u4e0a\u5b58\u5728\u9650\u5236\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u65b0\u7684\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\uff0c\u80fd\u591f\u5728\u4fdd\u6301\u9ad8\u6027\u80fd\u7684\u540c\u65f6\uff0c\u652f\u6301\u5e76\u884c\u6279\u91cf\u66f4\u65b0\u548c\u66f4\u5e7f\u6cdb\u7684\u67e5\u8be2\u529f\u80fd\u3002", "method": "\u672c\u6587\u8bbe\u8ba1\u5e76\u5f15\u5165\u4e86\u4e00\u79cd\u65b0\u7684\u5e76\u884c\u6279\u91cf\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\u2014\u2014UFO\u6811\u3002UFO\u6811\u57fa\u4e8e\u5176\u80fd\u591f\u652f\u6301\u5de5\u4f5c\u9ad8\u6548\u7684\u5e76\u884c\u6279\u91cf\u52a8\u6001\u66f4\u65b0\u548c\u5e7f\u6cdb\u7684\u67e5\u8be2\u529f\u80fd\u8bbe\u8ba1\u3002\u4f5c\u8005\u901a\u8fc7\u7406\u8bba\u5206\u6790\uff0c\u8bc1\u660e\u4e86Link-Cut\u6811\u548cUFO\u6811\u7684\u5f3a\u5927\u5b9e\u8df5\u6027\u80fd\u7684\u4e00\u4e2a\u5173\u952e\u539f\u56e0\u5728\u4e8e\u5b83\u4eec\u80fd\u591f\u5728\u4f4e\u76f4\u5f84\u6811\u4e0a\u4ee5\u4e9a\u5bf9\u6570\u65f6\u95f4\u6267\u884c\u66f4\u65b0\u548c\u67e5\u8be2\u3002\u4f5c\u8005\u8fd8\u5bf9UFO\u6811\u8fdb\u884c\u4e86\u4f18\u5316\u7684C++\u5b9e\u73b0\uff0c\u5e76\u4e0e\u5176\u5b83\u5341\u79cd\u52a8\u6001\u6811\u5b9e\u73b0\uff08\u5305\u62ec\u4e00\u4e9b\u65b0\u7684\u5b9e\u73b0\uff09\u5728\u4e00\u7cfb\u5217\u5408\u6210\u548c\u771f\u5b9e\u4e16\u754c\u7684\u3001\u4e0d\u540c\u76f4\u5f84\u548c\u5927\u5c0f\u7684\u57fa\u51c6\u6d4b\u8bd5\u4e2d\u8fdb\u884c\u4e86\u5e7f\u6cdb\u7684\u5b9e\u9a8c\u7814\u7a76\u3002", "result": "\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u5728\u987a\u5e8f\u548c\u5e76\u884c\u8bbe\u7f6e\u4e2d\uff0cUFO\u6811\u662f\u652f\u6301\u5e7f\u6cdb\u67e5\u8be2\u7684\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\u4e2d\u901f\u5ea6\u6700\u5feb\u7684\u3002UFO\u6811\u7684\u65b0\u5b9e\u73b0\u7a7a\u95f4\u5360\u7528\u4f4e\uff0c\u5e76\u53ef\u4ee5\u8f7b\u677e\u6269\u5c55\u5230\u5341\u4ebf\u7ea7\u522b\u7684\u8f93\u5165\u89c4\u6a21\u3002\u7406\u8bba\u5206\u6790\u548c\u5b9e\u9a8c\u90fd\u652f\u6301\u4e86\u5176\u5728\u4f4e\u76f4\u5f84\u6811\u4e0a\u5177\u6709\u4e9a\u5bf9\u6570\u65f6\u95f4\u64cd\u4f5c\u7684\u4f18\u5f02\u6027\u80fd\u3002", "conclusion": "UFO\u6811\u662f\u4e00\u79cd\u65b0\u7684\u5e76\u884c\u6279\u91cf\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u5728\u4fdd\u6301\u4e0e\u73b0\u6709\u6700\u597d\u7684\u987a\u5e8f\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\uff08\u5982Link-Cut\u6811\uff09\u76f8\u7ade\u4e89\u7684\u6027\u80fd\u7684\u540c\u65f6\uff0c\u663e\u8457\u6269\u5c55\u4e86\u6240\u652f\u6301\u7684\u67e5\u8be2\u529f\u80fd\u548c\u66f4\u65b0\u6a21\u5f0f\u3002\u5176\u5173\u952e\u4f18\u52bf\u5728\u4e8e\u652f\u6301\u9ad8\u6548\u7684\u5e76\u884c\u6279\u91cf\u52a8\u6001\u66f4\u65b0\uff0c\u4ee5\u53ca\u5728\u4f4e\u76f4\u5f84\u6811\u4e0a\u5b9e\u73b0\u4e9a\u5bf9\u6570\u65f6\u95f4\u7684\u64cd\u4f5c\u3002\u5b9e\u9a8c\u8bc1\u660e\uff0cUFO\u6811\u5728\u987a\u5e8f\u548c\u5e76\u884c\u73af\u5883\u4e0b\uff0c\u5bf9\u4e8e\u652f\u6301\u5e7f\u6cdb\u67e5\u8be2\u7684\u52a8\u6001\u6811\u6570\u636e\u7ed3\u6784\u4e2d\u901f\u5ea6\u6700\u5feb\uff0c\u5177\u6709\u4f4e\u7a7a\u95f4\u5360\u7528\u548c\u826f\u597d\u7684\u53ef\u6269\u5c55\u6027\uff0c\u4f7f\u5176\u6210\u4e3a\u6784\u5efa\u590d\u6742\u52a8\u6001\u56fe\u7b97\u6cd5\u7684\u6709\u524d\u666f\u7684\u7ec4\u4ef6\u3002"}}
