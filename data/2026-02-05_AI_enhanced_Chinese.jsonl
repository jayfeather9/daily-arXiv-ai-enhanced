{"id": "2602.04100", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.04100", "abs": "https://arxiv.org/abs/2602.04100", "authors": ["Maccoy Merrell", "Lei Wang", "Stavros Kalafatis", "Paul V. Gratz"], "title": "SPPAM: Signature Pattern Prediction and Access-Map Prefetcher", "comment": "5 pages, 6 figures, submitted to the 4th Data Prefetching Championship co-located at HPCA 2026", "summary": "The discrepancy between processor speed and memory system performance continues to limit the performance of many workloads. To address the issue, one effective and well studied technique is cache prefetching. Many prefetching designs have been proposed, with varying approaches and effectiveness. For example, SPP is a popular prefetcher that leverages confidence throttled recursion to speculate on the future path of program's references, however it is very susceptible to the reference reordering of higher-level caches and the OoO core. Orthogonally, AMPM is another popular approach to prefetching which uses reordering-resistant access maps to identify patterns within a region, but is unable to speculate beyond that region. In this paper, we propose SPPAM, a new approach to prefetching, inspired by prior works such as SPP and AMPM, while addressing their limitations. SPPAM utilizes online-learning to build a set of access-map patterns. These patterns are used in a speculative lookahead which is throttled by a confidence metric. Targeting the second-level cache, SPPAM alongside state-of-the-art prefetchers Berti and Bingo improve system performance by 31.4% over no prefetching and 6.2% over the baseline of Berti and Pythia.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04595", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.04595", "abs": "https://arxiv.org/abs/2602.04595", "authors": ["Xinyu Wang", "Jieyu Li", "Yanan Sun", "Weifeng He"], "title": "Harmonia: Algorithm-Hardware Co-Design for Memory- and Compute-Efficient BFP-based LLM Inference", "comment": null, "summary": "Large Language Models (LLMs) are powerful but incur high memory and computation costs. Quantization is an effective solution, with INT weights and FP activations being widely adopted to preserve accuracy. Prior works further reduce FP overhead by using block floating point (BFP) activations in linear layers, but fail to extend BFP to attention layers due to severe accuracy degradation, limiting overall efficiency. To address this challenge, we propose Harmonia, an algorithm-hardware co-design framework that enables all-layer BFP activations with a configurable hardware architecture. First, we systematically explore BFP configurations to achieve a better trade-off between accuracy and activation compression across all layers. Second, to reduce KV-cache storage and computation in attention layers, we introduce an asymmetric bit-allocation strategy and computations in attention layers,we introduce an asymmetric bit-allocation strategy combined with a hybrid offline-online outlier smoothing technique. This allow aggressive KV-cache compression from FP16 to 4-bit-mantissa BFP with only 0.3% average accuracy loss. Third, to fully exploit all-layer BFP activations, we design dedicated hardware components, including a reconfigurable PE supporting mixed data formats (BFP-INT and BPF-BFP), a real-time FP16-to-BFP converter, and a tiling-aware dataflow to reduce memory traffic. We evaluate Harmonia on GEMM operations in both linear and attention layers across eight widely used LLMs. Compared with prior works, Harmonia achieves 3.84x (up to 5.05x) higher area efficiency, 2.03x (up to 3.90x) better energy efficiency, and 3.08x (up to 4.62x) speedup on average.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.03991", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.03991", "abs": "https://arxiv.org/abs/2602.03991", "authors": ["Mingyang Gong", "Zhi-Zhong Chen", "Brendan Mumey"], "title": "Approximately Partitioning Vertices into Short Paths", "comment": null, "summary": "Given a fixed positive integer $k$ and a simple undirected graph $G = (V, E)$, the {\\em $k^-$-path partition} problem, denoted by $k$PP for short, aims to find a minimum collection $\\cal{P}$ of vertex-disjoint paths in $G$ such that each path in $\\cal{P}$ has at most $k$ vertices and each vertex of $G$ appears in one path in $\\cal{P}$. In this paper, we present a $\\frac {k+4}5$-approximation algorithm for $k$PP when $k\\in\\{9,10\\}$ and an improved $(\\frac{\\sqrt{11}-2}7 k + \\frac {9-\\sqrt{11}}7)$-approximation algorithm when $k \\ge 11$. Our algorithms achieve the current best approximation ratios for $k \\in \\{ 9, 10, \\ldots, 18 \\}$.\n  Our algorithms start with a maximum triangle-free path-cycle cover $\\cal{F}$, which may not be feasible because of the existence of cycles or paths with more than $k$ vertices. We connect as many cycles in $\\cal{F}$ with $4$ or $5$ vertices as possible by computing another maximum-weight path-cycle cover in a suitably constructed graph so that $\\cal{F}$ can be transformed into a $k^-$-path partition of $G$ without losing too many edges.\n  Keywords: $k^-$-path partition; Triangle-free path-cycle cover; $[f, g]$-factor; Approximation algorithm", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04013", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.04013", "abs": "https://arxiv.org/abs/2602.04013", "authors": ["Petr Kuznetsov", "Pierre Sutra", "Guillermo Toyos-Marfurt"], "title": "Pending Conflicts Make Progress Impossible", "comment": "9 pages, 2 figures", "summary": "In this work, we study progress conditions for commutativity-aware, linearizable implementations of shared objects. Motivated by the observation that commuting operations can be executed in parallel, we introduce conflict-obstruction-freedom: a process is guaranteed to complete its operation if it runs for long enough without encountering step contention with conflicting (non-commuting) operations. This condition generalizes obstruction-freedom and wait-freedom by allowing progress as long as step contention is only induced by commuting operations. We prove that conflict-obstruction-free universal constructions are impossible to implement in the asynchronous read-write shared memory model. This result exposes a fundamental limitation of conflict-aware universal constructions: the mere invocation of conflicting operations imposes a synchronization cost. Progress requires eventual resolution of pending conflicts.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04059", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.04059", "abs": "https://arxiv.org/abs/2602.04059", "authors": ["Bin Fu", "Yumei Huo", "Hairong Zhao"], "title": "Minimizing Makespan in Sublinear Time via Weighted Random Sampling", "comment": null, "summary": "We consider the classical makespan minimization scheduling problem where $n$ jobs must be scheduled on $m$ identical machines. Using weighted random sampling, we developed two sublinear time approximation schemes: one for the case where $n$ is known and the other for the case where $n$ is unknown. Both algorithms not only give a $(1+3\u03b5)$-approximation to the optimal makespan but also generate a sketch schedule.\n  Our first algorithm, which targets the case where $n$ is known and draws samples in a single round under weighted random sampling, has a running time of $\\tilde{O}(\\tfrac{m^5}{\u03b5^4} \\sqrt{n}+A(\\ceiling{m\\over \u03b5}, \u03b5 ))$, where\n  $A(\\mathcal{N}, \u03b1)$ is the time complexity of any $(1+\u03b1)$-approximation scheme for the makespan minimization of $\\mathcal{N}$ jobs.\n  The second algorithm addresses the case where $n$ is unknown. It uses adaptive weighted random sampling, %\\textit{that is}, it draws samples in several rounds, adjusting the number of samples after each round,\n  and runs in sublinear time $\\tilde{O}\\left( \\tfrac{m^5} {\u03b5^4} \\sqrt{n} +\n  A(\\ceiling{m\\over \u03b5}, \u03b5 )\\right)$. We also provide an implementation that generates a weighted random sample using $O(\\log n)$ uniform random samples.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04652", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.04652", "abs": "https://arxiv.org/abs/2602.04652", "authors": ["Ryan Barker", "Fatemeh Afghah"], "title": "Six Times to Spare: LDPC Acceleration on DGX Spark for AI-Native Open RAN", "comment": "6 pages, 2 figures, 1 table, 1 equation", "summary": "Low-density parity-check (LDPC) decoding is one of the most computationally intensive kernels in the 5G New Radio (NR) physical layer and must complete within a 0.5\\,ms transmission time interval while sharing the budget with FFT, channel estimation, demapping, HARQ, and MAC scheduling. Many open and proprietary stacks still execute LDPC on general-purpose CPUs, raising concerns about missed-slot events and limited scalability as bandwidths, modulation orders, and user multiplexing increase. This paper empirically quantifies the benefit of offloading 5G-style LDPC5G decoding from a Grace CPU to the integrated Blackwell GB10 GPU on an NVIDIA DGX~Spark platform. Using NVIDIA Sionna PHY/SYS on TensorFlow, we construct an NR-like link-level chain with an LDPC5G encoder/decoder, 16-QAM modulation, and AWGN, and sweep both the number of codewords decoded in parallel and the number of belief-propagation iterations, timing only the decoding phase while logging CPU and GPU utilization and power. Across the sweep we observe an average GPU/CPU throughput speedup of approximately $6\\times$, with per-codeword CPU latency reaching $\\approx 0.71$\\,ms at 20 iterations (exceeding the 0.5\\,ms slot), while the GB10 GPU remains within 6--24\\% of the slot for the same workloads. Resource-usage measurements show that CPU-based LDPC decoding often consumes around ten Grace cores, whereas GPU-based decoding adds only $\\approx10-15$\\,W over GPU idle while leaving most CPU capacity available for higher-layer tasks. Because our implementation relies on high-level Sionna layers rather than hand-tuned CUDA, these results represent conservative lower bounds on achievable accelerator performance and provide a reusable, scriptable methodology for evaluating LDPC and other physical-layer kernels on future Grace/Blackwell and Aerial/ACAR/AODT platforms.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04103", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.04103", "abs": "https://arxiv.org/abs/2602.04103", "authors": ["R. Groot Koerkamp"], "title": "QuadRank: Engineering a High Throughput Rank", "comment": "submitted to SEA-2026; 21 pages; 8 figures", "summary": "Given a text, a query $\\mathsf{rank}(q, c)$ counts the number of occurrences of character $c$ among the first $q$ characters of the text. Space-efficient methods to answer these rank queries form an important building block in many succinct data structures. For example, the FM-index is a widely used data structure that uses rank queries to locate all occurrences of a pattern in a text.\n  In bioinformatics applications, the goal is usually to process a given input as fast as possible. Thus, data structures should have high throughput when used with many threads.\n  Contributions. For the binary alphabet, we develop BiRank with 3.28% space overhead. It merges the central ideas of two recent papers: (1) we interleave (inline) offsets in each cache line of the underlying bit vector [Laws et al., 2024], reducing cache-misses, and (2) these offsets are to the middle of each block so that only half of them need popcounting [Gottlieb and Reinert, 2025]. In QuadRank (14.4% space overhead), we extend these techniques to the $\u03c3=4$ (DNA) alphabet.\n  Both data structures require only a single cache miss per query, making them highly suitable for high-throughput and memory-bound settings. To enable efficient batch-processing, we support prefetching the cache lines required to answer upcoming queries.\n  Results. BiRank and QuadRank are around $1.5\\times$ and $2\\times$ faster than similar-overhead methods that do not use inlining. Prefetching gives an additional $2\\times$ speedup, at which point the dual-channel DDR4 RAM bandwidth becomes a hard limit on the total throughput. With prefetching, both methods outperform all other methods apart from SPIDER [Laws et al., 2024] by $2\\times$.\n  When using QuadRank with prefetching in a toy count-only FM-index, QuadFm, this results in a smaller size and up to $4\\times$ speedup over Genedex, a state-of-the-art batching FM-index implementation.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04697", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2602.04697", "abs": "https://arxiv.org/abs/2602.04697", "authors": ["Davide Basile", "Valerio Goretti", "Luca Barbaro", "Hajo A. Reijers", "Claudio Di Ciccio"], "title": "A TEE-based Approach for Preserving Data Secrecy in Process Mining with Decentralized Sources", "comment": "arXiv admin note: text overlap with arXiv:2312.12105", "summary": "Process mining techniques enable organizations to gain insights into their business processes through the analysis of execution records (event logs) stored by information systems. While most process mining efforts focus on intra-organizational scenarios, many real-world business processes span multiple independent organizations. Inter-organizational process mining, though, faces significant challenges, particularly regarding confidentiality guarantees: The analysis of data can reveal information that the participating organizations may not consent to disclose to one another, or to a third party hosting process mining services. To overcome this issue, this paper presents CONFINE, an approach for secrecy-preserving inter-organizational process mining. CONFINE leverages Trusted Execution Environments (TEEs) to deploy trusted applications that are capable of securely mining multi-party event logs while preserving data secrecy. We propose an architecture supporting a four-stage protocol to secure data exchange and processing, allowing for protected transfer and aggregation of unaltered process data across organizational boundaries. To avoid out-of-memory errors due to the limited capacity of TEEs, our protocol employs a segmentation-based strategy, whereby event logs are transmitted to TEEs in smaller batches. We conduct a formal verification of correctness and a security analysis of the guarantees provided by the TEE core. We evaluate our implementation on real-world and synthetic data, showing that the proposed approach can handle realistic workloads. The results indicate logarithmic memory growth with respect to the event log size and linear growth with the number of provisioning organizations, highlighting scalability properties and opportunities for further optimization.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04386", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.04386", "abs": "https://arxiv.org/abs/2602.04386", "authors": ["Yahel Uffenheimer", "Omri Weinstein"], "title": "Improved Sparse Recovery for Approximate Matrix Multiplication", "comment": null, "summary": "We present a simple randomized algorithm for approximate matrix multiplication (AMM) whose error scales with the *output* norm $\\|AB\\|_F$. Given any $n\\times n$ matrices $A,B$ and a runtime parameter $r\\leq n$, the algorithm produces in $O(n^2(r+\\log n))$ time, a matrix $C$ with total squared error $\\mathbb{E}[\\|C-AB\\|_F^2]\\le (1-\\frac{r}{n})\\|AB\\|_F^2$, per-entry variance $\\|AB\\|_F^2/n^2$ and bias $\\mathbb{E}[C]=\\frac{r}{n}AB$. Alternatively, the algorithm can compute an *unbiased* estimation with expected total squared error $\\frac{n}{r}\\|{AB}\\|_{F}^2$, recovering the state-of-art AMM error obtained by Pagh's TensorSketch algorithm (Pagh, 2013). Our algorithm is a log-factor faster.\n  The key insight in the algorithm is a new variation of pseudo-random rotation of the input matrices (a Fast Hadamard Transform with asymmetric diagonal scaling), which redistributes the Frobenius norm of the *output* $AB$ uniformly across its entries.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04523", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.04523", "abs": "https://arxiv.org/abs/2602.04523", "authors": ["Ferdinando Cicalese", "Zsuzsanna Lipt\u00e1k", "Travis Gagie", "Gonzalo Navarro", "Nicola Prezza", "Cristian Urbina"], "title": "Incongruity-sensitive access to highly compressed strings", "comment": null, "summary": "Random access to highly compressed strings -- represented by straight-line programs or Lempel-Ziv parses, for example -- is a well-studied topic. Random access to such strings in strongly sublogarithmic time is impossible in the worst case, but previous authors have shown how to support faster access to specific characters and their neighbourhoods. In this paper we explore whether, since better compression can impede access, we can support faster access to relatively incompressible substrings of highly compressed strings. We first show how, given a run-length compressed straight-line program (RLSLP) of size $g_{rl}$ or a block tree of size $L$, we can build an $O (g_{rl})$-space or an $O (L)$-space data structure, respectively, that supports access to any character in time logarithmic in the length of the longest repeated substring containing that character. That is, the more incongruous a character is with respect to the characters around it in a certain sense, the faster we can support access to it. We then prove a similar but more powerful and sophisticated result for parsings in which phrases' sources do not overlap much larger phrases, with the query time depending also on the number of phrases we must copy from their sources to obtain the queried character.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
{"id": "2602.04842", "categories": ["cs.DS", "math.NA", "math.OC"], "pdf": "https://arxiv.org/pdf/2602.04842", "abs": "https://arxiv.org/abs/2602.04842", "authors": ["Micha\u0142 Derezi\u0144ski", "Ethan N. Epperly", "Raphael A. Meyer"], "title": "The matrix-vector complexity of $Ax=b$", "comment": null, "summary": "Matrix-vector algorithms, particularly Krylov subspace methods, are widely viewed as the most effective algorithms for solving large systems of linear equations. This paper establishes lower bounds on the worst-case number of matrix-vector products needed by such an algorithm to approximately solve a general linear system. The first main result is that, for a matrix-vector algorithm which can perform products with both a matrix and its transpose, $\u03a9(\u03ba\\log(1/\\varepsilon))$ matrix-vector products are necessary to solve a linear system with condition number $\u03ba$ to accuracy $\\varepsilon$, matching an upper bound for conjugate gradient on the normal equations. The second main result is that one-sided algorithms, which lack access to the transpose, must use $n$ matrix-vector products to solve an $n \\times n$ linear system, even when the problem is perfectly conditioned. Both main results include explicit constants that match known upper bounds up to a factor of four. These results rigorously demonstrate the limitations of matrix-vector algorithms and confirm the optimality of widely used Krylov subspace algorithms.", "AI": {"tldr": "Summary generation failed", "motivation": "Motivation analysis unavailable", "method": "Method extraction failed", "result": "Result analysis unavailable", "conclusion": "Conclusion extraction failed"}}
