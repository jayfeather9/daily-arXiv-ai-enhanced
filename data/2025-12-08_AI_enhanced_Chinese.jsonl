{"id": "2512.05247", "categories": ["cs.DS", "q-bio.QM"], "pdf": "https://arxiv.org/pdf/2512.05247", "abs": "https://arxiv.org/abs/2512.05247", "authors": ["Spencer Gibson", "Yun William Yu"], "title": "Incorporating indel channels into average-case analysis of seed-chain-extend", "comment": "25 pages (10 page main text + 2 page biblio + 13 page appendix); conference submission", "summary": "Given a sequence $s_1$ of $n$ letters drawn i.i.d. from an alphabet of size $\u03c3$ and a mutated substring $s_2$ of length $m < n$, we often want to recover the mutation history that generated $s_2$ from $s_1$. Modern sequence aligners are widely used for this task, and many employ the seed-chain-extend heuristic with $k$-mer seeds. Previously, Shaw and Yu showed that optimal linear-gap cost chaining can produce a chain with $1 - O\\left(\\frac{1}{\\sqrt{m}}\\right)$ recoverability, the proportion of the mutation history that is recovered, in $O\\left(mn^{2.43\u03b8} \\log n\\right)$ expected time, where $\u03b8< 0.206$ is the mutation rate under a substitution-only channel and $s_1$ is assumed to be uniformly random. However, a gap remains between theory and practice, since real genomic data includes insertions and deletions (indels), and yet seed-chain-extend remains effective. In this paper, we generalize those prior results by introducing mathematical machinery to deal with the two new obstacles introduced by indel channels: the dependence of neighboring anchors and the presence of anchors that are only partially correct. We are thus able\n  to prove that the expected recoverability of an optimal chain is $\\ge 1 - O\\Bigl(\\frac{1}{\\sqrt{m}}\\Bigr)$ and the expected runtime is $O(mn^{3.15 \\cdot \u03b8_T}\\log n)$, when the total mutation rate given by the sum of the substitution, insertion, and deletion mutation rates ($\u03b8_T = \u03b8_i + \u03b8_d + \u03b8_s$) is less than $0.159$.", "AI": {"tldr": "\u5173\u8054\uff1a\u56fe\u5904\u7406\uff08\u7ebf\u6027\u95f4\u9699\u6210\u672c\u94fe\u901a\u5e38\u53ef\u4ee5\u7528\u56fe\u7b97\u6cd5\u89e3\u51b3\uff09\u3002\u8fd9\u4e2a\u5de5\u4f5c\u5c06\u5e8f\u5217\u6bd4\u5bf9\u4e2d $k$-mer \u79cd\u5b50\u542f\u53d1\u5f0f\u7684\u7406\u8bba\u5206\u6790\u4ece\u4ec5\u66ff\u6362\u6a21\u578b\u63a8\u5e7f\u5230\u5305\u542b\u63d2\u5165\u548c\u5220\u9664\u7684\u6a21\u578b\u3002\u4e4b\u524d\u7684\u7814\u7a76\u8bc1\u660e\u4e86\u5728\u4ec5\u66ff\u6362\u901a\u9053\u4e0b\u4e00\u4e2a\u6700\u4f18\u7ebf\u6027\u95f4\u9699\u6210\u672c\u94fe\u7684\u9884\u671f\u53ef\u6062\u590d\u6027\u4e3a $1 - O\\left(\\frac{1}{\\sqrt{m}}\\right)$\uff0c\u4f46\u8fd9\u4e2a\u7ed3\u679c\u5ffd\u7565\u4e86\u771f\u5b9e\u57fa\u56e0\u7ec4\u6570\u636e\u4e2d\u7684\u63d2\u5165\u548c\u5220\u9664\u3002\u672c\u6587\u901a\u8fc7\u5f15\u5165\u65b0\u7684\u6570\u5b66\u5de5\u5177\u6765\u5904\u7406 indel \u901a\u9053\u5e26\u6765\u7684\u76f8\u90bb\u951a\u70b9\u7684\u4f9d\u8d56\u6027\u548c\u90e8\u5206\u6b63\u786e\u7684\u951a\u70b9\u8fd9\u4e24\u4e2a\u65b0\u95ee\u9898\uff0c\u8bc1\u660e\u4e86\u5728\u5305\u542b\u66ff\u6362\u3001\u63d2\u5165\u548c\u5220\u9664\u7684\u603b\u7a81\u53d8\u7387 $\u03b8_T < 0.159$ \u65f6\uff0c\u6700\u4f18\u94fe\u7684\u9884\u671f\u53ef\u6062\u590d\u6027\u4ecd\u80fd\u8fbe\u5230 $\\ge 1 - O\\left(\\frac{1}{\\sqrt{m}}\\right)$\uff0c\u540c\u65f6\u7ed9\u51fa\u4e86\u65b0\u7684\u9884\u671f\u8fd0\u884c\u65f6\u95f4\u4e0a\u754c $O(mn^{3.15 \\cdot \u03b8_T}\\log n)$\u3002", "motivation": "\u73b0\u6709\u7684\u6700\u4f73\u7ebf\u6027\u95f4\u9699\u6210\u672c\u94fe\u7406\u8bba\u7ed3\u679c\uff08\\[Shaw and Yu]\uff09\u4ec5\u9002\u7528\u4e8e\u53ea\u5305\u542b\u66ff\u6362\u7684\u7a81\u53d8\u901a\u9053\uff0c\u5e76\u5047\u8bbe\u5747\u5300\u968f\u673a\u7684 $s_1$\uff0c\u4f46\u5728\u5305\u542b\u63d2\u5165\u548c\u5220\u9664\uff08indels\uff09\u7684\u5b9e\u9645\u57fa\u56e0\u7ec4\u6570\u636e\u4e2d\uff0c\u57fa\u4e8e $k$-mer \u79cd\u5b50\u7684 seed-chain-extend \u542f\u53d1\u5f0f\u65b9\u6cd5\u4ecd\u7136\u6709\u6548\u3002\u56e0\u6b64\uff0c\u672c\u6587\u7684\u52a8\u673a\u5728\u4e8e\u5f25\u8865\u7406\u8bba\u4e0e\u5b9e\u8df5\u4e4b\u95f4\u7684\u5dee\u8ddd\uff0c\u5c06\u7406\u8bba\u63a8\u5e7f\u5230\u5305\u542b indels \u7684\u66f4\u771f\u5b9e\u7684\u7a81\u53d8\u6a21\u578b\u3002", "method": "\u901a\u8fc7\u5f15\u5165\u65b0\u7684\u6570\u5b66\u5de5\u5177\u6765\u5904\u7406 indel \u901a\u9053\u5e26\u6765\u7684\u4e24\u4e2a\u65b0\u969c\u788d\uff1a\u76f8\u90bb\u951a\u70b9\u7684\u4f9d\u8d56\u6027\u548c\u90e8\u5206\u6b63\u786e\u7684\u951a\u70b9\u7684\u5b58\u5728\uff0c\u672c\u6587\u6210\u529f\u5730\u5c06\u5176\u5148\u524d\u7684\u7406\u8bba\u7ed3\u679c\u63a8\u5e7f\u5230\u4e86\u5305\u542b\u63d2\u5165\u548c\u5220\u9664\uff08indels\uff09\u7684\u7a81\u53d8\u6a21\u578b\u3002", "result": "\u8bc1\u660e\u4e86\u5728\u5305\u542b\u66ff\u6362\u3001\u63d2\u5165\u548c\u5220\u9664\u7684\u7a81\u53d8\u901a\u9053\u4e0b\uff0c\u5f53\u603b\u7a81\u53d8\u7387 $\u03b8_T = \u03b8_i + \u03b8_d + \u03b8_s$ \u4f4e\u4e8e $0.159$ \u65f6\uff0c\u6700\u4f18\u94fe\u7684\u9884\u671f\u53ef\u6062\u590d\u6027\u4e3a $\\ge 1 - O\\left(\\frac{1}{\\sqrt{m}}\\right)$\uff0c\u9884\u671f\u8fd0\u884c\u65f6\u95f4\u4e3a $O(mn^{3.15 \\cdot \u03b8_T}\\log n)$\u3002\u8fd9\u6210\u529f\u5730\u5c06\u5148\u524d\u7684\u7406\u8bba\u7ed3\u679c\u63a8\u5e7f\u5230\u4e86\u5305\u542b indels \u7684\u60c5\u666f\u3002", "conclusion": "\u672c\u6587\u5c06\u5148\u524d\u5173\u4e8e\u6700\u4f18\u7ebf\u6027\u95f4\u9699\u6210\u672c\u94fe\u53ef\u6062\u590d\u6027\u7684\u7406\u8bba\u7ed3\u679c\u63a8\u5e7f\u5230\u5305\u542b\u63d2\u5165\u548c\u5220\u9664\uff08indels\uff09\u7684\u7a81\u53d8\u6a21\u578b\uff0c\u8bc1\u660e\u4e86\u5728\u603b\u7a81\u53d8\u7387\u4f4e\u4e8e $0.159$ \u7684\u6761\u4ef6\u4e0b\uff0c\u6700\u4f18\u94fe\u7684\u9884\u671f\u53ef\u6062\u590d\u6027\u53ef\u8fbe $\\ge 1 - O\\left(\\frac{1}{\\sqrt{m}}\\right)$\uff0c\u9884\u671f\u8fd0\u884c\u65f6\u95f4\u4e3a $O(mn^{3.15 \\cdot \u03b8_T}\\log n)$\uff0c\u4ece\u800c\u7f29\u5c0f\u4e86\u7406\u8bba\u4e0e\u5b9e\u8df5\u4e4b\u95f4\u7684\u5dee\u8ddd\u3002"}}
{"id": "2512.05300", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2512.05300", "abs": "https://arxiv.org/abs/2512.05300", "authors": ["Yonggang Jiang", "Yaowei Long", "Thatchaphol Saranurak", "Benyu Wang"], "title": "Crude Approximation of Directed Minimum Cut and Arborescence Packing in Almost Linear Time", "comment": null, "summary": "We give almost-linear-time algorithms for approximating rooted minimum cut and maximum arborescence packing in directed graphs, two problems that are dual to each other [Edm73]. More specifically, for an $n$-vertex, $m$-edge directed graph $G$ whose $s$-rooted minimum cut value is $k$, our first algorithm computes an $s$-rooted cut of size at most $O(k\\log^{5} n)$ in $m^{1+o(1)}$ time, and our second algorithm packs $k$ $s$-rooted arborescences with $n^{o(1)}$ congestion in $m^{1+o(1)}$ time, certifying that the $s$-rooted minimum cut is at least $k / n^{o(1)}$. Our first algorithm also works for weighted graphs.\n  Prior to our work, the fastest algorithms for computing the $s$-rooted minimum cut were exact but had super-linear running time: either $\\tilde{O}(mk)$ [Gab91] or $\\tilde{O}(m^{1+o(1)}\\min\\{\\sqrt{n},n/m^{1/3}\\})$ [CLN+22]. The fastest known algorithms for packing $s$-rooted arborescences had no congestion, but required $\\tilde{O}(m \\cdot \\mathrm{poly}(k))$ time [BHKP08].", "AI": {"tldr": "This paper is related to **Graph Processing (\u56fe\u5904\u7406)**, specifically the optimization problems on directed graphs (\u6709\u5411\u56fe\u4e0a\u7684\u4f18\u5316\u95ee\u9898), which are fundamental topics in **Compiler (\u7f16\u8bd1\u5668)** and **HLS (\u9ad8\u5c42\u6b21\u7efc\u5408)** for resource allocation and data flow analysis.\n\u672c\u6587\u63d0\u51fa\u4e86\u8fd1\u4f3c\u8ba1\u7b97\u6709\u6839\u6700\u5c0f\u5272\u548c\u6700\u5927\u53d1\u6563\u6811\u6253\u5305\u7684\u51c6\u7ebf\u6027\u65f6\u95f4\u7b97\u6cd5\u3002\u5bf9\u4e8e\u4e00\u4e2a\u8282\u70b9\u6570\u4e3a $n$\u3001\u8fb9\u6570\u4e3a $m$\u3001\u6700\u5c0f\u5272\u503c\u4e3a $k$ \u7684\u6709\u5411\u56fe\uff0c\u65b0\u7684\u7b97\u6cd5\u80fd\u5728 $m^{1+o(1)}$ \u65f6\u95f4\u5185\uff1aa) \u627e\u5230\u4e00\u4e2a $O(k \\log^5 n)$ \u7684\u8fd1\u4f3c\u6700\u5c0f\u5272\uff1bb) \u4ee5 $n^{o(1)}$ \u62e5\u585e\u5ea6\u6253\u5305 $k$ \u68f5\u53d1\u6563\u6811\u3002\u8fd9\u4e9b\u7b97\u6cd5\u5728\u901f\u5ea6\u4e0a\u8fdc\u8d85\u73b0\u6709\u7684\u7cbe\u786e\u7b97\u6cd5\uff0c\u663e\u8457\u63d0\u9ad8\u4e86\u56fe\u8bba\u57fa\u672c\u95ee\u9898\u7684\u6c42\u89e3\u6548\u7387\u3002", "motivation": "\u6709\u6839\u6700\u5c0f\u5272\uff08Rooted Minimum Cut\uff09\u548c\u6700\u5927\u53d1\u6563\u6811\u6253\u5305\uff08Maximum Arborescence Packing\uff09\u662f\u56fe\u8bba\u4e2d\u4e24\u4e2a\u5bf9\u5076\u4e14\u57fa\u7840\u7684\u95ee\u9898\u3002\n\u4f20\u7edf\u6c42\u89e3\u8fd9\u4e9b\u95ee\u9898\u7684\u5df2\u77e5\u7b97\u6cd5\u5177\u6709\u8f83\u9ad8\u7684\u8d85\u7ebf\u6027\uff08super-linear\uff09\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\n* \u6700\u5c0f\u5272\u7684\u7cbe\u786e\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $\\tilde{O}(mk)$ \u6216 $\\tilde{O}(m^{1+o(1)}\\min\\{\\sqrt{n},n/m^{1/3}\\})$\u3002\n* \u65e0\u62e5\u585e\u53d1\u6563\u6811\u6253\u5305\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $\\tilde{O}(m \\cdot \\mathrm{poly}(k))$\u3002\n\u56e0\u6b64\uff0c\u7814\u7a76\u7684\u52a8\u673a\u662f\u5f00\u53d1\u51fa\u51c6\u7ebf\u6027\u65f6\u95f4\uff08almost-linear-time\uff09\u7684\u8fd1\u4f3c\u7b97\u6cd5\uff0c\u4ee5\u663e\u8457\u63d0\u9ad8\u5927\u89c4\u6a21\u6709\u5411\u56fe\u5904\u7406\u7684\u6548\u7387\u3002", "method": "\u672c\u6587\u63d0\u51fa\u4e86\u4e24\u79cd\u51c6\u7ebf\u6027\u65f6\u95f4\u7b97\u6cd5\uff1a\n1. **\u8fd1\u4f3c s-\u6709\u6839\u6700\u5c0f\u5272\u7b97\u6cd5**\uff1a\u5728 $m^{1+o(1)}$ \u65f6\u95f4\u5185\uff0c\u8ba1\u7b97\u4e00\u4e2a\u5927\u5c0f\u81f3\u591a\u4e3a $O(k\\log^{5} n)$ \u7684 $s$-\u6709\u6839\u5272\uff0c\u5176\u4e2d $k$ \u662f $s$-\u6709\u6839\u6700\u5c0f\u5272\u503c\u3002\u6b64\u7b97\u6cd5\u4e5f\u9002\u7528\u4e8e\u52a0\u6743\u56fe\u3002\n2. **\u8fd1\u4f3c s-\u6709\u6839\u53d1\u6563\u6811\u6253\u5305\u7b97\u6cd5**\uff1a\u5728 $m^{1+o(1)}$ \u65f6\u95f4\u5185\uff0c\u6253\u5305 $k$ \u68f5 $s$-\u6709\u6839\u53d1\u6563\u6811\uff0c\u62e5\u585e\u5ea6\u4e3a $n^{o(1)}$\uff0c\u4ece\u800c\u8bc1\u660e $s$-\u6709\u6839\u6700\u5c0f\u5272\u81f3\u5c11\u4e3a $k / n^{o(1)}$\u3002\n\u8fd9\u4e9b\u7b97\u6cd5\u4e0e\u4f20\u7edf\u7684\u3001\u65f6\u95f4\u590d\u6742\u5ea6\u66f4\u9ad8\u7684\u7cbe\u786e\u7b97\u6cd5\u76f8\u6bd4\uff0c\u5728\u6548\u7387\u4e0a\u6709\u663e\u8457\u63d0\u5347\u3002", "result": "\u672c\u6587\u63d0\u51fa\u7684\u8fd1\u4f3c\u7b97\u6cd5\u53d6\u5f97\u4e86\u4ee5\u4e0b\u6210\u679c\uff1a\n1. **s-rooted minimum cut (s-\u6709\u6839\u6700\u5c0f\u5272) \u8fd1\u4f3c**\uff1a\u5728 $m^{1+o(1)}$ \u65f6\u95f4\u5185\uff0c\u627e\u5230\u4e00\u4e2a\u8fd1\u4f3c\u5272\uff0c\u5176\u5927\u5c0f\u6700\u591a\u662f\u7cbe\u786e\u6700\u5c0f\u5272 $k$ \u7684 $O(\\log^5 n)$ \u500d\u3002\n2. **s-rooted arborescence packing (s-\u6709\u6839\u53d1\u6563\u6811\u6253\u5305) \u8fd1\u4f3c**\uff1a\u5728 $m^{1+o(1)}$ \u65f6\u95f4\u5185\uff0c\u80fd\u591f\u6253\u5305 $k$ \u68f5\u53d1\u6563\u6811\uff0c\u62e5\u585e\u5ea6\u4e3a $n^{o(1)}$\uff0c\u4ece\u800c\u8bc1\u660e\u6700\u5c0f\u5272\u7684\u4e0b\u754c\u4e3a $k / n^{o(1)}$\u3002\n\u8fd9\u4e9b\u7ed3\u679c\u5728\u8fd0\u884c\u65f6\u95f4\u4e0a\u662f\u51c6\u7ebf\u6027\u7684\uff08$m^{1+o(1)}$\uff09\uff0c\u663e\u8457\u4f18\u4e8e\u6b64\u524d\u7684\u8d85\u7ebf\u6027\u7cbe\u786e\u7b97\u6cd5\u3002", "conclusion": "\u672c\u6587\u4ecb\u7ecd\u4e86\u8fd1\u4f3c\u8ba1\u7b97\u6709\u6839\u6700\u5c0f\u5272\u548c\u6700\u5927\u53d1\u6563\u6811\u6253\u5305\u7684\u51c6\u7ebf\u6027\u65f6\u95f4\u7b97\u6cd5\uff0c\u8fd9\u662f\u4e24\u4e2a\u5bf9\u5076\u95ee\u9898\u3002\u8fd9\u4e9b\u7b97\u6cd5\u5728\u5904\u7406\u6709\u5411\u56fe\u65f6\uff0c\u5177\u6709\u663e\u8457\u7684\u6548\u7387\u4f18\u52bf\uff0c\u5c24\u5176\u662f\u5728\u6700\u5c0f\u5272\u503c\u8f83\u5927\u65f6\uff0c\u5176\u8fd0\u884c\u901f\u5ea6\u8d85\u8d8a\u4e86\u73b0\u6709\u7cbe\u786e\u7b97\u6cd5\u3002\u4f5c\u8005\u6307\u51fa\uff0c\u8fd9\u4e9b\u7b97\u6cd5\u4e3a\u8fd1\u4f3c\u8ba1\u7b97\u65b9\u6cd5\u5728\u5904\u7406\u56fe\u8bba\u4e2d\u7684\u57fa\u672c\u95ee\u9898\u63d0\u4f9b\u4e86\u65b0\u7684\u601d\u8def\u548c\u91cd\u8981\u8fdb\u5c55\u3002"}}
{"id": "2512.05224", "categories": ["cs.PL", "cs.DC"], "pdf": "https://arxiv.org/pdf/2512.05224", "abs": "https://arxiv.org/abs/2512.05224", "authors": ["Miguel de Oliveira Guerreiro"], "title": "NVLang: Unified Static Typing for Actor-Based Concurrency on the BEAM", "comment": "4 figures, 2 tables", "summary": "Actor-based systems like Erlang/OTP power critical infrastructure -- from telecommunications to messaging platforms--handling millions of concurrent connections with legendary reliability. Yet these systems lack static guarantees about message protocols: processes communicate by sending arbitrary messages that pattern-matched at runtime, deferring protocol violations to production failures.\n  We present NVLang, a statically typed functional language that brings comprehensive type safety to the BEAM virtual machine while preserving actor model's simplicity and power. NVLang's central contribution that algebraic data types (ADTs) naturally encode actor message protocols: each actor declares the sum type representing its message vocabulary, and the type system enforces protocol conformance at compile time. We introduce typed process identifiers (Pid[T]) that encode the protocol an actor expects, and typed futures (Future[T]) that provide type-safe request-reply patterns.\n  By extending Hindley-Milner type inference to track message protocols, NVLang eliminates an entire class of message-passing errors while maintaining clean syntax that rivals dynamically typed alternatives. Our implementation compiles to Core Erlang, enabling seamless interoperability with the existing Erlang ecosystem. We formalize the type system and provide proof sketches for type soundness, demonstrating that well-typed NVLang programs cannot send messages that violate actor protocols.", "AI": {"tldr": "\u6d89\u53ca\u9886\u57df\uff1aCompiler (NVLang \u7f16\u8bd1\u5230 Core Erlang)\u3002\n\u603b\u7ed3\uff1aNVLang\u662f\u4e00\u79cd\u9759\u6001\u7c7b\u578b\u7684\u529f\u80fd\u8bed\u8a00\uff0c\u65e8\u5728\u4e3a\u57fa\u4e8eActor\u7684\u7cfb\u7edf\uff08\u5982Erlang/OTP\uff09\u63d0\u4f9b\u7f16\u8bd1\u65f6\u7684\u6d88\u606f\u534f\u8bae\u7c7b\u578b\u5b89\u5168\u4fdd\u8bc1\u3002\u5b83\u901a\u8fc7\u4ee3\u6570\u6570\u636e\u7c7b\u578b\uff08ADTs\uff09\u6765\u7f16\u7801Actor\u7684\u6d88\u606f\u534f\u8bae\uff0c\u5e76\u5f15\u5165\u4e86\u7c7b\u578b\u5316\u7684\u8fdb\u7a0b\u6807\u8bc6\u7b26\uff08Pid[T]\uff09\u548cFuture\uff08Future[T]\uff09\u3002NVLang\u6269\u5c55\u4e86Hindley-Milner\u7c7b\u578b\u63a8\u65ad\u6765\u8ddf\u8e2a\u6d88\u606f\u534f\u8bae\uff0c\u4ece\u800c\u5728\u4fdd\u6301\u7b80\u6d01\u8bed\u6cd5\u7684\u540c\u4e8b\uff0c\u6d88\u9664\u4e86\u8fd0\u884c\u65f6\u6d88\u606f\u4f20\u9012\u9519\u8bef\uff0c\u5e76\u80fd\u65e0\u7f1d\u5730\u4e0e\u73b0\u6709Erlang\u751f\u6001\u7cfb\u7edf\u4e92\u64cd\u4f5c\u3002", "motivation": "\u73b0\u6709\u7684\u57fa\u4e8eActor\u7684\u7cfb\u7edf\uff08\u5982Erlang/OTP\uff09\u867d\u7136\u5177\u6709\u6781\u9ad8\u7684\u53ef\u9760\u6027\uff0c\u64c5\u957f\u5904\u7406\u6570\u767e\u4e07\u5e76\u53d1\u8fde\u63a5\uff0c\u4f46\u5728\u6d88\u606f\u534f\u8bae\u65b9\u9762\u7f3a\u4e4f\u9759\u6001\u4fdd\u8bc1\u3002\u8fdb\u7a0b\u4e4b\u95f4\u901a\u8fc7\u53d1\u9001\u4efb\u610f\u6d88\u606f\u5e76\u5728\u8fd0\u884c\u65f6\u8fdb\u884c\u6a21\u5f0f\u5339\u914d\uff0c\u5bfc\u81f4\u534f\u8bae\u8fdd\u89c4\u5728\u751f\u4ea7\u73af\u5883\u4e2d\u624d\u4f1a\u66b4\u9732\uff0c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u751f\u4ea7\u6545\u969c\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u65b9\u6cd5\u6765\u5728\u7f16\u8bd1\u65f6\u5f3a\u5236\u6267\u884c\u6d88\u606f\u534f\u8bae\u7684\u7c7b\u578b\u5b89\u5168\u3002", "method": "NVLang\u7684\u6838\u5fc3\u65b9\u6cd5\u662f\u5229\u7528\u4ee3\u6570\u6570\u636e\u7c7b\u578b\uff08ADTs\uff09\u6765\u81ea\u7136\u5730\u7f16\u7801Actor\u7684\u6d88\u606f\u534f\u8bae\u3002\u6bcf\u4e2aActor\u58f0\u660e\u4e00\u4e2a\u8868\u793a\u5176\u6d88\u606f\u8bcd\u6c47\u7684\u6c42\u548c\u7c7b\u578b\uff08sum type\uff09\uff0c\u7c7b\u578b\u7cfb\u7edf\u5728\u7f16\u8bd1\u65f6\u5f3a\u5236\u6267\u884c\u534f\u8bae\u4e00\u81f4\u6027\u3002\u8be5\u8bed\u8a00\u5f15\u5165\u4e86\u7c7b\u578b\u5316\u7684\u8fdb\u7a0b\u6807\u8bc6\u7b26\uff08Pid[T]\uff09\u548c\u7c7b\u578b\u5316\u7684Future\uff08Future[T]\uff09\uff0c\u4ee5\u786e\u4fdd\u7c7b\u578b\u5b89\u5168\u7684\u6d88\u606f\u4f20\u9012\u548c\u8bf7\u6c42-\u56de\u590d\u6a21\u5f0f\u3002\u901a\u8fc7\u6269\u5c55Hindley-Milner\u7c7b\u578b\u63a8\u65ad\u6765\u8ddf\u8e2a\u6d88\u606f\u534f\u8bae\uff0cNVLang\u53ef\u4ee5\u5728\u4e0d\u727a\u7272\u52a8\u6001\u7c7b\u578b\u66ff\u4ee3\u65b9\u6848\u7684\u7b80\u6d01\u8bed\u6cd5\u7684\u60c5\u51b5\u4e0b\uff0c\u6d88\u9664\u6d88\u606f\u4f20\u9012\u9519\u8bef\u3002 NVLang\u7684\u5b9e\u73b0\u7f16\u8bd1\u5230Core Erlang\u3002", "result": "NVLang\u662f\u4e00\u79cd\u9759\u6001\u7c7b\u578b\u7684\u529f\u80fd\u8bed\u8a00\uff0c\u5b83\u4e3aBEAM\u865a\u62df\u673a\u5e26\u6765\u4e86\u5168\u9762\u7684\u7c7b\u578b\u5b89\u5168\uff0c\u540c\u65f6\u4fdd\u7559\u4e86Actor\u6a21\u578b\u7684\u7b80\u6d01\u6027\u548c\u5f3a\u5927\u529f\u3002\u8be5\u8bed\u8a00\u901a\u8fc7\u5728\u7f16\u8bd1\u65f6\u5f3a\u5236\u6267\u884c\u6d88\u606f\u534f\u8bae\u7684\u4e00\u81f4\u6027\uff0c\u6d88\u9664\u4e86\u6574\u4e2a\u7c7b\u522b\u7684\u6d88\u606f\u4f20\u9012\u9519\u8bef\u3002\u5f62\u5f0f\u5316\u7684\u7c7b\u578b\u7cfb\u7edf\u548c\u7c7b\u578b\u5065\u5168\u6027\uff08type soundness\uff09\u8bc1\u660e\u8349\u56fe\u8868\u660e\uff0c\u7c7b\u578b\u826f\u597d\u7684NVLang\u7a0b\u5e8f\u4e0d\u4f1a\u53d1\u9001\u8fdd\u53cdActor\u534f\u8bae\u7684\u6d88\u606f\u3002\u6b64\u5916\uff0cNVLang\u5b9e\u73b0\u4e86\u4e0e\u73b0\u6709Erlang\u751f\u6001\u7cfb\u7edf\u7684\u65e0\u7f1d\u4e92\u64cd\u4f5c\u6027\u3002", "conclusion": "NVLang\u901a\u8fc7\u5f62\u5f0f\u5316\u7c7b\u578b\u7cfb\u7edf\u548c\u8bc1\u660e\u4fdd\u8bc1\u4e86\u7c7b\u578b\u5b89\u5168\u7279\u6027\uff0c\u5e76\u80fd\u7f16\u8bd1\u4e3aCore Erlang\uff0c\u5b9e\u73b0\u4e0e\u73b0\u6709Erlang\u751f\u6001\u7cfb\u7edf\u7684\u4e92\u64cd\u4f5c\u6027\u3002\u5b83\u5c55\u793a\u4e86\u9759\u6001\u7c7b\u578b\u65b9\u6cd5\u5728\u4fdd\u6301Actor\u6a21\u578b\u7684\u7b80\u6d01\u6027\u548c\u5f3a\u5927\u7684\u540c\u65f6\uff0c\u53ef\u4ee5\u6d88\u9664\u4e00\u7c7b\u8fd0\u884c\u65f6\u9519\u8bef\u3002"}}
{"id": "2512.05372", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.05372", "abs": "https://arxiv.org/abs/2512.05372", "authors": ["Chengjie Ma", "Seungeun Oh", "Jihong Park", "Seong-Lyun Kim"], "title": "FedGMR: Federated Learning with Gradual Model Restoration under Asynchrony and Model Heterogeneity", "comment": null, "summary": "Federated learning (FL) holds strong potential for distributed machine learning, but in heterogeneous environments, Bandwidth-Constrained Clients (BCCs) often struggle to participate effectively due to limited communication capacity. Their small sub-models learn quickly at first but become under-parameterized in later stages, leading to slow convergence and degraded generalization. We propose FedGMR - Federated Learning with Gradual Model Restoration under Asynchrony and Model Heterogeneity. FedGMR progressively increases each client's sub-model density during training, enabling BCCs to remain effective contributors throughout the process. In addition, we develop a mask-aware aggregation rule tailored for asynchronous MHFL and provide convergence guarantees showing that aggregated error scales with the average sub-model density across clients and rounds, while GMR provably shrinks this gap toward full-model FL. Extensive experiments on FEMNIST, CIFAR-10, and ImageNet-100 demonstrate that FedGMR achieves faster convergence and higher accuracy, especially under high heterogeneity and non-IID settings.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e**\u673a\u5668\u5b66\u4e60\uff08ML\uff09**\u548c**\u7f16\u8bd1\u5668**\uff08\u6d89\u53ca\u6a21\u578b\u7ed3\u6784\u548c\u4f18\u5316\uff09\u76f8\u5173\u3002\n**\u592a\u957f\u4e0d\u770b\u7248\u603b\u7ed3\uff1a**\u8bba\u6587\u63d0\u51fa\u4e86 FedGMR\uff0c\u4e00\u79cd\u5728\u5f02\u6b65\u548c\u6a21\u578b\u5f02\u6784\u7684\u8054\u90a6\u5b66\u4e60\uff08FL\uff09\u4e2d\uff0c\u901a\u8fc7\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u9010\u6b65\u589e\u52a0\u5e26\u5bbd\u53d7\u9650\u5ba2\u6237\u7aef\uff08BCCs\uff09\u5b50\u6a21\u578b\u5bc6\u5ea6\u7684\u65b9\u6cd5\u3002\u8fd9\u89e3\u51b3\u4e86 BCCs \u540e\u671f\u6536\u655b\u6162\u548c\u6cdb\u5316\u5dee\u7684\u95ee\u9898\u3002FedGMR \u8fd8\u5305\u542b\u4e00\u4e2a\u63a9\u7801\u611f\u77e5\u805a\u5408\u89c4\u5219\u548c\u7406\u8bba\u6536\u655b\u6027\u4fdd\u8bc1\u3002\u5b9e\u9a8c\u8bc1\u660e\uff0c\u5728\u9ad8\u5f02\u6784\u548c\u975e IID \u8bbe\u7f6e\u4e0b\uff0cFedGMR \u5b9e\u73b0\u4e86\u66f4\u5feb\u7684\u6536\u655b\u548c\u66f4\u9ad8\u7684\u51c6\u786e\u6027\u3002", "motivation": "\u73b0\u6709\u7684\u8054\u90a6\u5b66\u4e60\uff08FL\uff09\u5728\u5f02\u6784\u73af\u5883\u4e2d\uff0c\u7279\u522b\u662f\u9762\u4e34\u5e26\u5bbd\u53d7\u9650\u5ba2\u6237\u7aef\uff08BCCs\uff09\u65f6\uff0c\u6548\u7387\u4f4e\u4e0b\u3002\u8fd9\u4e9b\u5ba2\u6237\u7aef\u7684\u5b50\u6a21\u578b\uff08\u7531\u4e8e\u5e26\u5bbd\u9650\u5236\uff09\u5bb9\u91cf\u5c0f\uff0c\u867d\u7136\u521d\u671f\u5b66\u4e60\u5feb\uff0c\u4f46\u5728\u540e\u671f\u4f1a\u56e0\u4e3a**\u6b20\u53c2\u6570\u5316\uff08under-parameterized\uff09**\u800c\u5bfc\u81f4**\u6536\u655b\u7f13\u6162**\u548c**\u6cdb\u5316\u80fd\u529b\u4e0b\u964d**\uff0c\u4f7f\u5f97\u5b83\u4eec\u96be\u4ee5\u6301\u7eed\u6709\u6548\u5730\u53c2\u4e0e\u8bad\u7ec3\u3002\u56e0\u6b64\uff0c\u9700\u8981\u4e00\u79cd\u673a\u5236\u6765\u786e\u4fdd\u8fd9\u4e9b\u5e26\u5bbd\u53d7\u9650\u7684\u8bbe\u5907\u80fd\u591f\u5168\u7a0b\u4fdd\u6301\u5bf9\u5168\u5c40\u6a21\u578b\u7684\u6709\u6548\u8d21\u732e\u3002", "method": "\u6838\u5fc3\u65b9\u6cd5\u662f FedGMR (Federated Learning with Gradual Model Restoration)\uff0c\u5373\u5f02\u6b65\u548c\u6a21\u578b\u5f02\u6784\u73af\u5883\u4e0b\u5177\u5907\u7684\u9010\u6b65\u6a21\u578b\u6062\u590d\u529f\u80fd\u7684\u8054\u90a6\u5b66\u4e60\u3002\n\n\u5177\u4f53\u673a\u5236\u5305\u62ec\uff1a\n1. **\u9010\u6b65\u6a21\u578b\u5bc6\u5ea6\u589e\u52a0\uff08Gradual Model Restoration, GMR\uff09**\uff1a\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\uff0c\u9010\u6e10\u589e\u52a0\u5e26\u5bbd\u53d7\u9650\u5ba2\u6237\u7aef\uff08BCCs\uff09\u7684\u5b50\u6a21\u578b\u5bc6\u5ea6\uff0c\u786e\u4fdd\u8fd9\u4e9b\u5ba2\u6237\u7aef\u5728\u6574\u4e2a\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u4fdd\u6301\u9ad8\u6548\u7684\u8d21\u732e\u3002\n2. **\u63a9\u7801\u611f\u77e5\u805a\u5408\u89c4\u5219\uff08Mask-aware Aggregation Rule\uff09**\uff1a\u4e3a\u5f02\u6b65\u5f02\u6784\u8054\u90a6\u5b66\u4e60\uff08MHFL\uff09\u91cf\u8eab\u5b9a\u5236\u7684\u805a\u5408\u89c4\u5219\uff0c\u7528\u4e8e\u5904\u7406\u548c\u805a\u5408\u4e0d\u540c\u5bc6\u5ea6\u7684\u5b50\u6a21\u578b\u3002\n3. **\u7406\u8bba\u6536\u655b\u6027\u4fdd\u8bc1**\uff1a\u8bc1\u660e\u4e86\u805a\u5408\u8bef\u5dee\u4e0e\u5ba2\u6237\u7aef\u548c\u8f6e\u6b21\u4e4b\u95f4\u7684\u5e73\u5747\u5b50\u6a21\u578b\u5bc6\u5ea6\u6210\u6b63\u6bd4\uff0c\u5e76\u8bc1\u660e\u4e86 GMR \u80fd\u6709\u6548\u7f29\u5c0f\u8fd9\u4e00\u5dee\u8ddd\uff0c\u4f7f\u5176\u8d8b\u5411\u4e8e\u5168\u6a21\u578b FL \u7684\u6027\u80fd\u3002", "result": "1. **\u6027\u80fd\u63d0\u5347**\uff1aFedGMR \u5b9e\u73b0\u4e86\u66f4\u5feb\u7684\u6536\u655b\u901f\u5ea6\u548c\u66f4\u9ad8\u7684\u51c6\u786e\u6027\u3002\n2. **\u9002\u7528\u6027**\uff1a\u5c24\u5176\u5728**\u9ad8\u5f02\u6784\u6027\uff08high heterogeneity\uff09**\u548c**\u975e\u72ec\u7acb\u540c\u5206\u5e03\uff08non-IID\uff09**\u8bbe\u7f6e\u4e0b\uff0c\u6027\u80fd\u4f18\u52bf\u66f4\u4e3a\u663e\u8457\u3002\n3. **\u5b9e\u9a8c\u9a8c\u8bc1**\uff1a\u5728 FEMNIST, CIFAR-10, \u548c ImageNet-100 \u7b49\u591a\u4e2a\u6570\u636e\u96c6\u4e0a\u9a8c\u8bc1\u4e86\u5176\u6709\u6548\u6027\u3002\n4. **\u7406\u8bba\u652f\u6491**\uff1a\u63d0\u4f9b\u4e86\u6536\u655b\u6027\u4fdd\u8bc1\uff0c\u8868\u660e\u805a\u5408\u8bef\u5dee\u968f\u5e73\u5747\u5b50\u6a21\u578b\u5bc6\u5ea6\u53d8\u5316\uff0c\u4e14 GMR \u80fd\u591f\u6709\u6548\u5730\u51cf\u5c0f\u8bef\u5dee\uff0c\u63a5\u8fd1\u5168\u6a21\u578b FL \u7684\u8868\u73b0\u3002", "conclusion": "FedGMR \u662f\u4e00\u79cd\u5728\u5f02\u6b65\u548c\u6a21\u578b\u5f02\u6784\u73af\u5883\u4e0b\u5177\u5907\u9010\u6b65\u6a21\u578b\u6062\u590d\u529f\u80fd\u7684\u8054\u90a6\u5b66\u4e60\uff08FL\uff09\u65b9\u6cd5\uff0c\u5b83\u901a\u8fc7\u5728\u8bad\u7ec3\u8fc7\u7a0b\u4e2d\u9010\u6b65\u589e\u52a0\u5e26\u5bbd\u53d7\u9650\u5ba2\u6237\u7aef\u7684\u5b50\u6a21\u578b\u5bc6\u5ea6\uff0c\u6709\u6548\u5730\u89e3\u51b3\u4e86\u5b83\u4eec\u53c2\u4e0eFL\u65f6\u9762\u4e34\u7684\u6536\u655b\u6162\u548c\u6cdb\u5316\u80fd\u529b\u4e0b\u964d\u7684\u95ee\u9898\u3002\u9664\u4e86\u63d0\u51fa FedGMR\uff0c\u4f5c\u8005\u8fd8\u8bbe\u8ba1\u4e86\u4e00\u79cd\u9002\u7528\u4e8e\u5f02\u6b65 MHFL \u7684\u63a9\u7801\u611f\u77e5\u805a\u5408\u89c4\u5219\uff0c\u5e76\u5728\u7406\u8bba\u4e0a\u8bc1\u660e\u4e86\u5176\u6536\u655b\u6027\u4fdd\u8bc1\uff0c\u5c55\u793a\u4e86 GMR \u5982\u4f55\u6709\u6548\u5730\u7f29\u5c0f\u4e0e\u5168\u6a21\u578b FL \u4e4b\u95f4\u7684\u6027\u80fd\u5dee\u8ddd\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0cFedGMR \u5728\u9ad8\u5f02\u6784\u548c\u975e IID \u8bbe\u7f6e\u4e0b\uff0c\u5c24\u5176\u5728 FEMNIST\u3001CIFAR-10 \u548c ImageNet-100 \u6570\u636e\u96c6\u4e0a\uff0c\u5b9e\u73b0\u4e86\u66f4\u5feb\u7684\u6536\u655b\u901f\u5ea6\u548c\u66f4\u9ad8\u7684\u51c6\u786e\u6027\u3002"}}
{"id": "2512.05262", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2512.05262", "abs": "https://arxiv.org/abs/2512.05262", "authors": ["Daniel Nezamabadi", "Magnus O. Myreen", "Yong Kiam Tan"], "title": "Verified VCG and Verified Compiler for Dafny", "comment": "16 pages, 4 figures. To be published in CPP 2026. For mechanization, see https://github.com/CakeML/cakeml/tree/751ecd45c16b11ee0c3fd1280be7a6d798b5c457/compiler/dafny", "summary": "Dafny is a verification-aware programming language that comes with a compiler and static program verifier. However, neither the compiler nor the verifier is proved correct; in fact, soundness bugs have been found in both tools. This paper shows that the aforementioned Dafny tools can be developed with foundational correctness guarantees. We present a functional big-step semantics for an imperative subset of Dafny and, based on this semantics, a verified verification condition generator (VCG) and a verified compiler for Dafny. The subset of Dafny we have formalized includes mutually recursive method calls, while loops, and arrays -- these language features are significant enough to cover challenging examples such as McCarthy's 91 function and array-based programs that are used when teaching Dafny. The verified VCG allows one to prove functional correctness of annotated Dafny programs, while the verified compiler can be used to compile verified Dafny programs to CakeML programs. From there, one can obtain executable machine code via the (already verified) CakeML compiler, all while provably maintaining the functional correctness guarantees that were proved for the source-level Dafny programs. Our work has been mechanized in the HOL4 theorem prover.", "AI": {"tldr": "\u76f8\u5173\u9886\u57df\uff1aCompiler (\u7f16\u8bd1\u5668)\u3002\n\u592a\u957f\u4e0d\u770b\u6458\u8981\uff1aDafny \u7684\u7f16\u8bd1\u5668\u548c\u9a8c\u8bc1\u5668\u5b58\u5728\u53ef\u9760\u6027\u9519\u8bef\u3002\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u547d\u4ee4\u5f0f Dafny \u5b50\u96c6\u7684\u51fd\u6570\u5f0f\u5927\u6b65\u8bed\u4e49\uff0c\u5e76\u5728 HOL4 \u4e2d\u673a\u68b0\u5316\u9a8c\u8bc1\u4e86\u4e00\u4e2a\u57fa\u4e8e\u6b64\u8bed\u4e49\u7684\u9a8c\u8bc1\u6761\u4ef6\u751f\u6210\u5668\uff08VCG\uff09\u548c\u4e00\u4e2a\u7f16\u8bd1\u5668\u3002\u8fd9\u4f7f\u5f97\u7ecf\u8fc7\u9a8c\u8bc1\u7684 Dafny \u7a0b\u5e8f\u53ef\u4ee5\u88ab\u7f16\u8bd1\u6210 CakeML\uff08\u7136\u540e\u662f\u673a\u5668\u7801\uff09\uff0c\u540c\u65f6\u5f62\u5f0f\u5316\u5730\u4fdd\u8bc1\u4e86\u6e90\u7a0b\u5e8f\u7684\u529f\u80fd\u6b63\u786e\u6027\u3002", "motivation": "Dafny \u662f\u4e00\u79cd\u652f\u6301\u9a8c\u8bc1\u7684\u7f16\u7a0b\u8bed\u8a00\uff0c\u4f46\u5176\u7f16\u8bd1\u5668\u548c\u9759\u6001\u7a0b\u5e8f\u9a8c\u8bc1\u5668\u90fd\u6ca1\u6709\u7ecf\u8fc7\u6b63\u786e\u6027\u8bc1\u660e\uff0c\u5e76\u4e14\u5df2\u53d1\u73b0\u5b58\u5728\u53ef\u9760\u6027\u9519\u8bef\uff08soundness bugs\uff09\u3002\u7531\u4e8e\u8fd9\u4e9b\u5de5\u5177\u7f3a\u4e4f\u5f62\u5f0f\u5316\u7684\u6b63\u786e\u6027\u4fdd\u8bc1\uff0c\u5bfc\u81f4\u5bf9\u4f7f\u7528 Dafny \u9a8c\u8bc1\u5f97\u5230\u7684\u7a0b\u5e8f\u7684\u4fe1\u4efb\u5ea6\u5b58\u5728\u6f5c\u5728\u95ee\u9898\u3002\u56e0\u6b64\uff0c\u6709\u5fc5\u8981\u4e3a Dafny \u5de5\u5177\u5f00\u53d1\u5177\u6709\u5f62\u5f0f\u5316\u6b63\u786e\u6027\u4fdd\u8bc1\u7684\u7248\u672c\u3002", "method": "\u672c\u6587\u9996\u5148\u63d0\u51fa\u4e86\u4e00\u4e2a\u547d\u4ee4\u5f0f Dafny \u5b50\u96c6\uff08\u5305\u62ec\u76f8\u4e92\u9012\u5f52\u65b9\u6cd5\u8c03\u7528\u3001while \u5faa\u73af\u548c\u6570\u7ec4\uff09\u7684\u51fd\u6570\u5f0f\u5927\u6b65\u8bed\u4e49\u3002\u7136\u540e\uff0c\u57fa\u4e8e\u8be5\u8bed\u4e49\uff0c\u4f5c\u8005\u6784\u5efa\u4e86\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u9a8c\u8bc1\u6761\u4ef6\u751f\u6210\u5668\uff08VCG\uff09\u548c\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u7f16\u8bd1\u5668\u3002VCG \u7528\u4e8e\u8bc1\u660e\u5e26\u6ce8\u89e3 Dafny \u7a0b\u5e8f\u7684\u529f\u80fd\u6b63\u786e\u6027\uff0c\u800c\u7f16\u8bd1\u5668\u7528\u4e8e\u5c06\u7ecf\u8fc7\u9a8c\u8bc1\u7684 Dafny \u7a0b\u5e8f\u7f16\u8bd1\u6210 CakeML \u7a0b\u5e8f\uff0c\u8fdb\u800c\u901a\u8fc7\u5df2\u9a8c\u8bc1\u7684 CakeML \u7f16\u8bd1\u5668\u751f\u6210\u53ef\u6267\u884c\u673a\u5668\u7801\u3002\u6240\u6709\u5de5\u4f5c\u90fd\u5728 HOL4 \u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u8fdb\u884c\u4e86\u673a\u68b0\u5316\u3002", "result": "\u4f5c\u8005\u5f62\u5f0f\u5316\u4e86\u4e00\u4e2a\u5305\u542b\u76f8\u4e92\u9012\u5f52\u65b9\u6cd5\u8c03\u7528\u3001while \u5faa\u73af\u548c\u6570\u7ec4\u7b49\u91cd\u8981\u7279\u6027\u7684 Dafny \u5b50\u96c6\u3002\u57fa\u4e8e\u6b64\u5f62\u5f0f\u5316\uff0c\u4f5c\u8005\u5f00\u53d1\u4e86\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u9a8c\u8bc1\u6761\u4ef6\u751f\u6210\u5668\uff08VCG\uff09\u548c\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u7f16\u8bd1\u5668\u3002\u7ecf\u8fc7\u9a8c\u8bc1\u7684 VCG \u5141\u8bb8\u8bc1\u660e\u5e26\u6ce8\u89e3 Dafny \u7a0b\u5e8f\u7684\u529f\u80fd\u6b63\u786e\u6027\u3002\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u7f16\u8bd1\u5668\u53ef\u4ee5\u5c06\u7ecf\u8fc7\u9a8c\u8bc1\u7684 Dafny \u7a0b\u5e8f\u7f16\u8bd1\u6210 CakeML \u7a0b\u5e8f\uff0c\u5e76\u6700\u7ec8\u901a\u8fc7\u5df2\u9a8c\u8bc1\u7684 CakeML \u7f16\u8bd1\u5668\u751f\u6210\u53ef\u6267\u884c\u673a\u5668\u7801\uff0c\u6574\u4e2a\u8fc7\u7a0b\uff08\u4ece\u6e90\u8bed\u8a00\u7684\u529f\u80fd\u6b63\u786e\u6027\u8bc1\u660e\u5230\u673a\u5668\u7801\u6267\u884c\uff09\u90fd\u4fdd\u6301\u4e86\u529f\u80fd\u6b63\u786e\u6027\u4fdd\u8bc1\u3002\u8fd9\u4e00\u5de5\u4f5c\u5df2\u5728 HOL4 \u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u8fdb\u884c\u4e86\u673a\u68b0\u5316\u3002", "conclusion": "\u672c\u6587\u4ecb\u7ecd\u4e86\u5f62\u5f0f\u5316 Dafny \u4e00\u4e2a\u91cd\u8981\u5b50\u96c6\u7684\u51fd\u6570\u5f0f\u5927\u6b65\u8bed\u4e49\uff0c\u5e76\u57fa\u4e8e\u6b64\u8bed\u4e49\uff0c\u6784\u5efa\u4e86\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u9a8c\u8bc1\u6761\u4ef6\u751f\u6210\u5668\uff08VCG\uff09\u548c\u4e00\u4e2a\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u7f16\u8bd1\u5668\uff0c\u4e3a Dafny \u5de5\u5177\u94fe\u63d0\u4f9b\u4e86\u5f62\u5f0f\u5316\u7684\u6b63\u786e\u6027\u4fdd\u8bc1\u3002\u8fd9\u9879\u5de5\u4f5c\u5728 HOL4 \u5b9a\u7406\u8bc1\u660e\u5668\u4e2d\u8fdb\u884c\u4e86\u673a\u68b0\u5316\uff0c\u4f7f\u5f97\u5bf9\u7ecf\u8fc7\u9a8c\u8bc1\u7684 Dafny \u7a0b\u5e8f\u8fdb\u884c\u7f16\u8bd1\u540e\uff0c\u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 CakeML \u7f16\u8bd1\u5668\u83b7\u5f97\u53ef\u6267\u884c\u7684\u673a\u5668\u7801\uff0c\u540c\u65f6\u4fdd\u6301\u4e86\u6e90\u7a0b\u5e8f\u7684\u529f\u80fd\u6b63\u786e\u6027\u4fdd\u8bc1\u3002"}}
{"id": "2512.05543", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.05543", "abs": "https://arxiv.org/abs/2512.05543", "authors": ["Xuezhi Li", "Jiancong He", "Ming Xie", "Xuyang Chen", "Le Chang", "Li Jiang", "Gui Gui"], "title": "Are Bus-Mounted Edge Servers Feasible?", "comment": null, "summary": "Placement of edge servers is the prerequisite of provisioning edge computing services for Internet of Vehicles (IoV). Fixed-site edge servers at Road Side Units (RSUs) or base stations are able to offer basic service coverage for end users, i.e., vehicles on road. However, the server locations and capacity are fixed after deployment, rendering their inefficiency in handling spationtemporal user dynamics. Mobile servers such as buses, on the other hand, have the potential of adding computation elasticity to such system. To this end, this paper studies the feasibility of bus-mounted edge servers based on real traces. First, we investigate the coverage of the buses and base stations using the Shanghai bus/taxi/Telecom datasets, which shows a great potential of bus-based edge servers as they cover a great portion of geographic area and demand points. Next, we build a mathematical model and design a simple greedy heuristic algorithm to select a limited number of buses that maximizes the coverage of demand points, i.e., with a limited purchase budget. We perform trace-driven simulations to verify the performance of the proposed bus selection algorithm. The results show that our approach effectively handles the dynamic user demand under realistic constraints such as server capacity and purchase quantity. Thus, we claim: bus-mounted edge servers for vehicular networks in urban areas are feasible, beneficial, and valuable.", "AI": {"tldr": "\u5173\u8054\uff1a\u90fd\u4e0d\u76f8\u5173\u3002\u603b\u7ed3\uff1a\u672c\u6587\u7814\u7a76\u4e86\u5728\u8f66\u8054\u7f51\uff08IoV\uff09\u4e2d\u90e8\u7f72\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u7684\u53ef\u884c\u6027\u3002\u4e0e\u56fa\u5b9a\u7ad9\u70b9\u670d\u52a1\u5668\uff08\u5982RSU\u548c\u57fa\u7ad9\uff09\u76f8\u6bd4\uff0c\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u80fd\u4e3a\u7cfb\u7edf\u63d0\u4f9b\u8ba1\u7b97\u5f39\u6027\uff0c\u66f4\u6709\u6548\u5730\u5e94\u5bf9\u65f6\u7a7a\u53d8\u5316\u7684\u7528\u6237\u9700\u6c42\u3002\u4f5c\u8005\u5229\u7528\u4e0a\u6d77\u7684\u771f\u5b9e\u516c\u4ea4/\u51fa\u79df\u8f66/\u7535\u4fe1\u6570\u636e\u96c6\u8fdb\u884c\u4e86\u8986\u76d6\u8303\u56f4\u5206\u6790\uff0c\u5e76\u5efa\u7acb\u4e86\u4e00\u4e2a\u6570\u5b66\u6a21\u578b\u548c\u8bbe\u8ba1\u4e86\u4e00\u4e2a\u8d2a\u5a6a\u542f\u53d1\u5f0f\u7b97\u6cd5\uff0c\u4ee5\u5728\u6709\u9650\u9884\u7b97\u4e0b\u9009\u62e9\u6700\u5927\u5316\u8986\u76d6\u9700\u6c42\u70b9\u7684\u516c\u4ea4\u8f66\u3002\u4eff\u771f\u7ed3\u679c\u9a8c\u8bc1\u4e86\u8be5\u65b9\u6cd5\u5728\u5904\u7406\u52a8\u6001\u7528\u6237\u9700\u6c42\u548c\u73b0\u5b9e\u7ea6\u675f\u4e0b\u7684\u6709\u6548\u6027\u3002\u6700\u7ec8\u5f97\u51fa\u7ed3\u8bba\uff1a\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u5728\u57ce\u5e02\u8f66\u8054\u7f51\u4e2d\u662f\u53ef\u884c\u3001\u6709\u76ca\u4e14\u6709\u4ef7\u503c\u7684\u3002", "motivation": "\u4f20\u7edf\u7684\u8def\u8fb9\u5355\u5143\uff08RSU\uff09\u6216\u57fa\u7ad9\u7684\u56fa\u5b9a\u8fb9\u7f18\u670d\u52a1\u5668\u4f4d\u7f6e\u548c\u5bb9\u91cf\u662f\u56fa\u5b9a\u7684\uff0c\u5728\u5904\u7406\u65f6\u7a7a\u7528\u6237\u52a8\u6001\u65b9\u9762\u6548\u7387\u4f4e\u4e0b\u3002\u79fb\u52a8\u670d\u52a1\u5668\uff08\u5982\u516c\u4ea4\u8f66\uff09\u6709\u6f5c\u529b\u4e3a\u7cfb\u7edf\u589e\u52a0\u8ba1\u7b97\u5f39\u6027\u3002\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u76ee\u6807\uff0c\u672c\u6587\u7814\u7a76\u4e86\u57fa\u4e8e\u771f\u5b9e\u8f68\u8ff9\u7684\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u7684\u53ef\u884c\u6027\u3002", "method": "1. \u5229\u7528\u4e0a\u6d77\u7684\u516c\u4ea4/\u51fa\u79df\u8f66/\u7535\u4fe1\u6570\u636e\u96c6\uff0c\u8c03\u67e5\u4e86\u516c\u4ea4\u8f66\u548c\u57fa\u7ad9\u7684\u8986\u76d6\u8303\u56f4\uff0c\u8bc1\u660e\u4e86\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u7684\u5de8\u5927\u6f5c\u529b\u30022. \u5efa\u7acb\u4e86\u6570\u5b66\u6a21\u578b\uff0c\u5e76\u8bbe\u8ba1\u4e86\u4e00\u4e2a\u7b80\u5355\u7684\u8d2a\u5a6a\u542f\u53d1\u5f0f\u7b97\u6cd5\u6765\u9009\u62e9\u6709\u9650\u6570\u91cf\u7684\u516c\u4ea4\u8f66\uff0c\u4ee5\u6700\u5927\u5316\u5bf9\u9700\u6c42\u70b9\uff08\u5373\u7528\u6237\uff09\u7684\u8986\u76d6\u8303\u56f4\u30023. \u8fdb\u884c\u4e86\u8ddf\u8e2a\u9a71\u52a8\u7684\u4eff\u771f\uff0c\u4ee5\u9a8c\u8bc1\u6240\u63d0\u51fa\u516c\u4ea4\u8f66\u9009\u62e9\u7b97\u6cd5\u7684\u6027\u80fd\u3002", "result": "1. \u7814\u7a76\u7ed3\u679c\u8868\u660e\uff0c\u516c\u4ea4\u8f66\u8986\u76d6\u4e86\u5927\u91cf\u7684\u5730\u7406\u533a\u57df\u548c\u9700\u6c42\u70b9\uff0c\u8bc1\u660e\u4e86\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u7684\u5de8\u5927\u6f5c\u529b\u30022. \u8ddf\u8e2a\u9a71\u52a8\u7684\u4eff\u771f\u7ed3\u679c\u8868\u660e\uff0c\u6240\u63d0\u51fa\u7684\u7b97\u6cd5\u5728\u670d\u52a1\u5668\u5bb9\u91cf\u548c\u8d2d\u4e70\u6570\u91cf\u7b49\u73b0\u5b9e\u7ea6\u675f\u4e0b\uff0c\u80fd\u6709\u6548\u5730\u5904\u7406\u52a8\u6001\u7528\u6237\u9700\u6c42\u3002", "conclusion": "\u516c\u4ea4\u8f66\u8f7d\u8fb9\u7f18\u670d\u52a1\u5668\u5bf9\u4e8e\u57ce\u5e02\u8f66\u8054\u7f51\u6765\u8bf4\u662f\u53ef\u884c\u3001\u6709\u76ca\u4e14\u6709\u4ef7\u503c\u7684\u3002"}}
{"id": "2512.05516", "categories": ["cs.PL", "cs.DC", "cs.MS"], "pdf": "https://arxiv.org/pdf/2512.05516", "abs": "https://arxiv.org/abs/2512.05516", "authors": ["Pawel K. Radtke", "Tobias Weinzierl"], "title": "Compiler-supported reduced precision and AoS-SoA transformations for heterogeneous hardware", "comment": null, "summary": "This study evaluates AoS-to-SoA transformations over reduced-precision data layouts for a particle simulation code on several GPU platforms: We hypothesize that SoA fits particularly well to SIMT, while AoS is the preferred storage format for many Lagrangian codes. Reduced-precision (below IEEE accuracy) is an established tool to address bandwidth constraints, although it remains unclear whether AoS and precision conversions should execute on a CPU or be deployed to a GPU if the compute kernel itself must run on an accelerator. On modern superchips where CPUs and GPUs share (logically) one data space, it is also unclear whether it is advantageous to stream data to the accelerator prior to the calculation, or whether we should let the accelerator transform data on demand, i.e.~work in-place logically. We therefore introduce compiler annotations to facilitate such conversions and to give the programmer the option to orchestrate the conversions in combination with GPU offloading. For some of our compute kernels of interest, Nvidia's G200 platforms yield a speedup of around 2.6 while AMD's MI300A exhibits more robust performance yet profits less. We assume that our compiler-based techniques are applicable to a wide variety of Lagrangian codes and beyond.", "AI": {"tldr": "\u5173\u8054\uff1a\u7f16\u8bd1\u5668\uff08Compiler\uff09\u3001\u56fe\u5904\u7406\uff08Graph Processing\uff09\u3001HLS\uff08High-Level Synthesis\uff09\u3002\n\u603b\u7ed3\uff1a\u672c\u6587\u8bc4\u4f30\u4e86\u5728\u57fa\u4e8e GPU \u7684\u7c92\u5b50\u6a21\u62df\u4ee3\u7801\u4e2d\uff0c\u5e94\u7528 AoS-to-SoA \u8f6c\u6362\u548c\u51cf\u5c11\u7cbe\u5ea6\u6570\u636e\u5e03\u5c40\u7684\u6548\u679c\u3002\u7814\u7a76\u52a8\u673a\u5728\u4e8e AoS \u5c3d\u7ba1\u662f\u8bb8\u591a\u62c9\u683c\u6717\u65e5\u4ee3\u7801\u7684\u9996\u9009\uff0c\u4f46 SoA \u66f4\u9002\u5408 SIMT \u67b6\u6784\uff1b\u540c\u65f6\uff0c\u4e0d\u786e\u5b9a\u6570\u636e\u8f6c\u6362\uff08\u683c\u5f0f\u548c\u7cbe\u5ea6\uff09\u4ee5\u53ca GPU \u5378\u8f7d\u5e94\u8be5\u5728 CPU \u7aef\u8fd8\u662f GPU \u7aef\u8fdb\u884c\uff0c\u5c24\u5176\u662f\u5728 CPU/GPU \u5171\u4eab\u5185\u5b58\u7684\u73b0\u4ee3\u8d85\u7ea7\u82af\u7247\u4e0a\u3002\u4e3a\u6b64\uff0c\u8bba\u6587\u5f15\u5165\u4e86\u7f16\u8bd1\u5668\u6ce8\u89e3\u6765\u5e2e\u52a9\u7a0b\u5e8f\u5458\u534f\u8c03\u8fd9\u4e9b\u8f6c\u6362\uff0c\u5e76\u4e0e GPU \u5378\u8f7d\u7ed3\u5408\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u5728 Nvidia G200 \u5e73\u53f0\u4e0a\u83b7\u5f97\u4e86\u7ea6 2.6 \u500d\u7684\u52a0\u901f\uff0c\u800c AMD MI300A \u5e73\u53f0\u6027\u80fd\u66f4\u7a33\u5b9a\u4f46\u52a0\u901f\u8f83\u5c11\uff0c\u8fd9\u8868\u660e\u57fa\u4e8e\u7f16\u8bd1\u5668\u7684\u8f6c\u6362\u6280\u672f\u5bf9\u4e8e\u5e7f\u6cdb\u7684\u62c9\u683c\u6717\u65e5\u4ee3\u7801\u5177\u6709\u6f5c\u5728\u5e94\u7528\u3002", "motivation": "\u8bb8\u591a\u62c9\u683c\u6717\u65e5\u4ee3\u7801\u503e\u5411\u4e8e\u4f7f\u7528 AoS \u5b58\u50a8\u683c\u5f0f\uff0c\u4f46\u7814\u7a76\u5047\u8bbe SoA \u683c\u5f0f\u66f4\u9002\u5408 SIMT \u67b6\u6784\u7684 GPU\u3002\u5f53\u8ba1\u7b97\u5185\u6838\u9700\u8981\u5728\u52a0\u901f\u5668\u4e0a\u8fd0\u884c\u65f6\uff0c\u4f7f\u7528\u4f4e\u4e8e IEEE \u7cbe\u5ea6\u7684\u51cf\u5c11\u7cbe\u5ea6\u6570\u636e\u4f5c\u4e3a\u89e3\u51b3\u5e26\u5bbd\u74f6\u9888\u7684\u65b9\u6cd5\uff0c\u7136\u800c\uff0c\u4e0d\u6e05\u695a AoS \u548c\u7cbe\u5ea6\u8f6c\u6362\u5e94\u8be5\u5728 CPU \u4e0a\u6267\u884c\u8fd8\u662f\u90e8\u7f72\u5230 GPU \u4e0a\u3002\u6b64\u5916\uff0c\u5728 CPU \u548c GPU \u5171\u4eab\uff08\u903b\u8f91\u4e0a\uff09\u540c\u4e00\u6570\u636e\u7a7a\u95f4\u7684\u73b0\u4ee3\u8d85\u7ea7\u82af\u7247\u4e0a\uff0c\u7814\u7a76\u4e0d\u786e\u5b9a\u662f\u5728\u8ba1\u7b97\u524d\u5c06\u6570\u636e\u6d41\u5f0f\u4f20\u8f93\u5230\u52a0\u901f\u5668\u4e0a\uff0c\u8fd8\u662f\u8ba9\u52a0\u901f\u5668\u6309\u9700\u8f6c\u6362\u6570\u636e\uff08\u5373\u903b\u8f91\u4e0a\u539f\u5730\u5de5\u4f5c\uff09\u66f4\u6709\u5229\u3002\u56e0\u6b64\uff0c\u9700\u8981\u673a\u5236\u6765\u4fc3\u8fdb\u8fd9\u79cd\u8f6c\u6362\u5e76\u4e3a\u7a0b\u5e8f\u5458\u63d0\u4f9b\u534f\u8c03\u8f6c\u6362\u7684\u9009\u9879\u3002", "method": "\u7814\u7a76\u901a\u8fc7\u5f15\u5165\u7f16\u8bd1\u5668\u6ce8\u89e3\u6765\u4fc3\u8fdb AoS-to-SoA \u8f6c\u6362\u4ee5\u53ca\u51cf\u5c11\u7cbe\u5ea6\u7684\u6570\u636e\u5e03\u5c40\uff0c\u4f7f\u5176\u80fd\u591f\u4e0e GPU \u5378\u8f7d\u76f8\u7ed3\u5408\uff0c\u5141\u8bb8\u7a0b\u5e8f\u5458\u534f\u8c03\u6570\u636e\u8f6c\u6362\u7684\u6267\u884c\u4f4d\u7f6e\uff08CPU \u6216 GPU\uff09\uff0c\u5e76\u5c06\u5176\u5e94\u7528\u4e8e\u7c92\u5b50\u6a21\u62df\u4ee3\u7801\u8fdb\u884c\u8bc4\u4f30\u3002", "result": "\u5728 Nvidia G200 \u5e73\u53f0\u4e0a\uff0c\u5bf9\u4e8e\u5173\u6ce8\u7684\u8ba1\u7b97\u5185\u6838\uff0cAoS-to-SoA \u8f6c\u6362\u548c\u51cf\u5c11\u7cbe\u5ea6\u6570\u636e\u5e03\u5c40\u7684\u4f18\u5316\u5e26\u6765\u4e86\u7ea6 2.6 \u500d\u7684\u52a0\u901f\u3002AMD MI300A \u5e73\u53f0\u8868\u73b0\u51fa\u66f4\u7a33\u5b9a\u7684\u6027\u80fd\uff0c\u4f46\u83b7\u76ca\u8f83\u5c11\u3002\u8fd9\u9879\u57fa\u4e8e\u7f16\u8bd1\u5668\u7684\u8f6c\u6362\u6280\u672f\u88ab\u5047\u8bbe\u53ef\u5e94\u7528\u4e8e\u591a\u79cd\u62c9\u683c\u6717\u65e5\u4ee3\u7801\u53ca\u5176\u4ed6\u9886\u57df\u3002", "conclusion": "\u8be5\u7814\u7a76\u63d0\u51fa\u4e86\u7f16\u8bd1\u5668\u6ce8\u89e3\u6765\u4fc3\u8fdb AoS-to-SoA \u8f6c\u6362\uff0c\u5e76\u5141\u8bb8\u7a0b\u5e8f\u5458\u5728 GPU \u5378\u8f7d\u7684\u540c\u65f6\u534f\u8c03\u8fd9\u4e9b\u8f6c\u6362\u3002\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u5728 Nvidia G200 \u5e73\u53f0\u4e0a\uff0c\u5bf9\u4e8e\u67d0\u4e9b\u8ba1\u7b97\u5185\u6838\uff0c\u6027\u80fd\u63d0\u5347\u7ea6\u4e3a 2.6 \u500d\uff0c\u800c\u5728 AMD MI300A \u5e73\u53f0\u4e0a\uff0c\u6027\u80fd\u63d0\u5347\u8f83\u5c0f\uff0c\u4f46\u6027\u80fd\u66f4\u7a33\u5b9a\u3002\u7814\u7a76\u5047\u8bbe\u5176\u57fa\u4e8e\u7f16\u8bd1\u5668\u7684\u6280\u672f\u9002\u7528\u4e8e\u5e7f\u6cdb\u7684\u62c9\u683c\u6717\u65e5\u4ee3\u7801\u53ca\u5176\u4ed6\u9886\u57df\uff0c\u5e76\u5efa\u8bae\u5728\u5177\u6709\u7edf\u4e00\u5185\u5b58\u7684\u73b0\u4ee3\u8d85\u7ea7\u82af\u7247\u4e0a\uff0c\u6570\u636e\u683c\u5f0f\u8f6c\u6362\u53ef\u4ee5\u8003\u8651\u5728 GPU \u4e0a\u6309\u9700\u8fdb\u884c\u3002"}}
{"id": "2512.05555", "categories": ["cs.PL", "cs.OS", "cs.SE"], "pdf": "https://arxiv.org/pdf/2512.05555", "abs": "https://arxiv.org/abs/2512.05555", "authors": ["Alexey Paznikov", "Andrey Kogutenko", "Yaroslav Osipov", "Michael Schwarz", "Umang Mathur"], "title": "Compiling Away the Overhead of Race Detection", "comment": "35 pages", "summary": "Dynamic data race detectors are indispensable for flagging concurrency errors in software, but their high runtime overhead limits their adoption. This overhead stems primarily from pervasive instrumentation of memory accesses - a significant fraction of which is redundant. We addresses this inefficiency through a static, compiler-integrated approach that identifies and eliminates redundant instrumentation, drastically reducing the runtime cost of dynamic data race detectors. We introduce a suite of interprocedural static analyses reasoning about memory access patterns, synchronization, and thread creation to eliminate instrumentation for provably race-free accesses and show that the completeness properties of the data race detector are preserved. We further observe that many inserted checks flag a race if and only if a preceding check has already flagged an equivalent race for the same memory location - albeit potentially at a different access. We characterize this notion of equivalence and show that, when limiting reporting to at least one representative for each equivalence class, a further class of redundant checks can be eliminated. We identify such accesses using a novel dominance-based elimination analysis. Based on these two insights, we have implemented five static analyses within the LLVM, integrated with the instrumentation pass of the race detector ThreadSanitizer. Our experimental evaluation on a diverse suite of real-world applications demonstrates that our approach significantly reduces race detection overhead, achieving a geomean speedup of 1.34x, with peak speedups reaching 2.5x under high thread contention. This performance is achieved with a negligible increase in compilation time and, being fully automatic, places no additional burden on developers. Our optimizations have been accepted by the ThreadSanitizer maintainers and are in the process of being upstreamed.", "AI": {"tldr": "\u8be5\u8bba\u6587\u4e0e\u7f16\u8bd1\u5668\u3001\u56fe\u5904\u7406\uff08\u95f4\u63a5\u6d89\u53ca\uff0c\u56e0\u4e3a\u9759\u6001\u5206\u6790\u548cLLVM IR\u5904\u7406\u53ef\u4ee5\u89c6\u4e3a\u56fe\u7ed3\u6784\u4e0a\u7684\u5206\u6790\uff09\u548cMLIR\uff08\u4e0e\u7f16\u8bd1\u5668\u76f8\u5173\uff0c\u867d\u7136\u672a\u76f4\u63a5\u63d0\u53ca\uff09\u76f8\u5173\u3002\u4e0eHLS\u548cDSL\u4e0d\u76f4\u63a5\u76f8\u5173\u3002\n\n**TLDR \u6458\u8981:** \u52a8\u6001\u6570\u636e\u7ade\u4e89\u68c0\u6d4b\u5668\u56e0\u5197\u4f59\u5185\u5b58\u8bbf\u95ee\u63d2\u6869\u5bfc\u81f4\u5f00\u9500\u5927\uff0c\u9650\u5236\u4e86\u5176\u5e94\u7528\u3002\u672c\u6587\u63d0\u51fa\u4e00\u4e2a\u7f16\u8bd1\u5668\u96c6\u6210\uff08\u57fa\u4e8eLLVM\uff0c\u96c6\u6210\u5230ThreadSanitizer\uff09\u7684\u9759\u6001\u5206\u6790\u65b9\u6cd5\uff0c\u901a\u8fc7\u8fc7\u7a0b\u95f4\u5206\u6790\u6d88\u9664\u5bf9\u786e\u5b9a\u65e0\u7ade\u4e89\u8bbf\u95ee\u7684\u63d2\u6869\uff0c\u5e76\u5f15\u5165\u57fa\u4e8e\u652f\u914d\u6027\u7684\u6d88\u9664\u5206\u6790\u6765\u6392\u9664\u62a5\u544a\u91cd\u590d\u7b49\u6548\u7ade\u4e89\u7684\u68c0\u67e5\u70b9\u3002\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u5728\u4fdd\u6301\u68c0\u6d4b\u5b8c\u6574\u6027\u7684\u524d\u63d0\u4e0b\uff0c\u5b9e\u73b0\u4e86\u5e73\u57471.34\u500d\u3001\u5cf0\u503c2.5\u500d\u7684\u52a0\u901f\uff0c\u663e\u8457\u964d\u4f4e\u4e86\u6570\u636e\u7ade\u4e89\u68c0\u6d4b\u7684\u8fd0\u884c\u65f6\u5f00\u9500\u3002\u8be5\u4f18\u5316\u5df2\u88abThreadSanitizer\u63a5\u53d7\u3002", "motivation": "\u52a8\u6001\u6570\u636e\u7ade\u4e89\u68c0\u6d4b\u5668\uff08\u5982ThreadSanitizer\uff09\u56e0\u5176\u9ad8\u6602\u7684\u8fd0\u884c\u65f6\u5f00\u9500\u800c\u9650\u5236\u4e86\u5176\u5e94\u7528\uff0c\u8fd9\u79cd\u5f00\u9500\u4e3b\u8981\u6e90\u4e8e\u5bf9\u5185\u5b58\u8bbf\u95ee\u7684\u666e\u904d\u63d2\u6869\uff0c\u5176\u4e2d\u5f88\u5927\u4e00\u90e8\u5206\u662f\u5197\u4f59\u7684\u3002\u672c\u6587\u7684\u52a8\u673a\u5728\u4e8e\u901a\u8fc7\u9759\u6001\u3001\u7f16\u8bd1\u5668\u96c6\u6210\u7684\u4f18\u5316\u65b9\u6cd5\uff0c\u8bc6\u522b\u5e76\u6d88\u9664\u8fd9\u4e9b\u5197\u4f59\u63d2\u6869\uff0c\u4ece\u800c\u663e\u8457\u964d\u4f4e\u52a8\u6001\u6570\u636e\u7ade\u4e89\u68c0\u6d4b\u5668\u7684\u8fd0\u884c\u65f6\u6210\u672c\u3002", "method": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u4e2a\u7f16\u8bd1\u5668\u96c6\u6210\u7684\u9759\u6001\u5206\u6790\u65b9\u6cd5\u6765\u6d88\u9664\u5197\u4f59\u63d2\u6869\u3002\u5177\u4f53\u65b9\u6cd5\u5305\u62ec\uff1a1. \u5f15\u5165\u4e00\u5957\u8fc7\u7a0b\u95f4\u9759\u6001\u5206\u6790\uff0c\u63a8\u7406\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\u3001\u540c\u6b65\u548c\u7ebf\u7a0b\u521b\u5efa\uff0c\u4ee5\u6d88\u9664\u5bf9\u786e\u5b9a\u65e0\u7ade\u4e89\u8bbf\u95ee\u7684\u63d2\u6869\uff0c\u540c\u65f6\u4fdd\u8bc1\u6570\u636e\u7ade\u4e89\u68c0\u6d4b\u5668\u7684\u5b8c\u6574\u6027\u30022. \u63d0\u51fa\u4e00\u79cd\u57fa\u4e8e\u652f\u914d\u6027\u7684\u6d88\u9664\u5206\u6790\uff0c\u8bc6\u522b\u5e76\u6d88\u9664\u90a3\u4e9b\u62a5\u544a\u7684\u7ade\u4e89\u4e0e\u5148\u524d\u5df2\u62a5\u544a\u7684\u7b49\u6548\u7ade\u4e89\u91cd\u590d\u7684\u68c0\u67e5\u70b9\uff0c\u901a\u8fc7\u9650\u5236\u6bcf\u4e2a\u7b49\u4ef7\u7c7b\u53ea\u62a5\u544a\u81f3\u5c11\u4e00\u4e2a\u4ee3\u8868\u6027\u7ade\u4e89\u6765\u5b9e\u73b0\u8fdb\u4e00\u6b65\u7684\u4f18\u5316\u30023. \u4ee5\u4e0a\u4e24\u79cd\u6d1e\u89c1\u5728LLVM\u4e2d\u5b9e\u73b0\u4e3a\u4e94\u4e2a\u9759\u6001\u5206\u6790\uff0c\u5e76\u96c6\u6210\u5230ThreadSanitizer\u7684\u63d2\u6869\u8fc7\u7a0b\u4e2d\u3002", "result": "\u6240\u63d0\u51fa\u7684\u4f18\u5316\u65b9\u6cd5\u5728\u591a\u6837\u5316\u7684\u771f\u5b9e\u4e16\u754c\u5e94\u7528\u5957\u4ef6\u4e0a\u7684\u5b9e\u9a8c\u8bc4\u4f30\u8868\u660e\uff0c\u5b83\u663e\u8457\u51cf\u5c11\u4e86\u7ade\u4e89\u68c0\u6d4b\u7684\u5f00\u9500\u3002\u5b9e\u73b0\u4e86\u5e73\u57471.34\u500d\u7684\u51e0\u4f55\u5e73\u5747\u52a0\u901f\u6bd4\uff0c\u5728\u7ebf\u7a0b\u7ade\u4e89\u6fc0\u70c8\u7684\u60c5\u51b5\u4e0b\uff0c\u5cf0\u503c\u52a0\u901f\u6bd4\u8fbe\u52302.5\u500d\u3002\u8be5\u6027\u80fd\u63d0\u5347\u662f\u5728\u7f16\u8bd1\u65f6\u95f4\u589e\u52a0\u53ef\u5ffd\u7565\u4e0d\u8ba1\u7684\u60c5\u51b5\u4e0b\u5b9e\u73b0\u7684\uff0c\u800c\u4e14\u662f\u5168\u81ea\u52a8\u7684\uff0c\u4e0d\u4f1a\u7ed9\u5f00\u53d1\u4eba\u5458\u5e26\u6765\u989d\u5916\u8d1f\u62c5\u3002\u8be5\u4f18\u5316\u5df2\u88abThreadSanitizer\u7ef4\u62a4\u8005\u63a5\u53d7\u5e76\u6b63\u5728\u96c6\u6210\u5230\u4e0a\u6e38\u4ee3\u7801\u4e2d\u3002", "conclusion": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u9759\u6001\u3001\u7f16\u8bd1\u5668\u96c6\u6210\u7684\u4f18\u5316\u65b9\u6cd5\uff0c\u901a\u8fc7\u8bc6\u522b\u548c\u6d88\u9664\u5197\u4f59\u7684\u5185\u5b58\u8bbf\u95ee\u63d2\u6869\uff0c\u663e\u8457\u964d\u4f4e\u4e86\u52a8\u6001\u6570\u636e\u7ade\u4e89\u68c0\u6d4b\u5668\u7684\u8fd0\u884c\u65f6\u5f00\u9500\u3002\u5b9e\u9a8c\u7ed3\u679c\u8868\u660e\uff0c\u8be5\u65b9\u6cd5\u5728\u4fdd\u6301\u68c0\u6d4b\u5b8c\u6574\u6027\u7684\u540c\u65f6\uff0c\u5b9e\u73b0\u4e86\u5e73\u57471.34\u500d\u3001\u5cf0\u503c2.5\u500d\u7684\u52a0\u901f\u6548\u679c\u3002\u8be5\u4f18\u5316\u5df2\u88abThreadSanitizer\u7ef4\u62a4\u8005\u63a5\u53d7\u5e76\u6b63\u5728\u96c6\u6210\u5230\u4e0a\u6e38\u4ee3\u7801\u4e2d\uff0c\u8bc1\u660e\u4e86\u5176\u6709\u6548\u6027\u548c\u5b9e\u7528\u6027\u3002"}}
