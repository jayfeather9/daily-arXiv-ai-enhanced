{"id": "2602.12295", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.12295", "abs": "https://arxiv.org/abs/2602.12295", "authors": ["R. Kanda", "N. Onizawa", "M. Leonardon", "V. Gripon", "T. Hanyu"], "title": "Design Environment of Quantization-Aware Edge AI Hardware for Few-Shot Learning", "comment": null, "summary": "This study aims to ensure consistency in accuracy throughout the entire design flow in the implementation of edge AI hardware for few-shot learning, by implementing fixed-point data processing in the pre-training and evaluation phases. Specifically, the quantization module, called Brevitas, is applied to implement fixed-point data processing, which allows for arbitrary specification of the bit widths for the integer and fractional parts. Two methods of fixed-point data quantization, quantization-aware training (QAT) and post-training quantization (PTQ), are utilized in Brevitas. With Tensil, which is used in the current design flow, the bit widths of the integer and fractional parts need to be 8 bits each or 16 bits each when implemented in hardware, but performance validation has shown that accuracy comparable to floating-point operations can be maintained even with 6 bits or 5 bits each, indicating potential for further reduction in computational resources. These results clearly contribute to the creation of a versatile design and evaluation environment for edge AI hardware for few-shot learning."}
{"id": "2602.12422", "categories": ["cs.AR", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2602.12422", "abs": "https://arxiv.org/abs/2602.12422", "authors": ["Kaushal Mhapsekar", "Azam Ghanbari", "Bita Aslrousta", "Samira Mirbagher-Ajorpaz"], "title": "CacheMind: From Miss Rates to Why -- Natural-Language, Trace-Grounded Reasoning for Cache Replacement", "comment": "16 pages, 13 figures, ASPLOS 2026", "summary": "Cache replacement remains a challenging problem in CPU microarchitecture, often addressed using hand-crafted heuristics, limiting cache performance. Cache data analysis requires parsing millions of trace entries with manual filtering, making the process slow and non-interactive. To address this, we introduce CacheMind, a conversational tool that uses Retrieval-Augmented Generation (RAG) and Large Language Models (LLMs) to enable semantic reasoning over cache traces. Architects can now ask natural language questions like, \"Why is the memory access associated with PC X causing more evictions?\", and receive trace-grounded, human-readable answers linked to program semantics for the first time. To evaluate CacheMind, we present CacheMindBench, the first verified benchmark suite for LLM-based reasoning for the cache replacement problem. Using the SIEVE retriever, CacheMind achieves 66.67% on 75 unseen trace-grounded questions and 84.80% on 25 unseen policy-specific reasoning tasks; with RANGER, it achieves 89.33% and 64.80% on the same evaluations. Additionally, with RANGER, CacheMind achieves 100% accuracy on 4 out of 6 categories in the trace-grounded tier of CacheMindBench. Compared to LlamaIndex (10% retrieval success), SIEVE achieves 60% and RANGER achieves 90%, demonstrating that existing Retrieval-Augmented Generation (RAGs) are insufficient for precise, trace-grounded microarchitectural reasoning. We provided four concrete actionable insights derived using CacheMind, wherein bypassing use case improved cache hit rate by 7.66% and speedup by 2.04%, software fix use case gives speedup of 76%, and Mockingjay replacement policy use case gives speedup of 0.7%; showing the utility of CacheMind on non-trivial queries that require a natural-language interface."}
{"id": "2602.12480", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.12480", "abs": "https://arxiv.org/abs/2602.12480", "authors": ["George Karfakis", "Samyak Chakrabarty", "Vinod Kurian Jacob", "Siyun Qiao", "Subramanian S. Iyer", "Sudhakar Pamarti", "Puneet Gupta"], "title": "MXFormer: A Microscaling Floating-Point Charge-Trap Transistor Compute-in-Memory Transformer Accelerator", "comment": null, "summary": "The proliferation of Transformer models is often constrained by the significant computational and memory bandwidth demands of deployment. To address this, we present MXFormer, a novel, hybrid, weight-stationary Compute-in-Memory (CIM) accelerator that provides high throughput and efficiency for fixed-model inference on large short-sequence Transformers. Our architecture's foundation is the use of ultra-dense Charge-Trap Transistors (CTTs) in Microscaling MXFP4 CIM arrays, uniquely enabling the on-chip storage of up to hundreds of millions of parameters in Fully Weight Stationary (FWS) fashion.\n  We introduce a statically partitioned design with 12 Transformer blocks connected by a deeply pipelined dataflow. Static-weight layers (MLPs and linear projections) execute on highly parallel analog CTT arrays using an MXFP4-native flow with per-block exponent alignment and a 10-bit SAR ADC. Dynamic computations are handled in fully accurate digital blocks that utilize MXFP-enabled systolic arrays for scaled dot-product attention and vector units for LayerNorm and FlashAttention-style Softmax.\n  By eliminating all weight movement, the deeply pipelined MXFormer architecture yields very high single-stream throughput and efficiency, processing 58275 FPS on ViT-L/32 (dual-chip) or 41269 FPS on ViT-B/16 (single chip). MXFormer outperforms comparable state-of-the-art non-FWS digital, hybrid and photonic Transformer accelerators ~3.3x-60.5x in compute density and ~1.7x-2.5x in energy efficiency. Against FWS accelerators, MXFormer improves compute density by ~20.9x and resident weight storage density by ~2x, while preserving near-digital accuracy (drop of <1%) without any model retraining."}
{"id": "2602.12596", "categories": ["cs.AR", "cs.NI"], "pdf": "https://arxiv.org/pdf/2602.12596", "abs": "https://arxiv.org/abs/2602.12596", "authors": ["Johnson Umeike", "Pongstorn Maidee", "Bahar Asgari"], "title": "Arcalis: Accelerating Remote Procedure Calls Using a Lightweight Near-Cache Solution", "comment": null, "summary": "Modern microservices increasingly depend on high-performance remote procedure calls (RPCs) to coordinate fine-grained, distributed computation. As network bandwidths continue to scale, the CPU overhead associated with RPC processing, particularly serialization, deserialization, and protocol handling, has become a critical bottleneck. This challenge is exacerbated by fast user-space networking stacks such as DPDK, which expose RPC processing as the dominant performance limiter. While prior work has explored software optimizations and FPGA-based offload engines, these approaches remain physically distant from the CPU's memory hierarchy, incurring unnecessary data movement and cache pollution. We present Arcalis, a near-cache RPC accelerator that positions a lightweight hardware engine adjacent to the last-level cache (LLC). Arcalis offloads RPC processing to dedicated microengines on receive and transmit paths that operate with cache-line latency while preserving programmability. By decoupling RPC processing logic, enabling microservice-specific execution, and positioning itself near the LLC to immediately consume data injected by network cards, Arcalis achieves 1.79-4.16$\\times$ end-to-end speedup compared to the CPU baseline, while significantly reducing microarchitectural overhead by up to 88%, and achieves up to a 1.62$\\times$ higher throughput than prior solutions. These results highlight the potential of near-cache RPC acceleration as a practical solution for high-performance microservice deployment."}
{"id": "2602.12446", "categories": ["cs.DS", "cs.LO"], "pdf": "https://arxiv.org/pdf/2602.12446", "abs": "https://arxiv.org/abs/2602.12446", "authors": ["Binh-Minh Bui-Xuan", "Florent Krasnopol", "Bruno Monasson", "Nathalie Sznajder"], "title": "Model checking with temporal graphs and their derivative", "comment": null, "summary": "Temporal graphs are graphs where the presence or properties of their vertices and edges change over time. When time is discrete, a temporal graph can be defined as a sequence of static graphs over a discrete time span, called lifetime, or as a single graph where each edge is associated with a specific set of time instants where the edge is alive. For static graphs, Courcelle's Theorem asserts that any graph problem expressible in monadic second-order logic can be solved in linear time on graphs of bounded tree-width. We propose the first adaptation of Courcelle's Theorem for monadic second-order logic on temporal graphs that does not explicitly rely on the lifetime as a parameter. We then introduce the notion of derivative over a sliding time window of a chosen size, and define the tree-width and twin-width of the temporal graph's derivative. We exemplify its usefulness with meta theorems with respect to a temporal variant of first-order logic. The resulting logic expresses a wide range of temporal graph problems including a version of temporal cliques, an important notion when querying time series databases for community structures."}
{"id": "2602.12973", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2602.12973", "abs": "https://arxiv.org/abs/2602.12973", "authors": ["Federico Bruzzone", "Walter Cazzola"], "title": "Meta-Monomorphizing Specializations", "comment": "31 pages", "summary": "Achieving zero-cost specialization remains a fundamental challenge in programming language and compiler design. It often necessitates trade-offs between expressive power and type system soundness, as the interaction between conditional compilation and static dispatch can easily lead to unforeseen coherence violations and increased complexity in the formal model. This paper introduces meta-monomorphizing specializations, a novel framework that achieves specialization by repurposing monomorphization through compile-time metaprogramming. Instead of modifying the host compiler, our approach generates meta-monomorphized traits and implementations that encode specialization constraints directly into the type structure, enabling deterministic, coherent dispatch without overlapping instances. We formalize this method for first-order, predicate-based, and higher-ranked polymorphic specialization, also in presence of lifetime parameters. Our evaluation, based on a Rust implementation using only existing macro facilities, demonstrates that meta-monomorphization enables expressive specialization patterns -- previously rejected by the compiler -- while maintaining full compatibility with standard optimization pipelines. We show that specialization can be realized as a disciplined metaprogramming layer, offering a practical, language-agnostic path to high-performance abstraction. A comprehensive study of public Rust codebases further validates our approach, revealing numerous workarounds that meta-monomorphization can eliminate, leading to more idiomatic and efficient code."}
{"id": "2602.12894", "categories": ["cs.DC", "cs.DM"], "pdf": "https://arxiv.org/pdf/2602.12894", "abs": "https://arxiv.org/abs/2602.12894", "authors": ["Jérémie Chalopin", "Victor Chepoi", "Maria Kokkou"], "title": "Distance-based certification for leader election in meshed graphs and local recognition of their subclasses", "comment": null, "summary": "In this paper, we present a 2-local proof labeling scheme with labels in $\\{ 0,1,2\\}$ for leader election in anonymous meshed graphs. Meshed graphs form a general class of graphs defined by a distance condition. They comprise several important classes of graphs, which have long been the subject of intensive studies in metric graph theory, geometric group theory, and discrete mathematics: median graphs, bridged graphs, chordal graphs, Helly graphs, dual polar graphs, modular, weakly modular graphs, and basis graphs of matroids. We also provide 3-local proof labeling schemes to recognize these subclasses of meshed graphs using labels of size $O(\\log D)$ (where $D$ is the diameter of the graph).\n  To establish these results, we show that in meshed graphs, we can verify locally that every vertex $v$ is labeled by its distance $d(s,v)$ to an arbitrary root $s$. To design proof labeling schemes to recognize the subclasses of meshed graphs mentioned above, we use this distance verification to ensure that the triangle-square complex of the graph is simply connected and we then rely on existing local-to-global characterizations for the different classes we consider.\n  To get a proof-labeling scheme for leader election with labels of constant size, we then show that we can check locally if every $v$ is labeled by $d(s,v) \\pmod{3}$ for some root $s$ that we designate as the leader."}
{"id": "2602.12847", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2602.12847", "abs": "https://arxiv.org/abs/2602.12847", "authors": ["Alexandros Patras", "Spyros Lalis", "Christos D. Antonopoulos", "Nikolaos Bellas"], "title": "DPUConfig: Optimizing ML Inference in FPGAs Using Reinforcement Learning", "comment": "8 pages, 6 figures, to appear in the proceedings of DATE 2026", "summary": "Heterogeneous embedded systems, with diverse computing elements and accelerators such as FPGAs, offer a promising platform for fast and flexible ML inference, which is crucial for services such as autonomous driving and augmented reality, where delays can be costly. However, efficiently allocating computational resources for deep learning applications in FPGA-based systems is a challenging task. A Deep Learning Processor Unit (DPU) is a parameterizable FPGA-based accelerator module optimized for ML inference. It supports a wide range of ML models and can be instantiated multiple times within a single FPGA to enable concurrent execution. This paper introduces DPUConfig, a novel runtime management framework, based on a custom Reinforcement Learning (RL) agent, that dynamically selects optimal DPU configurations by leveraging real-time telemetry data monitoring, system utilization, power consumption, and application performance to inform its configuration selection decisions. The experimental evaluation demonstrates that the RL agent achieves energy efficiency 95% (on average) of the optimal attainable energy efficiency for several CNN models on the Xilinx Zynq UltraScale+ MPSoC ZCU102."}
{"id": "2602.12632", "categories": ["cs.DS", "cs.GT"], "pdf": "https://arxiv.org/pdf/2602.12632", "abs": "https://arxiv.org/abs/2602.12632", "authors": ["Mohammad Mahdian", "Jieming Mao", "Enze Sun", "Kangning Wang", "Yifan Wang"], "title": "Additively Competitive Secretaries", "comment": null, "summary": "In the secretary problem, a set of secretary candidates arrive in a uniformly random order and reveal their values one by one. A company, who can only hire one candidate and hopes to maximize the expected value of its hire, needs to make irrevocable online decisions about whether to hire the current candidate. The classical framework of evaluating a policy is to compute its worst-case competitive ratio against the optimal solution in hindsight, and there the best policy -- the ``$1/e$ law'' -- has a competitive ratio of $1/e$.\n  We propose an alternative evaluation framework through the lens of regret -- the worst-case additive difference between the optimal hindsight solution and the expected performance of the policy, assuming that each value is normalized between $0$ and $1$. The $1/e$ law for the classical framework has a regret of $1 - 1/e \\approx 0.632$; by contrast, we show that the class of ``pricing curves'' algorithms can guarantee a regret of at most $1/4 = 0.25$ (which is tight within the class), and the class of ``best-only pricing curves'' algorithms can guarantee a regret of at most $0.190$ (with a lower bound of $0.171$). In addition, we show that in general, no policy can give a regret guarantee better than $0.152$. Finally, we discuss other objectives in our regret-minimization framework, such as selecting the top-$k$ candidates for $k > 1$, or maximizing revenue during the selection process."}
{"id": "2602.13046", "categories": ["cs.DC", "cs.CC", "cs.FL"], "pdf": "https://arxiv.org/pdf/2602.13046", "abs": "https://arxiv.org/abs/2602.13046", "authors": ["Thomas Boudier", "Fabian Kuhn", "Augusto Modanese", "Ronja Stimpert", "Jukka Suomela"], "title": "Classification of Local Optimization Problems in Directed Cycles", "comment": "26 pages, 2 figures", "summary": "We present a complete classification of the distributed computational complexity of local optimization problems in directed cycles for both the deterministic and the randomized LOCAL model. We show that for any local optimization problem $Π$ (that can be of the form min-sum, max-sum, min-max, or max-min, for any local cost or utility function over some finite alphabet), and for any \\emph{constant} approximation ratio $α$, the task of finding an $α$-approximation of $Π$ in directed cycles has one of the following complexities:\n  1. $O(1)$ rounds in deterministic LOCAL, $O(1)$ rounds in randomized LOCAL,\n  2. $Θ(\\log^* n)$ rounds in deterministic LOCAL, $O(1)$ rounds in randomized LOCAL,\n  3. $Θ(\\log^* n)$ rounds in deterministic LOCAL, $Θ(\\log^* n)$ rounds in randomized LOCAL,\n  4. $Θ(n)$ rounds in deterministic LOCAL, $Θ(n)$ rounds in randomized LOCAL.\n  Moreover, for any given $Π$ and $α$, we can determine the complexity class automatically, with an efficient (centralized, sequential) meta-algorithm, and we can also efficiently synthesize an asymptotically optimal distributed algorithm.\n  Before this work, similar results were only known for local search problems (e.g., locally checkable labeling problems). The family of local optimization problems is a strict generalization of local search problems, and it contains numerous commonly studied distributed tasks, such as the problems of finding approximations of the maximum independent set, minimum vertex cover, minimum dominating set, and minimum vertex coloring."}
{"id": "2602.12962", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2602.12962", "abs": "https://arxiv.org/abs/2602.12962", "authors": ["Jonghun Lee", "Junghoon Lee", "Hyeonjin Kim", "Seoho Jeon", "Jisup Yoon", "Hyunbin Park", "Meejeong Park", "Heonjae Ha"], "title": "TriGen: NPU Architecture for End-to-End Acceleration of Large Language Models based on SW-HW Co-Design", "comment": "13 pages, 14 figures", "summary": "Recent studies have extensively explored NPU architectures for accelerating AI inference in on-device environments, which are inherently resource-constrained. Meanwhile, transformer-based large language models (LLMs) have become dominant, with rapidly increasing model sizes but low degree of parameter reuse compared to conventional CNNs, making end-to-end execution on resource-limited devices extremely challenging. To address these challenges, we propose TriGen, a novel NPU architecture tailored for resource-constrained environments through software-hardware co-design. Firstly, TriGen adopts low-precision computation using microscaling (MX) to enable additional optimization opportunities while preserving accuracy, and resolves the issues that arise by employing such precision. Secondly, to jointly optimize both nonlinear and linear operations, TriGen eliminates the need for specialized hardware for essential nonlinear operations by using fast and accurate LUT, thereby maximizing performance gains and reducing hardware-cost in on-device environments, and finally, by taking practical hardware constraints into account, further employs scheduling techniques to maximize computational utilization even under limited on-chip memory capacity. We evaluate the performance of TriGen on various LLMs and show that TriGen achieves an average 2.73x performance speedup and 52% less memory transfer over the baseline NPU design with negligible accuracy loss."}
{"id": "2602.12645", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.12645", "abs": "https://arxiv.org/abs/2602.12645", "authors": ["Yu Chen", "Zihan Tan", "Mingyang Yang"], "title": "Lower Bounds on Flow Sparsifiers with Steiner Nodes", "comment": null, "summary": "Given a large graph $G$ with a set of its $k$ vertices called terminals, a \\emph{quality-$q$ flow sparsifier} is a small graph $G'$ that contains the terminals and preserves all multicommodity flows between them up to some multiplicative factor $q\\ge 1$, called the \\emph{quality}. Constructing flow sparsifiers with good quality and small size ($|V(G')|$) has been a central problem in graph compression. The most common approach of constructing flow sparsifiers is contraction: first compute a partition of the vertices in $V(G)$, and then contract each part into a supernode to obtain $G'$. When $G'$ is only allowed to contain all terminals, the best quality is shown to be $O(\\log k/\\log\\log k)$ and $Ω(\\sqrt{\\log k/\\log\\log k})$. In this paper, we show that allowing a few Steiner nodes does not help much in improving the quality. Specifically, there exist $k$-terminal graphs such that, even if we allow $k\\cdot 2^{(\\log k)^{Ω(1)}}$ Steiner nodes in its contraction-based flow sparsifier, the quality is still $Ω\\big((\\log k)^{0.3}\\big)$."}
{"id": "2602.13167", "categories": ["cs.DC", "cs.CR"], "pdf": "https://arxiv.org/pdf/2602.13167", "abs": "https://arxiv.org/abs/2602.13167", "authors": ["Shlomi Dolev", "Ehud Gudes", "Daniel Shlomo"], "title": "Bloom Filter Look-Up Tables for Private and Secure Distributed Databases in Web3 (Revised Version)", "comment": null, "summary": "The rapid growth of decentralized systems in theWeb3 ecosystem has introduced numerous challenges, particularly in ensuring data security, privacy, and scalability [3, 8]. These systems rely heavily on distributed architectures, requiring robust mechanisms to manage data and interactions among participants securely. One critical aspect of decentralized systems is key management, which is essential for encrypting files, securing database segments, and enabling private transactions. However, securely managing cryptographic keys in a distributed environment poses significant risks, especially when nodes in the network can be compromised [9]. This research proposes a decentralized database scheme specifically designed for secure and private key management. Our approach ensures that cryptographic keys are not stored explicitly at any location, preventing their discovery even if an attacker gains control of multiple nodes. Instead of traditional storage, keys are encoded and distributed using the BFLUT (Bloom Filter for Private Look-Up Tables) algorithm [7], which enables secure retrieval without direct exposure. The system leverages OrbitDB [4], IPFS [1], and IPNS [10] for decentralized data management, providing robust support for consistency, scalability, and simultaneous updates. By combining these technologies, our scheme enhances both security and privacy while maintaining high performance and reliability. Our findings demonstrate the system's capability to securely manage keys, prevent unauthorized access, and ensure privacy, making it a foundational solution for Web3 applications requiring decentralized security."}
{"id": "2602.12667", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.12667", "abs": "https://arxiv.org/abs/2602.12667", "authors": ["Yen-Cheng Chang", "Tsun Ming Cheung", "Meng-Tsung Tsai", "Ting-An Wu"], "title": "Efficient Streaming Algorithms for Two-Dimensional Congruence Testing and Geometric Hashing", "comment": null, "summary": "The geometric congruence problem is a fundamental building block in many computer vision and image recognition tasks. This problem considers the decision task of whether two point sets are congruent under translation and rotation. A related and more general problem, geometric hashing, considers the task of compactly encoding multiple point sets for efficient congruence queries. Despite its wide applications, both problems have received little prior attention in space-aware settings.\n  In this work, we study the two-dimensional congruence testing and geometric hashing problem in the streaming model, where data arrive as a stream and the primary goal is to minimize the space usage. To meaningfully analyze space complexity, we address the underaddressed issue of input precision by working in the finite-precision rational setting: the input point coordinates are rational numbers of the form $p/q$ with $|p|, |q| \\le U$.\n  Our result considers a stronger variant of congruence testing called congruence identification, for which we obtain a 3-pass randomized streaming algorithm using $O(\\log n(\\log U+\\log n))$ space. Using the congruence identification algorithm as a building block, we give a 6-pass $O(m\\log n (\\log n + \\log U + \\log m))$-space randomized streaming algorithm that outputs a hash function of length $O(\\log n+\\log U+\\log m)$.\n  Our key technical tool for achieving space efficiency is the use of complex moments. While complex moment methods are widely employed as heuristics in object recognition, their effectiveness is often limited by vanishing moment issues (Flusser and Suk [IEEE Trans. Image Process 2006]). We show that, in the rational setting, it suffices to track only $O(\\log n)$ complex moments to ensure a non-vanishing moment, thus providing a sound theoretical guarantee for recovering a valid rotation in positive instances."}
{"id": "2602.12668", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.12668", "abs": "https://arxiv.org/abs/2602.12668", "authors": ["Ho-Lin Chen", "Tsun Ming Cheung", "Peng-Ting Lin", "Meng-Tsung Tsai"], "title": "Independence-Number Parameterized Space Complexity for Directed Connectivity Certificate", "comment": null, "summary": "We study the space complexity of computing a sparse subgraph of a directed graph that certifies connectivity in the streaming and distributed models. Formally, for a directed graph $G=(V,A)$ and $k\\in \\mathbb{N}$, a $k$-node strong connectivity certificate is a subgraph $H=(V,A')\\subseteq G$ such that for every pair of distinct nodes $s,t\\in V$, the number of pairwise internally node-disjoint paths from $s$ to $t$ in $H$ is at least $k$ or the corresponding number in $G$. In light of the inherent hardness of directed connectivity problems, several prior work focused on restricted graph classes, showing that several problems that are hard in general become efficiently solvable when the input graph is a tournament (i.e., a directed complete graph) (Chakrabarti et al. [SODA 2020]; Baweja, Jia, and Woddruff [ITCS 2022]), or close to a tournament in edit distance (Ghosh and Kuchlous [ESA 2024]). Extending this line of work, our main result shows, at a qualitative level, that the streaming complexity of strong connectivity certificates and related problems is parameterized by independence number, demonstrating a continuum of hardness for directed graph connectivity problems. Quantitatively, for an $n$-node graph with independence number $α$, we give $p$-pass randomized algorithms that compute a $k$-node strong connectivity certificate of size $O(αn)$ using $\\tilde{O}(k^{1-1/p}αn^{1+1/p})$ space in the insertion-only model. For the lower bound, we show that even when $k=1$, any $p$-pass streaming algorithm for a 1-node strong connectivity certificate in the insertion-only model requires $Ω(αn/p)$ space. To derive these lower bounds, we introduce the gadget-embedding tournament framework to construct direct-sum-type hard instances with a prescribed independence number, which is applicable to lower-bounding a wide range of directed graph problems."}
{"id": "2602.12716", "categories": ["cs.DS"], "pdf": "https://arxiv.org/pdf/2602.12716", "abs": "https://arxiv.org/abs/2602.12716", "authors": ["Alexander Lindermayr", "Guido Schäfer", "Jens Schlöter", "Leen Stougie"], "title": "Online Flow Time Minimization with Gradually Revealed Jobs", "comment": null, "summary": "We consider the problem of online preemptive scheduling on a single machine to minimize the total flow time. In clairvoyant scheduling, where job processing times are revealed upon arrival, the Shortest Remaining Processing Time (SRPT) algorithm is optimal. In practice, however, exact processing times are often unknown. At the opposite extreme, non-clairvoyant scheduling, in which processing times are revealed only upon completion, suffers from strong lower bounds on the competitive ratio. This motivates the study of intermediate information models. We introduce a new model in which processing times are revealed gradually during execution. Each job consists of a sequence of operations, and the processing time of an operation becomes known only after the preceding one completes. This models many scheduling scenarios that arise in computing systems.\n  Our main result is a deterministic $O(m^2)$-competitive algorithm, where $m$ is the maximum number of operations per job. More specifically, we prove a refined competitive ratio in $O(m_1 \\cdot m_2)$, where $m_1$ and $m_2$ are instance-dependent parameters describing the operation size structure. Our algorithm and analysis build on recent advancements in robust flow time minimization (SODA '26), where jobs arrive with estimated sizes. However, in our setting we have no bounded estimate on a job's processing time. Thus, we design a highly adaptive algorithm that gradually explores a job's operations while working on them, and groups them into virtual chunks whose size can be well-estimated. This is a crucial ingredient of our result and requires a much more careful analysis compared to the robust setting. We also provide lower bounds showing that our bounds are essentially best possible. For the special case of scheduling with uniform obligatory tests, we show that SRPT at the operation level is $2$-competitive, which is best possible."}
{"id": "2602.12925", "categories": ["cs.DS", "cs.DM", "math.CO"], "pdf": "https://arxiv.org/pdf/2602.12925", "abs": "https://arxiv.org/abs/2602.12925", "authors": ["Tomáš Masařík", "Michał Włodarczyk", "Mehmet Akif Yıldız"], "title": "Optimal Path Partitions in Subcubic and Almost-subcubic Graphs", "comment": "22 pages, 15 figures", "summary": "We consider the problem of partitioning the edges of a graph into as few paths as possible. This is a~subject of the classic conjecture of Gallai and a recurring topic in combinatorics. Regarding the complexity of partitioning a graph optimally, Peroché [Discret. Appl. Math., 1984] proved that it is NP-hard already on graphs of maximum degree four, even when we only ask if two paths suffice.\n  We show that the problem is solvable in polynomial time on subcubic graphs and then we present an efficient algorithm for ``almost-subcubic'' graphs. Precisely, we prove that the problem is fixed-parameter tractable when parameterized by the edge-deletion distance to a subcubic graph. To this end, we reduce the task to model checking in first-order logic extended by disjoint-paths predicates ($\\mathsf{FO}\\text{+}\\mathsf{DP}$) and then we employ the recent tractability result by Schirrmacher, Siebertz, Stamoulis, Thilikos, and Vigny [LICS 2024]."}
